<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="Jetty Developers">
<title>Eclipse Jetty: Programming Guide</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="./coderay-asciidoctor.css">
<link rel="stylesheet" href="../styles.css">
<link rel="stylesheet" href="../toc.css">
<script src="../toc.js"></script>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1><a href="https://eclipse.dev/jetty">Eclipse Jetty</a>: Programming Guide</h1>
<div class="details">
<span id="author" class="author">Jetty Developers</span><br>
<span id="email" class="email"><a href="mailto:jetty-dev@eclipse.org">jetty-dev@eclipse.org</a></span><br>
<span id="revnumber">version 12.0.10-SNAPSHOT,</span>
<span id="revdate">2024-05-07</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Programming Guide</div>
<ul class="sectlevel1">
<li><a href="#pg-intro">Eclipse Jetty Programming Guide</a></li>
<li><a href="#pg-client">Client Libraries</a>
<ul class="sectlevel2">
<li><a href="#pg-client-io-arch">I/O Architecture</a>
<ul class="sectlevel3">
<li><a href="#pg-client-io-arch-transport">Transport Layer</a>
<ul class="sectlevel4">
<li><a href="#pg-client-io-arch-unix-domain">Unix-Domain Support</a></li>
<li><a href="#pg-client-io-arch-memory">Memory Support</a></li>
</ul>
</li>
<li><a href="#pg-client-io-arch-protocol">Protocol Layer</a></li>
</ul>
</li>
<li><a href="#pg-client-http">HTTP Client</a>
<ul class="sectlevel3">
<li><a href="#pg-client-http-intro">HttpClient Introduction</a></li>
<li><a href="#pg-client-http-start">Starting HttpClient</a></li>
<li><a href="#pg-client-http-stop">Stopping HttpClient</a></li>
<li><a href="#pg-client-http-arch">HttpClient Architecture</a></li>
<li><a href="#pg-client-http-connection-pool">HttpClient Connection Pooling</a></li>
<li><a href="#pg-client-http-request-processing">HttpClient Request Processing</a></li>
<li><a href="#pg-client-http-api">HttpClient API Usage</a>
<ul class="sectlevel4">
<li><a href="#pg-client-http-blocking">HttpClient Blocking APIs</a></li>
<li><a href="#pg-client-http-non-blocking">HttpClient Non-Blocking APIs</a></li>
<li><a href="#pg-client-http-content-request">Request Content Handling</a></li>
<li><a href="#pg-client-http-content-response">Response Content Handling</a></li>
<li><a href="#pg-client-http-api-transport">Request <code>Transport</code></a></li>
</ul>
</li>
<li><a href="#pg-client-http-configuration">HttpClient Configuration</a>
<ul class="sectlevel4">
<li><a href="#pg-client-http-configuration-tls">HttpClient TLS Configuration</a>
<ul class="sectlevel5">
<li><a href="#pg-client-http-configuration-tls-listener">HttpClient <code>SslHandshakeListener</code></a></li>
<li><a href="#pg-client-http-configuration-tls-truststore">HttpClient TLS TrustStore Configuration</a></li>
<li><a href="#pg-client-http-configuration-tls-client-certs">HttpClient TLS Client Certificates Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-client-http-cookie">HttpClient Cookie Support</a>
<ul class="sectlevel4">
<li><a href="#pg-special-characters-in-cookies">Special Characters in Cookies</a></li>
</ul>
</li>
<li><a href="#pg-client-http-authentication">HttpClient Authentication Support</a>
<ul class="sectlevel4">
<li><a href="#pg-client-http-authentication-spnego">HttpClient SPNEGO Authentication Support</a></li>
</ul>
</li>
<li><a href="#pg-client-http-proxy">HttpClient Proxy Support</a>
<ul class="sectlevel4">
<li><a href="#pg-client-http-proxy-socks5">SOCKS5 Proxy Support</a></li>
<li><a href="#pg-client-http-proxy-authentication">HTTP Proxy Authentication Support</a></li>
</ul>
</li>
<li><a href="#pg-client-http-transport">HttpClient Pluggable Transports</a>
<ul class="sectlevel4">
<li><a href="#pg-client-http-transport-http11">HTTP/1.1 Transport</a></li>
<li><a href="#pg-client-http-transport-http2">HTTP/2 Transport</a></li>
<li><a href="#pg-client-http-transport-http3">HTTP/3 Transport</a></li>
<li><a href="#pg-client-http-transport-fcgi">FastCGI Transport</a></li>
<li><a href="#pg-client-http-transport-dynamic">Dynamic Transport</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-client-http2">HTTP/2 Client Library</a>
<ul class="sectlevel3">
<li><a href="#pg-client-http2-intro">Introducing HTTP2Client</a></li>
<li><a href="#pg-client-http2-flow-control">HTTP/2 Flow Control</a></li>
<li><a href="#pg-client-http2-connect">Connecting to the Server</a></li>
<li><a href="#pg-client-http2-configure">Configuring the Session</a></li>
<li><a href="#pg-client-http2-request">Sending a Request</a></li>
<li><a href="#pg-client-http2-response">Receiving a Response</a></li>
<li><a href="#pg-client-http2-reset">Resetting a Request or Response</a></li>
<li><a href="#pg-client-http2-push">Receiving HTTP/2 Pushes</a></li>
</ul>
</li>
<li><a href="#pg-client-http3">HTTP/3 Client Library</a>
<ul class="sectlevel3">
<li><a href="#pg-client-http3-intro">Introducing HTTP3Client</a></li>
<li><a href="#pg-client-http3-connect">Connecting to the Server</a></li>
<li><a href="#pg-client-http3-configure">Configuring the Session</a></li>
<li><a href="#pg-client-http3-request">Sending a Request</a></li>
<li><a href="#pg-client-http3-response">Receiving a Response</a></li>
<li><a href="#pg-client-http3-reset">Resetting a Request or Response</a></li>
</ul>
</li>
<li><a href="#pg-client-websocket">WebSocket Client</a>
<ul class="sectlevel3">
<li><a href="#pg-client-websocket-start">Starting WebSocketClient</a></li>
<li><a href="#pg-client-websocket-stop">Stopping WebSocketClient</a></li>
<li><a href="#pg-client-websocket-connect">Connecting to a Remote Host</a>
<ul class="sectlevel4">
<li><a href="#pg-client-websocket-connect-http11">Using HTTP/1.1</a></li>
<li><a href="#pg-client-websocket-connect-http2">Using HTTP/2</a></li>
<li><a href="#pg-client-websocket-connect-custom-http-request">Customizing the Initial HTTP Request</a></li>
<li><a href="#pg-client-websocket-connect-inspect-http-response">Inspecting the Initial HTTP Response</a></li>
</ul>
</li>
<li><a href="#pg-websocket-architecture">Jetty WebSocket Architecture</a></li>
<li><a href="#pg-websocket-endpoints">WebSocket Endpoints</a>
<ul class="sectlevel4">
<li><a href="#pg-websocket-endpoints-demand">WebSocket Events Demand</a></li>
<li><a href="#pg-websocket-endpoints-listener">Listener Endpoints</a>
<ul class="sectlevel5">
<li><a href="#pg-message-streaming-reads">Message Streaming Reads</a></li>
</ul>
</li>
<li><a href="#pg-websocket-endpoints-annotated">Annotated Endpoints</a>
<ul class="sectlevel5">
<li><a href="#pg-websocket-endpoints-annotated-streaming">Message Streaming Reads</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-websocket-session">WebSocket Session</a>
<ul class="sectlevel4">
<li><a href="#pg-websocket-session-configure">Configuring the Session</a></li>
<li><a href="#pg-websocket-session-send">Sending Data</a>
<ul class="sectlevel5">
<li><a href="#pg-websocket-session-send-stream">Streaming Send APIs</a></li>
</ul>
</li>
<li><a href="#pg-websocket-session-ping">Sending Ping/Pong</a></li>
<li><a href="#pg-websocket-session-close">Closing the Session</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server">Server Libraries</a>
<ul class="sectlevel2">
<li><a href="#pg-server-http">HTTP Server Libraries</a>
<ul class="sectlevel3">
<li><a href="#pg-server-http-request-processing">Request Processing</a>
<ul class="sectlevel4">
<li><a href="#pg-server-http-request-processing-events">Request Processing Events</a></li>
</ul>
</li>
<li><a href="#pg-server-http-request-logging">Request Logging</a></li>
<li><a href="#pg-server-http-request-customizers">Request Customizers</a>
<ul class="sectlevel4">
<li><a href="#pg-server-http-request-customizer-forwarded"><code>ForwardedRequestCustomizer</code></a></li>
<li><a href="#pg-server-http-request-customizer-host"><code>HostHeaderCustomizer</code></a></li>
<li><a href="#pg-server-http-request-customizer-proxy"><code>ProxyCustomizer</code></a></li>
<li><a href="#pg-server-http-request-customizer-rewrite"><code>RewriteCustomizer</code></a></li>
<li><a href="#pg-server-http-request-customizer-secure"><code>SecureRequestCustomizer</code></a></li>
</ul>
</li>
<li><a href="#pg-server-http-connector">Server Connectors</a>
<ul class="sectlevel4">
<li><a href="#pg-server-http-connector-acceptors">Acceptors</a></li>
<li><a href="#pg-server-http-connector-selectors">Selectors</a></li>
<li><a href="#pg-server-http-connector-multiple">Multiple Connectors</a></li>
<li><a href="#pg-server-http-connector-protocol">Configuring Protocols</a>
<ul class="sectlevel5">
<li><a href="#pg-server-http-connector-protocol-http11">Clear-Text HTTP/1.1</a></li>
<li><a href="#pg-server-http-connector-protocol-http11-tls">Encrypted HTTP/1.1 (https)</a></li>
<li><a href="#pg-server-http-connector-protocol-http2">Clear-Text HTTP/2</a></li>
<li><a href="#pg-server-http-connector-protocol-http2-tls">Encrypted HTTP/2</a></li>
<li><a href="#pg-server-http-connector-protocol-http3">HTTP/3</a></li>
<li><a href="#pg-server-http-connector-protocol-tls-conscrypt">Using Conscrypt as SSL/TLS Provider</a></li>
<li><a href="#pg-server-http-connector-protocol-proxy-http11">Jetty Behind a Load Balancer</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server-http-handler">Server Handlers</a>
<ul class="sectlevel4">
<li><a href="#pg-server-http-handler-use">Jetty Handlers</a>
<ul class="sectlevel5">
<li><a href="#pg-server-http-handler-use-context">ContextHandler</a></li>
<li><a href="#pg-server-http-handler-use-context-collection">ContextHandlerCollection</a></li>
<li><a href="#pg-server-http-handler-use-resource">ResourceHandler&#8201;&#8212;&#8201;Static Content</a></li>
<li><a href="#pg-server-http-handler-use-gzip">GzipHandler</a></li>
<li><a href="#pg-server-http-handler-use-rewrite">RewriteHandler</a></li>
<li><a href="#pg-server-http-handler-use-sizelimit">SizeLimitHandler</a></li>
<li><a href="#pg-server-http-handler-use-statistics">StatisticsHandler</a></li>
<li><a href="#pg-server-http-handler-use-events">EventsHandler</a></li>
<li><a href="#pg-server-http-handler-use-qos">QoSHandler</a></li>
<li><a href="#pg-server-http-handler-use-secured">SecuredRedirectHandler&#8201;&#8212;&#8201;Redirect from HTTP to HTTPS</a></li>
<li><a href="#pg-server-http-handler-use-cross-origin">CrossOriginHandler</a></li>
<li><a href="#pg-server-http-handler-use-default">DefaultHandler</a></li>
</ul>
</li>
<li><a href="#pg-server-http-handler-use-servlet">Servlet API Handlers</a>
<ul class="sectlevel5">
<li><a href="#pg-server-http-handler-use-servlet-context">ServletContextHandler</a></li>
<li><a href="#pg-server-http-handler-use-webapp-context">WebAppContext</a></li>
<li><a href="#pg-server-http-handler-use-default-servlet">DefaultServlet&#8201;&#8212;&#8201;Static Content for Servlets</a></li>
</ul>
</li>
<li><a href="#pg-server-http-handler-impl">Implementing Handler</a>
<ul class="sectlevel5">
<li><a href="#pg-server-http-handler-impl-hello">Hello World <code>Handler</code></a></li>
<li><a href="#pg-server-http-handler-impl-filter">Filtering <code>Handler</code></a></li>
<li><a href="#pg-server-http-handler-impl-request">Using the <code>Request</code></a></li>
<li><a href="#pg-server-http-handler-impl-request-content">Reading the <code>Request</code> Content</a></li>
<li><a href="#pg-server-http-handler-impl-request-listeners"><code>Request</code> Listeners</a></li>
<li><a href="#pg-server-http-handler-impl-response">Using the <code>Response</code></a></li>
<li><a href="#pg-server-http-handler-impl-response-content">Writing the <code>Response</code> Content</a></li>
<li><a href="#pg-server-http-handler-impl-response-interim">Sending Interim <code>Response</code>s</a></li>
</ul>
</li>
<li><a href="#pg-server-http-session">HTTP Session Support</a></li>
<li><a href="#pg-server-http-security">Securing HTTP Server Applications</a></li>
<li><a href="#pg-server-http-application">Writing HTTP Server Applications</a>
<ul class="sectlevel5">
<li><a href="#pg-server-http-application-1xx">Sending 1xx Responses</a></li>
<li><a href="#pg-server-http-application-100">100 Continue</a></li>
<li><a href="#jetty-102-processing">102 Processing</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server-http2">HTTP/2 Server Library</a>
<ul class="sectlevel3">
<li><a href="#pg-server-http2-intro">Introduction</a></li>
<li><a href="#pg-server-http2-flow-control">HTTP/2 Flow Control</a></li>
<li><a href="#pg-server-http2-setup">Server Setup</a></li>
<li><a href="#pg-server-http2-request">Receiving a Request</a></li>
<li><a href="#pg-server-http2-response">Sending a Response</a></li>
<li><a href="#pg-server-http2-reset">Resetting a Request</a></li>
<li><a href="#pg-server-http2-push">HTTP/2 Push of Resources</a></li>
</ul>
</li>
<li><a href="#pg-server-http3">HTTP/3 Server Library</a>
<ul class="sectlevel3">
<li><a href="#pg-server-http3-intro">Introduction</a></li>
<li><a href="#pg-server-http3-setup">Server Setup</a></li>
<li><a href="#pg-server-http3-request">Receiving a Request</a></li>
<li><a href="#pg-server-http3-response">Sending a Response</a></li>
<li><a href="#pg-server-http3-reset">Resetting a Request</a></li>
</ul>
</li>
<li><a href="#pg-server-compliance">Server Compliance Modes</a>
<ul class="sectlevel3">
<li><a href="#pg-server-compliance-http">HTTP Compliance Modes</a></li>
<li><a href="#pg-server-compliance-uri">URI Compliance Modes</a></li>
<li><a href="#pg-server-compliance-cookie">Cookie Compliance Modes</a></li>
</ul>
</li>
<li><a href="#pg-server-session">HTTP Session Management</a>
<ul class="sectlevel3">
<li><a href="#pg-server-session-architecture">Session Architecture</a></li>
<li><a href="#pg-server-session-idmgr">The SessionIdManager</a>
<ul class="sectlevel4">
<li><a href="#pg-server-session-defaultidmgr">The DefaultSessionIdManager</a></li>
<li><a href="#pg-server-session-housekeeper">The HouseKeeper</a></li>
<li><a href="#pg-implementing-a-custom-sessionidmanager">Implementing a Custom SessionIdManager</a></li>
</ul>
</li>
<li><a href="#pg-server-session-handler">The SessionHandler</a>
<ul class="sectlevel4">
<li><a href="#pg-statistics">Statistics</a></li>
</ul>
</li>
<li><a href="#pg-server-session-cache">The SessionCache</a>
<ul class="sectlevel4">
<li><a href="#pg-server-session-hash">The DefaultSessionCache</a></li>
<li><a href="#pg-server-session-null">The NullSessionCache</a></li>
<li><a href="#pg-server-session-customcache">Implementing a custom SessionCache</a></li>
<li><a href="#pg-heterogeneous-caching">Heterogeneous caching</a></li>
</ul>
</li>
<li><a href="#pg-server-session-datastore">The SessionDataStore</a>
<ul class="sectlevel4">
<li><a href="#pg-custom-sessiondatastores">Custom SessionDataStores</a></li>
<li><a href="#pg-the-sessiondatastorefactory">The SessionDataStoreFactory</a></li>
<li><a href="#pg-server-session-datastore-null">The NullSessionDataStore</a></li>
<li><a href="#pg-server-session-datastore-file">The FileSessionDataStore</a></li>
<li><a href="#pg-server-session-datastore-jdbc">The JDBCSessionDataStore</a>
<ul class="sectlevel5">
<li><a href="#pg-the-databaseadaptor">The DatabaseAdaptor</a></li>
<li><a href="#pg-the-sessiontableschema">The SessionTableSchema</a></li>
</ul>
</li>
<li><a href="#pg-server-session-datastore-mongo">The MongoSessionDataStore</a></li>
<li><a href="#pg-server-session-datastore-infinispan">The InfinispanSessionDataStore</a></li>
<li><a href="#pg-server-session-datastore-gcloud">The GCloudSessionDataStore</a>
<ul class="sectlevel5">
<li><a href="#pg-server-session-datastore-gcloud-prep">Preparation</a></li>
<li><a href="#pg-configuration">Configuration</a></li>
</ul>
</li>
<li><a href="#pg-server-session-cachingsessiondatastore">The CachingSessionDataStore</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server-websocket">WebSocket Server</a>
<ul class="sectlevel3">
<li><a href="#pg-server-websocket-standard">Standard APIs Implementation</a>
<ul class="sectlevel4">
<li><a href="#pg-server-websocket-standard-container">Setting Up <code>ServerContainer</code></a></li>
<li><a href="#pg-server-websocket-standard-endpoints">Configuring Endpoints</a>
<ul class="sectlevel5">
<li><a href="#pg-server-websocket-standard-upgrade">Upgrade to WebSocket</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server-websocket-configure-filter">Advanced <code>WebSocketUpgradeFilter</code> Configuration</a></li>
<li><a href="#pg-server-websocket-jetty">Jetty APIs Implementation</a>
<ul class="sectlevel4">
<li><a href="#pg-server-websocket-jetty-container">Setting up <code>ServerWebSocketContainer</code></a>
<ul class="sectlevel5">
<li><a href="#pg-server-websocket-jetty-container-websocket-handler">Implicit setup using <code>WebSocketUpgradeHandler</code></a></li>
<li><a href="#pg-server-websocket-jetty-container-websocket-container">Explicit setup using <code>ServerWebSocketContainer</code></a></li>
</ul>
</li>
<li><a href="#pg-server-websocket-jetty-endpoints">WebSocket Endpoints</a>
<ul class="sectlevel5">
<li><a href="#pg-server-websocket-jetty-pathspec">Custom PathSpec Mappings</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-server-fastcgi">FastCGI Server Libraries</a></li>
<li><a href="#pg-server-io-arch">Server I/O Architecture</a>
<ul class="sectlevel3">
<li><a href="#pg-server-io-arch-connection-factory">Creating Connections with <code>ConnectionFactory</code></a></li>
<li><a href="#pg-server-io-arch-connection-factory-wrapping">Wrapping a <code>ConnectionFactory</code></a></li>
<li><a href="#pg-server-io-arch-connection-factory-detecting">Choosing <code>ConnectionFactory</code> via Bytes Detection</a></li>
<li><a href="#pg-server-io-arch-connection-factory-custom">Writing a Custom <code>ConnectionFactory</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#maven-and-jetty">Maven and Jetty</a>
<ul class="sectlevel2">
<li><a href="#jetty-maven-helloworld">Using Maven</a>
<ul class="sectlevel3">
<li><a href="#configuring-embedded-jetty-with-maven">Using Embedded Jetty with Maven</a>
<ul class="sectlevel4">
<li><a href="#creating-helloworld-class">Creating the HelloWorld Class</a></li>
<li><a href="#creating-embedded-pom-descriptor">Creating the POM Descriptor</a></li>
<li><a href="#buildng-and-running-embedded-helloworld">Building and Running Embedded HelloWorld</a></li>
</ul>
</li>
<li><a href="#developing-standard-webapp-with-jetty-and-maven">Developing a Standard WebApp with Jetty and Maven</a>
<ul class="sectlevel4">
<li><a href="#creating-servlet">Creating a Servlet</a></li>
<li><a href="#creating-plugin-pom-descriptor">Creating the POM Descriptor</a></li>
<li><a href="#building-and-running-web-application">Building and Running the Web Application</a></li>
<li><a href="#building-war-file">Building a WAR file</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jetty-maven-plugin">Using the Jetty Maven Plugin</a>
<ul class="sectlevel3">
<li><a href="#get-up-and-running">Get Up and Running</a></li>
<li><a href="#supported-goals">Supported Goals</a></li>
<li><a href="#deployment-modes">Deployment Modes</a>
<ul class="sectlevel4">
<li><a href="#pg-embedded">Embedded</a></li>
<li><a href="#pg-forked">Forked</a></li>
<li><a href="#pg-in-a-jetty-distribution">In a jetty distribution</a></li>
</ul>
</li>
<li><a href="#common-configuration">Common Configuration</a></li>
<li><a href="#container-classpath">Container Classpath vs WebApp Classpath</a></li>
<li><a href="#jetty-run-goal">jetty:run</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-2">Configuration</a></li>
</ul>
</li>
<li><a href="#jetty-run-war-goal">jetty:run-war</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-3">Configuration</a></li>
</ul>
</li>
<li><a href="#jetty-start-goal">jetty:start</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-4">Configuration</a></li>
</ul>
</li>
<li><a href="#jetty-start-war-goal">jetty:start-war</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-5">Configuration</a></li>
</ul>
</li>
<li><a href="#jetty-stop-goal">jetty:stop</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-6">Configuration</a></li>
</ul>
</li>
<li><a href="#jetty-effective-web-xml-goal">jetty:effective-web-xml</a>
<ul class="sectlevel4">
<li><a href="#pg-configuration-7">Configuration</a></li>
</ul>
</li>
<li><a href="#using-overlaid-wars">Using Overlaid wars</a>
<ul class="sectlevel4">
<li><a href="#pg-with-maven-war-plugin">With maven-war-plugin</a></li>
<li><a href="#pg-without-maven-war-plugin">Without maven-war-plugin</a></li>
</ul>
</li>
<li><a href="#configuring-security-settings">Configuring Security Settings</a></li>
<li><a href="#using-multiple-webapp-root-directories">Using Multiple Webapp Root Directories</a></li>
<li><a href="#running-more-than-one-webapp">Running More than One Webapp</a>
<ul class="sectlevel4">
<li><a href="#pg-with-jettyrun">With jetty:run</a></li>
</ul>
</li>
<li><a href="#setting-system-properties">Setting System Properties</a>
<ul class="sectlevel4">
<li><a href="#specifying-properties-in-pom">Specifying System Properties in the POM</a></li>
<li><a href="#specifying-properties-in-file">Specifying System Properties in a File</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jetty-jspc-maven-plugin">Jetty Jspc Maven Plugin</a>
<ul class="sectlevel3">
<li><a href="#jspc-config">Configuration</a></li>
<li><a href="#jspc-production-precompile">Precompiling only for Production Build</a></li>
<li><a href="#jspc-overlay-precompile">Precompiling Jsps with Overlaid Wars</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-arch">Appendix A: Jetty Architecture</a>
<ul class="sectlevel2">
<li><a href="#pg-arch-bean">Jetty Component Architecture</a>
<ul class="sectlevel3">
<li><a href="#pg-arch-bean-lifecycle">Jetty Component Lifecycle</a></li>
<li><a href="#pg-arch-bean-listener">Jetty Component Listeners</a>
<ul class="sectlevel4">
<li><a href="#pg-arch-bean-listener-lifecycle">LifeCycle.Listener</a></li>
<li><a href="#pg-arch-bean-listener-container">Container.Listener</a></li>
<li><a href="#pg-arch-bean-listener-inherited">Container.InheritedListener</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-arch-threads">Jetty Threading Architecture</a>
<ul class="sectlevel3">
<li><a href="#pg-arch-threads-execution-strategy">Execution Strategies</a>
<ul class="sectlevel4">
<li><a href="#pg-arch-threads-execution-strategy-pc">Produce-Consume</a></li>
<li><a href="#pg-arch-threads-execution-strategy-pec">Produce-Execute-Consume</a></li>
<li><a href="#pg-arch-threads-execution-strategy-epc">Execute-Produce-Consume</a></li>
<li><a href="#pg-arch-threads-execution-strategy-adaptive">Adaptive Execution Strategy</a></li>
</ul>
</li>
<li><a href="#pg-arch-threads-thread-pool">Thread Pool</a>
<ul class="sectlevel4">
<li><a href="#pg-arch-threads-thread-pool-queue">Thread Pool Queue</a></li>
<li><a href="#pg-arch-threads-thread-pool-configuration"><code>QueuedThreadPool</code> configuration</a></li>
<li><a href="#pg-arch-threads-thread-pool-virtual-threads">Virtual Threads</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-arch-io">Jetty I/O Architecture</a>
<ul class="sectlevel3">
<li><a href="#pg-arch-io-selector-manager">Jetty I/O: <code>SelectorManager</code></a></li>
<li><a href="#pg-arch-io-endpoint-connection">Jetty I/O: <code>EndPoint</code> and <code>Connection</code></a></li>
<li><a href="#pg-arch-io-endpoint">Jetty I/O: <code>EndPoint</code></a></li>
<li><a href="#pg-arch-io-connection">Jetty I/O: <code>Connection</code></a>
<ul class="sectlevel4">
<li><a href="#pg-arch-io-connection-listener">Jetty I/O: <code>Connection.Listener</code></a></li>
</ul>
</li>
<li><a href="#pg-arch-io-echo">Jetty I/O: TCP Network Echo</a></li>
<li><a href="#pg-arch-io-content-source"><code>Content.Source</code></a>
<ul class="sectlevel4">
<li><a href="#pg-arch-io-content-source-chunk"><code>Content.Chunk</code></a></li>
</ul>
</li>
<li><a href="#pg-arch-io-content-sink"><code>Content.Sink</code></a></li>
</ul>
</li>
<li><a href="#pg-arch-listener">Jetty Listeners</a></li>
<li><a href="#pg-arch-jmx">Jetty JMX Support</a>
<ul class="sectlevel3">
<li><a href="#pg-enabling-jmx-support">Enabling JMX Support</a></li>
<li><a href="#pg-arch-jmx-remote">Enabling JMX Remote Access</a>
<ul class="sectlevel4">
<li><a href="#pg-arch-jmx-remote-authorization">JMX Remote Access Authorization</a></li>
<li><a href="#pg-securing-jmx-remote-access-with-tls">Securing JMX Remote Access with TLS</a></li>
<li><a href="#pg-arch-jmx-remote-ssh-tunnel">JMX Remote Access with Port Forwarding via SSH Tunnel</a></li>
</ul>
</li>
<li><a href="#pg-arch-jmx-annotation">Jetty JMX Annotations</a>
<ul class="sectlevel4">
<li><a href="#pg-managedobject">@ManagedObject</a></li>
<li><a href="#pg-managedattribute">@ManagedAttribute</a></li>
<li><a href="#pg-managedoperation">@ManagedOperation</a></li>
<li><a href="#pg-name">@Name</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-troubleshooting">Appendix B: Troubleshooting Jetty</a>
<ul class="sectlevel2">
<li><a href="#pg-troubleshooting-logging">Logging</a>
<ul class="sectlevel3">
<li><a href="#pg-jetty-slf4j-binding">Jetty SLF4J Binding</a></li>
</ul>
</li>
<li><a href="#pg-troubleshooting-thread-dump">JVM Thread Dump</a></li>
<li><a href="#pg-troubleshooting-component-dump">Jetty Component Tree Dump</a></li>
<li><a href="#pg-troubleshooting-debugging">Debugging</a></li>
</ul>
</li>
<li><a href="#pg-migration">Appendix C: Migration Guides</a>
<ul class="sectlevel2">
<li><a href="#pg-migration-94-to-10">Migrating from Jetty 9.4.x to Jetty 10.0.x</a>
<ul class="sectlevel3">
<li><a href="#pg-migration-94-to-10-java-version">Required Java Version Changes</a></li>
<li><a href="#pg-migration-94-to-10-websocket">WebSocket Migration Guide</a>
<ul class="sectlevel4">
<li><a href="#pg-migration-94-to-10-websocket-maven-artifact-changes">Maven Artifacts Changes</a></li>
<li><a href="#pg-migration-94-to-10-websocket-class-name-changes">Class Names Changes</a></li>
<li><a href="#pg-migration-94-to-10-websocket-example-code">Example Code</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#pg-migration-11-to-12">Migrating from Jetty 11.0.x to Jetty 12.0.x</a>
<ul class="sectlevel3">
<li><a href="#pg-migration-11-to-12-java-version">Required Java Version Changes</a></li>
<li><a href="#pg-migration-11-to-12-maven-artifacts">Maven Artifacts Changes</a></li>
<li><a href="#pg-migration-11-to-12-class-packages-names">Class Packages/Names Changes</a></li>
<li><a href="#pg-migration-11-to-12-servlet-to-handler">Migrate Servlets to Jetty Handlers</a>
<ul class="sectlevel4">
<li><a href="#pg-handler-request-apis">Handler Request APIs</a></li>
<li><a href="#pg-handler-request-content-apis">Handler Request Content APIs</a></li>
<li><a href="#pg-handler-response-apis">Handler Response APIs</a></li>
<li><a href="#pg-handler-response-content-apis">Handler Response Content APIs</a></li>
</ul>
</li>
<li><a href="#pg-migration-11-to-12-api-changes">APIs Changes</a>
<ul class="sectlevel4">
<li><a href="#pg-httpclient"><code>HttpClient</code></a></li>
<li><a href="#pg-websocket">WebSocket</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="pg-intro"><a class="anchor" href="#pg-intro"></a><a class="link" href="#pg-intro">Eclipse Jetty Programming Guide</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Eclipse Jetty Programming Guide targets developers who want to use the Jetty libraries in their applications.</p>
</div>
<div class="paragraph">
<p>The Jetty libraries provide the client-side and server-side APIs to work with various web protocols such as HTTP/1.1, HTTP/2, HTTP/3, WebSocket and FastCGI.</p>
</div>
<div class="paragraph">
<p>You may use the <a href="#pg-client">Jetty client-side library</a> in your application to make calls to third party REST services, or to other REST microservices in your system.</p>
</div>
<div class="paragraph">
<p>Likewise, you may use the <a href="#pg-server">Jetty server-side library</a> to quickly create an HTTP or REST service without having to create a web application archive file (a <code>*.war</code> file) and without having to deploy it to a Jetty standalone server that you would have to download and install.</p>
</div>
<div class="paragraph">
<p>This guide will walk you through the design of the Jetty libraries and how to use its classes to write your applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pg-client"><a class="anchor" href="#pg-client"></a><a class="link" href="#pg-client">Client Libraries</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Eclipse Jetty Project provides client-side libraries that allow you to embed an HTTP or WebSocket client in your applications.
A typical example is a client application that needs to contact a third party service via HTTP (for example a REST service).
Another example is a proxy application that receives HTTP requests and forwards them as FCGI requests to a PHP application such as WordPress, or receives HTTP/1.1 requests and converts them to HTTP/2 or HTTP/3.
Yet another example is a client application that needs to receive events from a WebSocket server.</p>
</div>
<div class="paragraph">
<p>The client libraries are designed to be non-blocking and offer both synchronous and asynchronous APIs and come with many configuration options.</p>
</div>
<div class="paragraph">
<p>These are the available client libraries:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pg-client-http">The High-Level HTTP Client Library</a> for HTTP/1.1, HTTP/2, HTTP/3 and FastCGI</p>
</li>
<li>
<p><a href="#pg-client-http2">The Low-Level HTTP/2 Client Library</a> for low-level HTTP/2</p>
</li>
<li>
<p><a href="#pg-client-http3">The Low-Level HTTP/3 Client Library</a> for low-level HTTP/3</p>
</li>
<li>
<p><a href="#pg-client-websocket">The WebSocket client library</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are interested in the low-level details of how the Jetty client libraries work, or are interested in writing a custom protocol, look at the <a href="#pg-client-io-arch">Client I/O Architecture</a>.</p>
</div>
<div class="sect2">
<h3 id="pg-client-io-arch"><a class="anchor" href="#pg-client-io-arch"></a><a class="link" href="#pg-client-io-arch">I/O Architecture</a></h3>
<div class="paragraph">
<p>The Jetty client libraries provide the basic components and APIs to implement a client application.</p>
</div>
<div class="paragraph">
<p>They build on the common <a href="#pg-arch-io">Jetty I/O Architecture</a> and provide client specific concepts (such as establishing a connection to a server).</p>
</div>
<div class="paragraph">
<p>There are conceptually two layers that compose the Jetty client libraries:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#pg-client-io-arch-transport">The transport layer</a>, that handles the low-level communication with the server, and deals with buffers, threads, etc.</p>
</li>
<li>
<p><a href="#pg-client-io-arch-protocol">The protocol layer</a>, that handles the high-level protocol by parsing the bytes read from the transport layer and by generating the bytes to write to the transport layer.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="pg-client-io-arch-transport"><a class="anchor" href="#pg-client-io-arch-transport"></a><a class="link" href="#pg-client-io-arch-transport">Transport Layer</a></h4>
<div class="paragraph">
<p>The transport layer is the low-level layer that communicates with the server.</p>
</div>
<div class="paragraph">
<p>Protocols such as HTTP/1.1 and HTTP/2 are typically transported over TCP, while the newer HTTP/3 is transported over QUIC, which is itself transported over UDP.</p>
</div>
<div class="paragraph">
<p>However, there are other means of communication supported by the Jetty client libraries, in particular over <a href="#pg-client-io-arch-unix-domain">Unix-Domain sockets</a> (for inter-process communication), and over <a href="#pg-client-io-arch-memory">memory</a> (for intra-process communication).</p>
</div>
<div class="paragraph">
<p>The same high-level protocol can be carried by different low-level transports.
For example, the high-level HTTP/1.1 protocol can be transported over either TCP (the default), or QUIC, or Unix-Domain sockets, or memory, because all these low-level transport provide reliable and ordered communication between client and server.</p>
</div>
<div class="paragraph">
<p>Similarly, the high-level HTTP/3 protocol can be transported over either QUIC (the default) or memory.
It would be possible to transport HTTP/3 also over Unix-Domain sockets, but the current version of Java only supports Unix-Domain sockets for <code>SocketChannel</code>s and not for <code>DatagramChannel</code>s.</p>
</div>
<div class="paragraph">
<p>The Jetty client libraries use the common I/O design described in <a href="#pg-arch-io">this section</a>.</p>
</div>
<div class="paragraph">
<p>The common I/O components and concepts are used for all low-level transports.
The only partial exception is the <a href="#pg-client-io-arch-memory">memory transport</a>, which is not based on network components; as such it does not need a <code>SelectorManager</code>, but it exposes <code>EndPoint</code> so that high-level protocols have a common interface to interact with the low-level transport.</p>
</div>
<div class="paragraph">
<p>The client-side abstraction for the low-level transport is <code>org.eclipse.jetty.io.Transport</code>.</p>
</div>
<div class="paragraph">
<p><code>Transport</code> represents how high-level protocols can be transported; there is <code>Transport.TCP_IP</code> that represents communication over TCP, but also <code>Transport.TCPUnix</code> for Unix-Domain sockets, <code>QuicTransport</code> for QUIC and <code>MemoryTransport</code> for memory.</p>
</div>
<div class="paragraph">
<p>Applications can specify the <code>Transport</code> to use for each request as described in <a href="#pg-client-http-api-transport">this section</a>.</p>
</div>
<div class="paragraph">
<p>When the <code>Transport</code> implementation uses the network, it delegates to <code>org.eclipse.jetty.io.ClientConnector</code>.</p>
</div>
<div class="paragraph">
<p><code>ClientConnector</code> primarily wraps <code>org.eclipse.jetty.io.SelectorManager</code> to provide network functionalities, and aggregates other four components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a thread pool (in form of an <code>java.util.concurrent.Executor</code>)</p>
</li>
<li>
<p>a scheduler (in form of <code>org.eclipse.jetty.util.thread.Scheduler</code>)</p>
</li>
<li>
<p>a byte buffer pool (in form of <code>org.eclipse.jetty.io.ByteBufferPool</code>)</p>
</li>
<li>
<p>a TLS factory (in form of <code>org.eclipse.jetty.util.ssl.SslContextFactory.Client</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ClientConnector</code> is where you want to set those components after you have configured them.
If you don&#8217;t explicitly set those components on the <code>ClientConnector</code>, then appropriate defaults will be chosen when the <code>ClientConnector</code> starts.</p>
</div>
<div class="paragraph">
<p><code>ClientConnector</code> manages all network-related components, and therefore it is used for TCP, UDP, QUIC and <a href="#pg-client-io-arch-unix-domain">Unix-Domain sockets</a>.</p>
</div>
<div class="paragraph">
<p>The simplest example that creates and starts a <code>ClientConnector</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more typical example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create and configure the SslContextFactory.</span>
SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();
sslContextFactory.addExcludeProtocols(<span class="string"><span class="delimiter">&quot;</span><span class="content">TLSv1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">TLSv1.1</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create and configure the thread pool.</span>
QueuedThreadPool threadPool = <span class="keyword">new</span> QueuedThreadPool();
threadPool.setName(<span class="string"><span class="delimiter">&quot;</span><span class="content">client</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create and configure the ClientConnector.</span>
ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.setSslContextFactory(sslContextFactory);
clientConnector.setExecutor(threadPool);
clientConnector.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more advanced example that customizes the <code>ClientConnector</code> by overriding some of its methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">CustomClientConnector</span> <span class="directive">extends</span> ClientConnector
{
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> SelectorManager newSelectorManager()
    {
        <span class="keyword">return</span> <span class="keyword">new</span> ClientSelectorManager(getExecutor(), getScheduler(), getSelectors())
        {
            <span class="annotation">@Override</span>
            <span class="directive">protected</span> <span class="type">void</span> endPointOpened(EndPoint endpoint)
            {
                <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">endpoint</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">opened %s</span><span class="delimiter">&quot;</span></span>, endpoint);
            }

            <span class="annotation">@Override</span>
            <span class="directive">protected</span> <span class="type">void</span> endPointClosed(EndPoint endpoint)
            {
                <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">endpoint</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">closed %s</span><span class="delimiter">&quot;</span></span>, endpoint);
            }
        };
    }
}

<span class="comment">// Create and configure the thread pool.</span>
QueuedThreadPool threadPool = <span class="keyword">new</span> QueuedThreadPool();
threadPool.setName(<span class="string"><span class="delimiter">&quot;</span><span class="content">client</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create and configure the scheduler.</span>
Scheduler scheduler = <span class="keyword">new</span> ScheduledExecutorScheduler(<span class="string"><span class="delimiter">&quot;</span><span class="content">scheduler-client</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">false</span>);

<span class="comment">// Create and configure the custom ClientConnector.</span>
CustomClientConnector clientConnector = <span class="keyword">new</span> CustomClientConnector();
clientConnector.setExecutor(threadPool);
clientConnector.setScheduler(scheduler);
clientConnector.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>ClientConnector</code> is the component that handles the low-level network transport, it is also the component where you want to configure the low-level network configuration.</p>
</div>
<div class="paragraph">
<p>The most common parameters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ClientConnector.selectors</code>: the number of <code>java.nio.Selector</code>s components (defaults to <code>1</code>) that are present to handle the <code>SocketChannel</code>s and <code>DatagramChannel</code>s opened by the <code>ClientConnector</code>.
You typically want to increase the number of selectors only for those use cases where each selector should handle more than few hundreds <em>concurrent</em> socket events.
For example, one selector typically runs well for <code>250</code> <em>concurrent</em> socket events; as a rule of thumb, you can multiply that number by <code>10</code> to obtain the number of opened sockets a selector can handle (<code>2500</code>), based on the assumption that not all the <code>2500</code> sockets will be active <em>at the same time</em>.</p>
</li>
<li>
<p><code>ClientConnector.idleTimeout</code>: the duration of time after which <code>ClientConnector</code> closes a socket due to inactivity (defaults to <code>30</code> seconds).
This is an important parameter to configure, and you typically want the client idle timeout to be shorter than the server idle timeout, to avoid race conditions where the client attempts to use a socket just before the client-side idle timeout expires, but the server-side idle timeout has already expired and the is already closing the socket.</p>
</li>
<li>
<p><code>ClientConnector.connectBlocking</code>: whether the operation of connecting a socket to the server (i.e. <code>SocketChannel.connect(SocketAddress)</code>) must be a blocking or a non-blocking operation (defaults to <code>false</code>).
For <code>localhost</code> or same datacenter hosts you want to set this parameter to
<code>true</code> because DNS resolution will be immediate (and likely never fail).
For generic Internet hosts (e.g. when you are implementing a web spider) you want to set this parameter to <code>false</code>.</p>
</li>
<li>
<p><code>ClientConnector.connectTimeout</code>: the duration of time after which <code>ClientConnector</code> aborts a connection attempt to the server (defaults to <code>5</code> seconds).
This time includes the DNS lookup time <em>and</em> the TCP connect time.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please refer to the <code>ClientConnector</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/ClientConnector.html">javadocs</a> for the complete list of configurable parameters.</p>
</div>
<div class="sect4">
<h5 id="pg-client-io-arch-unix-domain"><a class="anchor" href="#pg-client-io-arch-unix-domain"></a><a class="link" href="#pg-client-io-arch-unix-domain">Unix-Domain Support</a></h5>
<div class="paragraph">
<p><a href="https://openjdk.java.net/jeps/380">JEP 380</a> introduced Unix-Domain sockets support in Java 16, on all operative systems, but only for <code>SocketChannel</code>s (not for <code>DatagramChannel</code>s).</p>
</div>
<div class="paragraph">
<p><code>ClientConnector</code> handles Unix-Domain sockets exactly like it handles regular TCP sockets, so there is no additional configuration necessary&#8201;&#8212;&#8201;Unix-Domain sockets are supported out-of-the-box.</p>
</div>
<div class="paragraph">
<p>Applications can specify the <code>Transport</code> to use for each request as described in <a href="#pg-client-http-api-transport">this section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-io-arch-memory"><a class="anchor" href="#pg-client-io-arch-memory"></a><a class="link" href="#pg-client-io-arch-memory">Memory Support</a></h5>
<div class="paragraph">
<p>In addition to support communication between client and server via network or Unix-Domain, the Jetty client libraries also support communication between client and server via memory for intra-process communication.
This means that the client and server must be in the same JVM process.</p>
</div>
<div class="paragraph">
<p>This functionality is provided by <code>org.eclipse.jetty.server.MemoryTransport</code>, which does not delegate to <code>ClientConnector</code>, but instead delegates to the server-side <code>MemoryConnector</code> and its related classes.</p>
</div>
<div class="paragraph">
<p>Applications can specify the <code>Transport</code> to use for each request as described in <a href="#pg-client-http-api-transport">this section</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-io-arch-protocol"><a class="anchor" href="#pg-client-io-arch-protocol"></a><a class="link" href="#pg-client-io-arch-protocol">Protocol Layer</a></h4>
<div class="paragraph">
<p>The protocol layer builds on top of the transport layer to generate the bytes to be written to the low-level transport and to parse the bytes read from the low-level transport.</p>
</div>
<div class="paragraph">
<p>Recall from <a href="#pg-arch-io-connection">this section</a> that Jetty uses the <code>Connection</code> abstraction to produce and interpret the low-level transport bytes.</p>
</div>
<div class="paragraph">
<p>On the client side, a <code>ClientConnectionFactory</code> implementation is the component that creates <code>Connection</code> instances based on the protocol that the client wants to "speak" with the server.</p>
</div>
<div class="paragraph">
<p>Applications may use <code>ClientConnector.connect(SocketAddress, Map&lt;String, Object&gt;)</code> to establish a TCP connection to the server, and must provide <code>ClientConnector</code> with the following information in the context map:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>Transport</code> instance that specifies the low-level transport to use.</p>
</li>
<li>
<p>A <code>ClientConnectionFactory</code> that creates <code>Connection</code> instances for the high-level protocol.</p>
</li>
<li>
<p>A <code>Promise</code> that is notified when the connection creation succeeds or fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">CustomConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="directive">public</span> CustomConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Opened connection {0}</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">this</span>);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
    }
}

ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.start();

<span class="predefined-type">String</span> host = <span class="string"><span class="delimiter">&quot;</span><span class="content">serverHost</span><span class="delimiter">&quot;</span></span>;
<span class="type">int</span> port = <span class="integer">8080</span>;
<span class="predefined-type">SocketAddress</span> address = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(host, port);

<span class="comment">// The Transport instance.</span>
Transport transport = Transport.TCP_IP;

<span class="comment">// The ClientConnectionFactory that creates CustomConnection instances.</span>
ClientConnectionFactory connectionFactory = (endPoint, context) -&gt;
{
    <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Creating connection for {0}</span><span class="delimiter">&quot;</span></span>, endPoint);
    <span class="keyword">return</span> <span class="keyword">new</span> CustomConnection(endPoint, clientConnector.getExecutor());
};

<span class="comment">// The Promise to notify of connection creation success or failure.</span>
CompletableFuture&lt;CustomConnection&gt; connectionPromise = <span class="keyword">new</span> Promise.Completable&lt;&gt;();

<span class="comment">// Populate the context with the mandatory keys to create and obtain connections.</span>
<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; context = <span class="keyword">new</span> <span class="predefined-type">ConcurrentHashMap</span>&lt;&gt;();
context.put(Transport.class.getName(), transport);
context.put(ClientConnector.CLIENT_CONNECTION_FACTORY_CONTEXT_KEY, connectionFactory);
context.put(ClientConnector.CONNECTION_PROMISE_CONTEXT_KEY, connectionPromise);
clientConnector.connect(address, context);

<span class="comment">// Use the Connection when it's available.</span>

<span class="comment">// Use it in a non-blocking way via CompletableFuture APIs.</span>
connectionPromise.whenComplete((connection, failure) -&gt;
{
    <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Created connection for {0}</span><span class="delimiter">&quot;</span></span>, connection);
});

<span class="comment">// Alternatively, you can block waiting for the connection (or a failure).</span>
<span class="comment">// CustomConnection connection = connectionPromise.get();</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>When a <code>Connection</code> is created successfully, its <code>onOpen()</code> method is invoked, and then the promise is completed successfully.</p>
</div>
<div class="paragraph">
<p>It is now possible to write a super-simple <code>telnet</code> client that reads and writes string lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TelnetConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">ByteArrayOutputStream</span> bytes = <span class="keyword">new</span> <span class="predefined-type">ByteArrayOutputStream</span>();
    <span class="directive">private</span> Consumer&lt;<span class="predefined-type">String</span>&gt; consumer;

    <span class="directive">public</span> TelnetConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest for fill events.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        <span class="keyword">try</span>
        {
            <span class="predefined-type">ByteBuffer</span> buffer = BufferUtil.allocate(<span class="integer">1024</span>);
            <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
            {
                <span class="type">int</span> filled = getEndPoint().fill(buffer);
                <span class="keyword">if</span> (filled &gt; <span class="integer">0</span>)
                {
                    <span class="keyword">while</span> (buffer.hasRemaining())
                    {
                        <span class="comment">// Search for newline.</span>
                        <span class="type">byte</span> read = buffer.get();
                        <span class="keyword">if</span> (read == <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>)
                        {
                            <span class="comment">// Notify the consumer of the line.</span>
                            consumer.accept(bytes.toString(StandardCharsets.UTF_8));
                            bytes.reset();
                        }
                        <span class="keyword">else</span>
                        {
                            bytes.write(read);
                        }
                    }
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (filled == <span class="integer">0</span>)
                {
                    <span class="comment">// No more bytes to fill, declare</span>
                    <span class="comment">// again interest for fill events.</span>
                    fillInterested();
                    <span class="keyword">return</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// The other peer closed the</span>
                    <span class="comment">// connection, close it back.</span>
                    getEndPoint().close();
                    <span class="keyword">return</span>;
                }
            }
        }
        <span class="keyword">catch</span> (<span class="exception">Exception</span> x)
        {
            getEndPoint().close(x);
        }
    }

    <span class="directive">public</span> <span class="type">void</span> onLine(Consumer&lt;<span class="predefined-type">String</span>&gt; consumer)
    {
        <span class="local-variable">this</span>.consumer = consumer;
    }

    <span class="directive">public</span> <span class="type">void</span> writeLine(<span class="predefined-type">String</span> line, <span class="predefined-type">Callback</span> callback)
    {
        line = line + <span class="string"><span class="delimiter">&quot;</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
        getEndPoint().write(callback, <span class="predefined-type">ByteBuffer</span>.wrap(line.getBytes(StandardCharsets.UTF_8)));
    }
}

ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.start();

<span class="predefined-type">String</span> host = <span class="string"><span class="delimiter">&quot;</span><span class="content">example.org</span><span class="delimiter">&quot;</span></span>;
<span class="type">int</span> port = <span class="integer">80</span>;
<span class="predefined-type">SocketAddress</span> address = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(host, port);

ClientConnectionFactory connectionFactory = (endPoint, context) -&gt;
    <span class="keyword">new</span> TelnetConnection(endPoint, clientConnector.getExecutor());

CompletableFuture&lt;TelnetConnection&gt; connectionPromise = <span class="keyword">new</span> Promise.Completable&lt;&gt;();

<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; context = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
context.put(Transport.class.getName(), Transport.TCP_IP);
context.put(ClientConnector.CLIENT_CONNECTION_FACTORY_CONTEXT_KEY, connectionFactory);
context.put(ClientConnector.CONNECTION_PROMISE_CONTEXT_KEY, connectionPromise);
clientConnector.connect(address, context);

connectionPromise.whenComplete((connection, failure) -&gt;
{
    <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
    {
        <span class="comment">// Register a listener that receives string lines.</span>
        connection.onLine(line -&gt; <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">line: {0}</span><span class="delimiter">&quot;</span></span>, line));

        <span class="comment">// Write a line.</span>
        connection.writeLine(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET / HTTP/1.0</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.NOOP);
    }
    <span class="keyword">else</span>
    {
        failure.printStackTrace();
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how a very basic "telnet" API that applications could use is implemented in the form of the <code>onLine(Consumer&lt;String&gt;)</code> for the non-blocking receiving side and <code>writeLine(String, Callback)</code> for the non-blocking sending side.
Note also how the <code>onFillable()</code> method implements some basic "parsing" by looking up the <code>\n</code> character in the buffer.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The "telnet" client above looks like a super-simple HTTP client because HTTP/1.0 can be seen as a line-based protocol.
HTTP/1.0 was used just as an example, but we could have used any other line-based protocol such as <a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">SMTP</a>, provided that the server was able to understand it.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is very similar to what the Jetty client implementation does for real network protocols.
Real network protocols are of course more complicated and so is the implementation code that handles them, but the general ideas are similar.</p>
</div>
<div class="paragraph">
<p>The Jetty client implementation provides a number of <code>ClientConnectionFactory</code> implementations that can be composed to produce and interpret the network bytes.</p>
</div>
<div class="paragraph">
<p>For example, it is simple to modify the above example to use the TLS protocol so that you will be able to connect to the server on port <code>443</code>, typically reserved for the secure HTTP protocol.</p>
</div>
<div class="paragraph">
<p>The differences between the clear-text version and the TLS encrypted version are minimal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">TelnetConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">ByteArrayOutputStream</span> bytes = <span class="keyword">new</span> <span class="predefined-type">ByteArrayOutputStream</span>();
    <span class="directive">private</span> Consumer&lt;<span class="predefined-type">String</span>&gt; consumer;

    <span class="directive">public</span> TelnetConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest for fill events.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        <span class="keyword">try</span>
        {
            <span class="predefined-type">ByteBuffer</span> buffer = BufferUtil.allocate(<span class="integer">1024</span>);
            <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
            {
                <span class="type">int</span> filled = getEndPoint().fill(buffer);
                <span class="keyword">if</span> (filled &gt; <span class="integer">0</span>)
                {
                    <span class="keyword">while</span> (buffer.hasRemaining())
                    {
                        <span class="comment">// Search for newline.</span>
                        <span class="type">byte</span> read = buffer.get();
                        <span class="keyword">if</span> (read == <span class="string"><span class="delimiter">'</span><span class="content">\n</span><span class="delimiter">'</span></span>)
                        {
                            <span class="comment">// Notify the consumer of the line.</span>
                            consumer.accept(bytes.toString(StandardCharsets.UTF_8));
                            bytes.reset();
                        }
                        <span class="keyword">else</span>
                        {
                            bytes.write(read);
                        }
                    }
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (filled == <span class="integer">0</span>)
                {
                    <span class="comment">// No more bytes to fill, declare</span>
                    <span class="comment">// again interest for fill events.</span>
                    fillInterested();
                    <span class="keyword">return</span>;
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// The other peer closed the</span>
                    <span class="comment">// connection, close it back.</span>
                    getEndPoint().close();
                    <span class="keyword">return</span>;
                }
            }
        }
        <span class="keyword">catch</span> (<span class="exception">Exception</span> x)
        {
            getEndPoint().close(x);
        }
    }

    <span class="directive">public</span> <span class="type">void</span> onLine(Consumer&lt;<span class="predefined-type">String</span>&gt; consumer)
    {
        <span class="local-variable">this</span>.consumer = consumer;
    }

    <span class="directive">public</span> <span class="type">void</span> writeLine(<span class="predefined-type">String</span> line, <span class="predefined-type">Callback</span> callback)
    {
        line = line + <span class="string"><span class="delimiter">&quot;</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;
        getEndPoint().write(callback, <span class="predefined-type">ByteBuffer</span>.wrap(line.getBytes(StandardCharsets.UTF_8)));
    }
}

ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.start();

<span class="comment">// Use port 443 to contact the server using encrypted HTTP.</span>
<span class="predefined-type">String</span> host = <span class="string"><span class="delimiter">&quot;</span><span class="content">example.org</span><span class="delimiter">&quot;</span></span>;
<span class="type">int</span> port = <span class="integer">443</span>;
<span class="predefined-type">SocketAddress</span> address = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(host, port);

ClientConnectionFactory connectionFactory = (endPoint, context) -&gt;
    <span class="keyword">new</span> TelnetConnection(endPoint, clientConnector.getExecutor());

<span class="comment">// Wrap the &quot;telnet&quot; ClientConnectionFactory with the SslClientConnectionFactory.</span>
connectionFactory = <span class="keyword">new</span> SslClientConnectionFactory(clientConnector.getSslContextFactory(),
    clientConnector.getByteBufferPool(), clientConnector.getExecutor(), connectionFactory);

<span class="comment">// We will obtain a SslConnection now.</span>
CompletableFuture&lt;SslConnection&gt; connectionPromise = <span class="keyword">new</span> Promise.Completable&lt;&gt;();

<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; context = <span class="keyword">new</span> <span class="predefined-type">ConcurrentHashMap</span>&lt;&gt;();
context.put(Transport.class.getName(), Transport.TCP_IP);
context.put(ClientConnector.CLIENT_CONNECTION_FACTORY_CONTEXT_KEY, connectionFactory);
context.put(ClientConnector.CONNECTION_PROMISE_CONTEXT_KEY, connectionPromise);
clientConnector.connect(address, context);

connectionPromise.whenComplete((sslConnection, failure) -&gt;
{
    <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
    {
        <span class="comment">// Unwrap the SslConnection to access the &quot;line&quot; APIs in TelnetConnection.</span>
        TelnetConnection connection = (TelnetConnection)sslConnection.getSslEndPoint().getConnection();
        <span class="comment">// Register a listener that receives string lines.</span>
        connection.onLine(line -&gt; <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">app</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">line: {0}</span><span class="delimiter">&quot;</span></span>, line));

        <span class="comment">// Write a line.</span>
        connection.writeLine(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET / HTTP/1.0</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.NOOP);
    }
    <span class="keyword">else</span>
    {
        failure.printStackTrace();
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The differences with the clear-text version are only:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Change the port from <code>80</code> to <code>443</code>.</p>
</li>
<li>
<p>Wrap the <code>ClientConnectionFactory</code> with <code>SslClientConnectionFactory</code>.</p>
</li>
<li>
<p>Unwrap the <code>SslConnection</code> to access <code>TelnetConnection</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-client-http"><a class="anchor" href="#pg-client-http"></a><a class="link" href="#pg-client-http">HTTP Client</a></h3>
<div class="sect3">
<h4 id="pg-client-http-intro"><a class="anchor" href="#pg-client-http-intro"></a><a class="link" href="#pg-client-http-intro">HttpClient Introduction</a></h4>
<div class="paragraph">
<p>The Jetty HTTP client module provides easy-to-use APIs and utility classes to perform HTTP (or HTTPS) requests.</p>
</div>
<div class="paragraph">
<p>Jetty&#8217;s HTTP client is non-blocking and asynchronous.
It offers an asynchronous API that never blocks for I/O, making it very efficient in thread utilization and well suited for high performance scenarios such as load testing or parallel computation.</p>
</div>
<div class="paragraph">
<p>However, when all you need to do is to perform a <code>GET</code> request to a resource, Jetty&#8217;s HTTP client offers also a synchronous API; a programming interface where the thread that issued the request blocks until the request/response conversation is complete.</p>
</div>
<div class="paragraph">
<p>Jetty&#8217;s HTTP client supports different <a href="#pg-client-http-transport">HTTP formats</a>: HTTP/1.1, HTTP/2, HTTP/3 and FastCGI.
Each format has a different <code>HttpClientTransport</code> implementation, that in turn use a <a href="#pg-client-io-arch-transport">low-level transport</a> to communicate with the server.</p>
</div>
<div class="paragraph">
<p>This means that the semantic of an HTTP request such as: " <code>GET</code> the resource <code>/index.html</code> " can be carried over the low-level transport in different formats.
The most common and default format is HTTP/1.1.
That said, Jetty&#8217;s HTTP client can carry the same request using the HTTP/2 format, the HTTP/3 format, or the FastCGI format.</p>
</div>
<div class="paragraph">
<p>Furthermore, every format can be transported over different low-level transport, such as TCP, Unix-Domain sockets, QUIC or memory.
Supports for Unix-Domain sockets requires Java 16 or later, since Unix-Domain sockets support has been introduced in OpenJDK with <a href="https://openjdk.java.net/jeps/380">JEP 380</a>.</p>
</div>
<div class="paragraph">
<p>The <a href="#pg-client-http-transport-fcgi">FastCGI format</a> is used in Jetty&#8217;s <a href="#pg-server-fastcgi">FastCGI support</a> that allows Jetty to work as a reverse proxy to PHP (exactly like Apache or Nginx do) and therefore be able to serve, for example, WordPress websites, often in conjunction with Unix-Domain sockets (although it is possible to use FastCGI via network too).</p>
</div>
<div class="paragraph">
<p>The HTTP/2 format allows Jetty&#8217;s HTTP client to perform requests using HTTP/2 to HTTP/2 enabled websites, see also Jetty&#8217;s <a href="#pg-client-http2">HTTP/2 support</a>.</p>
</div>
<div class="paragraph">
<p>The HTTP/3 format allows Jetty&#8217;s HTTP client to perform requests using HTTP/3 to HTTP/3 enabled websites, see also Jetty&#8217;s <a href="#pg-client-http3">HTTP/3 support</a>.</p>
</div>
<div class="paragraph">
<p>Out of the box features that you get with the Jetty HTTP client include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redirect support&#8201;&#8212;&#8201;redirect codes such as 302 or 303 are automatically followed.</p>
</li>
<li>
<p>Cookies support&#8201;&#8212;&#8201;cookies sent by servers are stored and sent back to servers in matching requests.</p>
</li>
<li>
<p>Authentication support&#8201;&#8212;&#8201;HTTP "Basic", "Digest" and "SPNEGO" authentications are supported, others are pluggable.</p>
</li>
<li>
<p>Forward proxy support&#8201;&#8212;&#8201;HTTP proxying, SOCKS4 and SOCKS5 proxying.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-start"><a class="anchor" href="#pg-client-http-start"></a><a class="link" href="#pg-client-http-start">Starting HttpClient</a></h4>
<div class="paragraph">
<p>The Jetty artifact that provides the main HTTP client implementation is <code>jetty-client</code>.
The Maven artifact coordinates are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-client<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main class is named <code>org.eclipse.jetty.client.HttpClient</code>.</p>
</div>
<div class="paragraph">
<p>You can think of a <code>HttpClient</code> instance as a browser instance.
Like a browser it can make requests to different domains, it manages redirects, cookies and authentication, you can configure it with a forward proxy, and it provides you with the responses to the requests you make.</p>
</div>
<div class="paragraph">
<p>In order to use <code>HttpClient</code>, you must instantiate it, configure it, and then start it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Instantiate HttpClient.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient();

<span class="comment">// Configure HttpClient, for example:</span>
httpClient.setFollowRedirects(<span class="predefined-constant">false</span>);

<span class="comment">// Start HttpClient.</span>
httpClient.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may create multiple instances of <code>HttpClient</code>, but typically one instance is enough for an application.
There are several reasons for having multiple <code>HttpClient</code> instances including, but not limited to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You want to specify different configuration parameters (for example, one instance is configured with a forward proxy while another is not).</p>
</li>
<li>
<p>You want the two instances to behave like two different browsers and hence have different cookies, different authentication credentials, etc.</p>
</li>
<li>
<p>You want to use <a href="#pg-client-http-transport">different <code>HttpClientTransport</code>s</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Like browsers, HTTPS requests are supported out-of-the-box (see <a href="#pg-client-http-configuration-tls">this section</a> for the TLS configuration), as long as the server provides a valid certificate.
In case the server does not provide a valid certificate (or in case it is self-signed) you want to customize <code>HttpClient</code>'s TLS configuration as described in <a href="#pg-client-http-configuration-tls">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-stop"><a class="anchor" href="#pg-client-http-stop"></a><a class="link" href="#pg-client-http-stop">Stopping HttpClient</a></h4>
<div class="paragraph">
<p>It is recommended that when your application stops, you also stop the <code>HttpClient</code> instance (or instances) that you are using.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Stop HttpClient.</span>
httpClient.stop();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stopping <code>HttpClient</code> makes sure that the memory it holds (for example, <code>ByteBuffer</code> pools, authentication credentials, cookies, etc.) is released, and that the thread pool and scheduler are properly stopped allowing all threads used by <code>HttpClient</code> to exit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot call <code>HttpClient.stop()</code> from one of its own threads, as it would cause a deadlock.
It is recommended that you stop <code>HttpClient</code> from an unrelated thread, or from a newly allocated thread, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Stop HttpClient from a new thread.</span>
<span class="comment">// Use LifeCycle.stop(...) to rethrow checked exceptions as unchecked.</span>
<span class="keyword">new</span> <span class="predefined-type">Thread</span>(() -&gt; LifeCycle.stop(httpClient)).start();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-arch"><a class="anchor" href="#pg-client-http-arch"></a><a class="link" href="#pg-client-http-arch">HttpClient Architecture</a></h4>
<div class="paragraph">
<p>A <code>HttpClient</code> instance can be thought as a browser instance, and it manages the following components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>CookieStore</code> (see <a href="#pg-client-http-cookie">this section</a>).</p>
</li>
<li>
<p>A <code>AuthenticationStore</code> (see <a href="#pg-client-http-authentication">this section</a>).</p>
</li>
<li>
<p>A <code>ProxyConfiguration</code> (see <a href="#pg-client-http-proxy">this section</a>).</p>
</li>
<li>
<p>A set of <code>Destination</code>s</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>Destination</code> is the client-side component that represents an <em>origin</em> server, and manages a queue of requests for that origin, and a <a href="#pg-client-http-connection-pool">pool of connections</a> to that origin.</p>
</div>
<div class="paragraph">
<p>An <em>origin</em> may be simply thought as the tuple <code>(scheme, host, port)</code> and it is where the client connects to in order to communicate with the server.
However, this is not enough.</p>
</div>
<div class="paragraph">
<p>If you use <code>HttpClient</code> to write a proxy you may have different clients that want to contact the same server.
In this case, you may not want to use the same proxy-to-server connection to proxy requests for both clients, for example for authentication reasons: the server may associate the connection with authentication credentials, and you do not want to use the same connection for two different users that have different credentials.
Instead, you want to use different connections for different clients and this can be achieved by "tagging" a destination with a tag object that represents the remote client (for example, it could be the remote client IP address).</p>
</div>
<div class="paragraph">
<p>Two origins with the same <code>(scheme, host, port)</code> but different <code>tag</code> create two different destinations and therefore two different connection pools.
However, also this is not enough.</p>
</div>
<div class="paragraph">
<p>It is possible for a server to speak different protocols on the same <code>port</code>.
A connection may start by speaking one protocol, for example HTTP/1.1, but then be upgraded to speak a different protocol, for example HTTP/2. After a connection has been upgraded to a second protocol, it cannot speak the first protocol anymore, so it can only be used to communicate using the second protocol.</p>
</div>
<div class="paragraph">
<p>Two origins with the same <code>(scheme, host, port, tag)</code> but different <code>protocol</code> create two different destinations and therefore two different connection pools.</p>
</div>
<div class="paragraph">
<p>Finally, it is possible for a server to speak the same protocol over different <a href="#pg-client-io-arch-transport">low-level transports</a> (represented by <code>Transport</code>), for example TCP and Unix-Domain.</p>
</div>
<div class="paragraph">
<p>Two origins with the same <code>(scheme, host, port, tag, protocol)</code> but different low-level transports create two different destinations and therefore two different connection pools.</p>
</div>
<div class="paragraph">
<p>Therefore, an origin is identified by the tuple <code>(scheme, host, port, tag, protocol, transport)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-connection-pool"><a class="anchor" href="#pg-client-http-connection-pool"></a><a class="link" href="#pg-client-http-connection-pool">HttpClient Connection Pooling</a></h4>
<div class="paragraph">
<p>A <code>Destination</code> manages a <code>org.eclipse.jetty.client.ConnectionPool</code>, where connections to a particular origin are pooled for performance reasons: opening a connection is a costly operation, and it&#8217;s better to reuse them for multiple requests.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that to select a specific <code>Destination</code> you must select a specific origin, and that an origin is identified by the tuple <code>(scheme, host, port, tag, protocol, transport)</code>, so you can have multiple <code>Destination</code>s for the same <code>host</code> and <code>port</code>, and therefore multiple <code>ConnectionPool</code>s
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can access the <code>ConnectionPool</code> in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();

ConnectionPool connectionPool = httpClient.getDestinations().stream()
    <span class="comment">// Find the destination by filtering on the Origin.</span>
    .filter(destination -&gt; destination.getOrigin().getAddress().getHost().equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">domain.com</span><span class="delimiter">&quot;</span></span>))
    .findAny()
    <span class="comment">// Get the ConnectionPool.</span>
    .map(<span class="predefined-type">Destination</span>::getConnectionPool)
    .orElse(<span class="predefined-constant">null</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetty&#8217;s client library provides the following <code>ConnectionPool</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DuplexConnectionPool</code>, historically the first implementation, only used by the HTTP/1.1 transport.</p>
</li>
<li>
<p><code>MultiplexConnectionPool</code>, the generic implementation valid for any transport where connections are reused with a most recently used algorithm (that is, the connections most recently returned to the connection pool are the more likely to be used again).</p>
</li>
<li>
<p><code>RoundRobinConnectionPool</code>, similar to <code>MultiplexConnectionPool</code> but where connections are reused with a round-robin algorithm.</p>
</li>
<li>
<p><code>RandomRobinConnectionPool</code>, similar to <code>MultiplexConnectionPool</code> but where connections are reused with an algorithm that chooses them randomly.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ConnectionPool</code> implementation can be customized for each destination in by setting a <code>ConnectionPool.Factory</code> on the <code>HttpClientTransport</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();

<span class="comment">// The max number of connections in the pool.</span>
<span class="type">int</span> maxConnectionsPerDestination = httpClient.getMaxConnectionsPerDestination();

<span class="comment">// The max number of requests per connection (multiplexing).</span>
<span class="comment">// Start with 1, since this value is dynamically set to larger values if</span>
<span class="comment">// the transport supports multiplexing requests on the same connection.</span>
<span class="type">int</span> maxRequestsPerConnection = <span class="integer">1</span>;

HttpClientTransport transport = httpClient.getTransport();

<span class="comment">// Set the ConnectionPool.Factory using a lambda.</span>
transport.setConnectionPoolFactory(destination -&gt;
    <span class="keyword">new</span> RoundRobinConnectionPool(destination,
        maxConnectionsPerDestination,
        maxRequestsPerConnection));</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-request-processing"><a class="anchor" href="#pg-client-http-request-processing"></a><a class="link" href="#pg-client-http-request-processing">HttpClient Request Processing</a></h4>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-4760564aad148998e116357e8f3a5450.png" alt="Diagram" width="684" height="514">
</div>
</div>
<div class="paragraph">
<p>When a request is sent, an origin is computed from the request; <code>HttpClient</code> uses that origin to find (or create if it does not exist) the correspondent destination.
The request is then queued onto the destination, and this causes the destination to ask its connection pool for a free connection.
If a connection is available, it is returned, otherwise a new connection is created.
Once the destination has obtained the connection, it dequeues the request and sends it over the connection.</p>
</div>
<div class="paragraph">
<p>The first request to a destination triggers the opening of the first connection.
A second request with the same origin sent <em>after</em> the first request/response cycle is completed may reuse the same connection, depending on the connection pool implementation.
A second request with the same origin sent <em>concurrently</em> with the first request will likely cause the opening of a second connection, depending on the connection pool implementation.
The configuration parameter <code>HttpClient.maxConnectionsPerDestination</code> (see also the <a href="#pg-client-http-configuration">configuration section</a>) controls the max number of connections that can be opened for a destination.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If opening connections to a given origin takes a long time, then requests for that origin will queue up in the corresponding destination until the connections are established.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each connection can handle a limited number of concurrent requests.
For HTTP/1.1, this number is always <code>1</code>: there can only be one outstanding request for each connection.
For HTTP/2 this number is determined by the server <code>max_concurrent_stream</code> setting (typically around <code>100</code>, i.e. there can be up to <code>100</code> outstanding requests for every connection).</p>
</div>
<div class="paragraph">
<p>When a destination has maxed out its number of connections, and all connections have maxed out their number of outstanding requests, more requests sent to that destination will be queued.
When the request queue is full, the request will be failed.
The configuration parameter <code>HttpClient.maxRequestsQueuedPerDestination</code> (see also the <a href="#pg-client-http-configuration">configuration section</a>) controls the max number of requests that can be queued for a destination.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-api"><a class="anchor" href="#pg-client-http-api"></a><a class="link" href="#pg-client-http-api">HttpClient API Usage</a></h4>
<div class="paragraph">
<p><code>HttpClient</code> provides two types of APIs: a blocking API and a non-blocking API.</p>
</div>
<div class="sect4">
<h5 id="pg-client-http-blocking"><a class="anchor" href="#pg-client-http-blocking"></a><a class="link" href="#pg-client-http-blocking">HttpClient Blocking APIs</a></h5>
<div class="paragraph">
<p>The simpler way to perform a HTTP request is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();

<span class="comment">// Perform a simple GET and wait for the response.</span>
ContentResponse response = httpClient.GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path?query</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>HttpClient.GET(...)</code> performs a HTTP <code>GET</code> request to the given URI and returns a <code>ContentResponse</code> when the request/response conversation completes successfully.</p>
</div>
<div class="paragraph">
<p>The <code>ContentResponse</code> object contains the HTTP response information: status code, headers and possibly content.
The content length is limited by default to 2 MiB; for larger content see <a href="#pg-client-http-content-response">the section on response content handling</a>.</p>
</div>
<div class="paragraph">
<p>If you want to customize the request, for example by issuing a <code>HEAD</code> request instead of a <code>GET</code>, and simulating a browser user agent, you can do it in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path?query</span><span class="delimiter">&quot;</span></span>)
    .method(HttpMethod.HEAD)
    .agent(<span class="string"><span class="delimiter">&quot;</span><span class="content">Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0</span><span class="delimiter">&quot;</span></span>)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a shorthand for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Request request = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path?query</span><span class="delimiter">&quot;</span></span>);
request.method(HttpMethod.HEAD);
request.agent(<span class="string"><span class="delimiter">&quot;</span><span class="content">Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:17.0) Gecko/20100101 Firefox/17.0</span><span class="delimiter">&quot;</span></span>);
ContentResponse response = request.send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You first create a request object using <code>httpClient.newRequest(...)</code>, and then you customize it using the fluent API style (that is, a chained invocation of methods on the request object).
When the request object is customized, you call <code>request.send()</code> that produces the <code>ContentResponse</code> when the request/response conversation is complete.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>Request</code> object, despite being mutable, cannot be reused for other requests.
This is true also when trying to send two or more identical requests: you have to create two or more <code>Request</code> objects.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simple <code>POST</code> requests also have a shortcut method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/entity/1</span><span class="delimiter">&quot;</span></span>)
    .param(<span class="string"><span class="delimiter">&quot;</span><span class="content">p</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>POST</code> parameter values added via the <code>param()</code> method are automatically URL-encoded.</p>
</div>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> automatically follows redirects, so it handles the typical web pattern <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get">POST/Redirect/GET</a>, and the response object contains the content of the response of the <code>GET</code> request.
Following redirects is a feature that you can enable/disable on a per-request basis or globally.</p>
</div>
<div class="paragraph">
<p>File uploads also require one line, and make use of <code>java.nio.file</code> classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .file(Paths.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">file_to_upload.txt</span><span class="delimiter">&quot;</span></span>), <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to impose a total timeout for the request/response conversation using the <code>Request.timeout(...)</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path?query</span><span class="delimiter">&quot;</span></span>)
    .timeout(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, when the 5 seconds expire, the request/response cycle is aborted and a <code>java.util.concurrent.TimeoutException</code> is thrown.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-non-blocking"><a class="anchor" href="#pg-client-http-non-blocking"></a><a class="link" href="#pg-client-http-non-blocking">HttpClient Non-Blocking APIs</a></h5>
<div class="paragraph">
<p>So far we have shown how to use Jetty HTTP client in a blocking style&#8201;&#8212;&#8201;that is, the thread that issues the request blocks until the request/response conversation is complete.</p>
</div>
<div class="paragraph">
<p>This section will look at Jetty&#8217;s <code>HttpClient</code> non-blocking, asynchronous APIs that are perfectly suited for large content downloads, for parallel processing of requests/responses and in cases where performance and efficient thread and resource utilization is a key factor.</p>
</div>
<div class="paragraph">
<p>The asynchronous APIs rely heavily on listeners that are invoked at various stages of request and response processing.
These listeners are implemented by applications and may perform any kind of logic.
The implementation invokes these listeners in the same thread that is used to process the request or response.
Therefore, if the application code in these listeners takes a long time to execute, the request or response processing is delayed until the listener returns.</p>
</div>
<div class="paragraph">
<p>If you need to execute application code that takes long time inside a listener, it is typically better to spawn your own thread to execute the code that takes long time.
In this way you return from the listener as soon as possible and allow the implementation to resume the processing of the request or response (or of other requests/responses).</p>
</div>
<div class="paragraph">
<p>Request and response processing are executed by two different threads and therefore may happen concurrently.
A typical example of this concurrent processing is an echo server, where a large upload may be concurrent with the large download echoed back.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that responses may be processed and completed <em>before</em> requests; a typical example is a large upload that triggers a quick response, for example an error, by the server: the response may arrive and be completed while the request content is still being uploaded.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The application thread that calls <code>Request.send(Response.CompleteListener)</code> performs the <a href="#pg-client-http-request-processing">processing of the request</a> until either the request is fully sent over the network or until it would block on I/O, then it returns (and therefore never blocks).
If it would block on I/O, the thread asks the I/O system to emit an event when the I/O will be ready to continue, then returns.
When such an event is fired, a thread taken from the <code>HttpClient</code> thread pool will resume the processing of the request.</p>
</div>
<div class="paragraph">
<p>Response are processed from the I/O thread taken from the <code>HttpClient</code> thread pool that processes the event that bytes are ready to be read.
Response processing continues until either the response is fully processed or until it would block for I/O.
If it would block for I/O, the thread asks the I/O system to emit an event when the I/O will be ready to continue, then returns.
When such an event is fired, a (possibly different) thread taken from the <code>HttpClient</code> thread pool will resume the processing of the response.</p>
</div>
<div class="paragraph">
<p>When the request and the response are both fully processed, the thread that finished the last processing (usually the thread that processes the response, but may also be the thread that processes the request&#8201;&#8212;&#8201;if the request takes more time than the response to be processed) is used to dequeue the next request for the same destination and to process it.</p>
</div>
<div class="paragraph">
<p>A simple non-blocking <code>GET</code> request that discards the response content can be written in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    .send(result -&gt;
    {
        <span class="comment">// Your logic here</span>
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>Method <code>Request.send(Response.CompleteListener)</code> returns <code>void</code> and does not block; the <code>Response.CompleteListener</code> lambda provided as a parameter is notified when the request/response conversation is complete, and the <code>Result</code> parameter allows you to access the request and response objects as well as failures, if any.</p>
</div>
<div class="paragraph">
<p>You can impose a total timeout for the request/response conversation in the same way used by the synchronous API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    .timeout(<span class="integer">3</span>, <span class="predefined-type">TimeUnit</span>.SECONDS)
    .send(result -&gt;
    {
        <span class="comment">/* Your logic here */</span>
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above will impose a total timeout of 3 seconds on the request/response conversation.</p>
</div>
<div class="paragraph">
<p>The HTTP client APIs use listeners extensively to provide hooks for all possible request and response events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Add request hooks.</span>
    .onRequestQueued(request -&gt; { <span class="comment">/* ... */</span> })
    .onRequestBegin(request -&gt; { <span class="comment">/* ... */</span> })
    .onRequestHeaders(request -&gt; { <span class="comment">/* ... */</span> })
    .onRequestCommit(request -&gt; { <span class="comment">/* ... */</span> })
    .onRequestContent((request, content) -&gt; { <span class="comment">/* ... */</span> })
    .onRequestFailure((request, failure) -&gt; { <span class="comment">/* ... */</span> })
    .onRequestSuccess(request -&gt; { <span class="comment">/* ... */</span> })
    <span class="comment">// Add response hooks.</span>
    .onResponseBegin(response -&gt; { <span class="comment">/* ... */</span> })
    .onResponseHeader((response, field) -&gt; <span class="predefined-constant">true</span>)
    .onResponseHeaders(response -&gt; { <span class="comment">/* ... */</span> })
    .onResponseContentAsync((response, chunk, demander) -&gt; demander.run())
    .onResponseFailure((response, failure) -&gt; { <span class="comment">/* ... */</span> })
    .onResponseSuccess(response -&gt; { <span class="comment">/* ... */</span> })
    <span class="comment">// Result hook.</span>
    .send(result -&gt; { <span class="comment">/* ... */</span> });</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes Jetty HTTP client suitable for HTTP load testing because, for example, you can accurately time every step of the request/response conversation (thus knowing where the request/response time is really spent).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The code in request and response listeners <em>should not</em> block.</p>
</div>
<div class="paragraph">
<p>It is allowed to call other blocking APIs, such as the Java file-system APIs.
You should not call blocking APIs that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wait for other request or response events, such as receiving other request or response content chunks.</p>
</li>
<li>
<p>Use wait/notify primitives such as those available in <code>java.lang.Object</code> or <code>java.util.concurrent.locks.Condition</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the listener code blocks, the implementation also will be blocked and will not be able to advance the processing of the request or response that the listener code is likely waiting for, causing a deadlock.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Have a look at the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/client/api/Request.Listener.html"><code>Request.Listener</code></a> class to know about request events, and to the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/client/api/Response.Listener.html"><code>Response.Listener</code></a> class to know about response events.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-content-request"><a class="anchor" href="#pg-client-http-content-request"></a><a class="link" href="#pg-client-http-content-request">Request Content Handling</a></h5>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> provides a number of utility classes off the shelf to handle request content.</p>
</div>
<div class="paragraph">
<p>You can provide request content as <code>String</code>, <code>byte[]</code>, <code>ByteBuffer</code>, <code>java.nio.file.Path</code>, <code>InputStream</code>, and provide your own implementation of <code>org.eclipse.jetty.client.Request.Content</code>.
Here’s an example that provides the request content using <code>java.nio.file.Paths</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .body(<span class="keyword">new</span> PathRequestContent(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>, Paths.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">file_to_upload.txt</span><span class="delimiter">&quot;</span></span>)))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use <code>FileInputStream</code> via the <code>InputStreamRequestContent</code> utility class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .body(<span class="keyword">new</span> InputStreamRequestContent(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">FileInputStream</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">file_to_upload.txt</span><span class="delimiter">&quot;</span></span>)))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>InputStream</code> is blocking, then also the send of the request will block if the input stream blocks, even in case of usage of the non-blocking <code>HttpClient</code> APIs.</p>
</div>
<div class="paragraph">
<p>If you have already read the content in memory, you can pass it as a <code>byte[]</code> (or a <code>String</code>) using the <code>BytesRequestContent</code> (or <code>StringRequestContent</code>) utility class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse bytesResponse = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .body(<span class="keyword">new</span> BytesRequestContent(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>, bytes))
    .send();

ContentResponse stringResponse = httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .body(<span class="keyword">new</span> StringRequestContent(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>, string))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the request content is not immediately available, but your application will be notified of the content to send, you can use <code>AsyncRequestContent</code> in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AsyncRequestContent content = <span class="keyword">new</span> AsyncRequestContent();
httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/upload</span><span class="delimiter">&quot;</span></span>)
    .body(content)
    .send(result -&gt;
    {
        <span class="comment">// Your logic here</span>
    });

<span class="comment">// Content not available yet here.</span>

<span class="comment">// An event happens in some other class, in some other thread.</span>
<span class="type">class</span> <span class="class">ContentPublisher</span>
{
    <span class="type">void</span> publish(<span class="type">byte</span><span class="type">[]</span> bytes, <span class="type">boolean</span> lastContent)
    {
        <span class="comment">// Wrap the bytes into a new ByteBuffer.</span>
        <span class="predefined-type">ByteBuffer</span> buffer = <span class="predefined-type">ByteBuffer</span>.wrap(bytes);

        <span class="comment">// Write the content.</span>
        content.write(buffer, <span class="predefined-type">Callback</span>.NOOP);

        <span class="comment">// Close AsyncRequestContent when all the content is arrived.</span>
        <span class="keyword">if</span> (lastContent)
            content.close();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the request content is awaited and consequently uploaded by the client application, the server may be able to respond (at least with the response headers) completely asynchronously.
In this case, <code>Response.Listener</code> callbacks will be invoked before the request is fully sent.
This allows fine-grained control of the request/response conversation: for example the server may reject contents that are too big, send a response to the client, which in turn may stop the content upload.</p>
</div>
<div class="paragraph">
<p>Another way to provide request content is by using an <code>OutputStreamRequestContent</code>, which allows applications to write request content when it is available to the <code>OutputStream</code> provided by <code>OutputStreamRequestContent</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">OutputStreamRequestContent content = <span class="keyword">new</span> OutputStreamRequestContent();

<span class="comment">// Use try-with-resources to close the OutputStream when all content is written.</span>
<span class="keyword">try</span> (<span class="predefined-type">OutputStream</span> output = content.getOutputStream())
{
    httpClient.POST(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/</span><span class="delimiter">&quot;</span></span>)
        .body(content)
        .send(result -&gt;
        {
            <span class="comment">// Your logic here</span>
        });

    <span class="comment">// Content not available yet here.</span>

    <span class="comment">// Content is now available.</span>
    <span class="type">byte</span><span class="type">[]</span> bytes = <span class="keyword">new</span> <span class="type">byte</span><span class="type">[]</span>{<span class="string"><span class="delimiter">'</span><span class="content">h</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">e</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">l</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">l</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">o</span><span class="delimiter">'</span></span>};
    output.write(bytes);
}
<span class="comment">// End of try-with-resource, output.close() called automatically to signal end of content.</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-content-response"><a class="anchor" href="#pg-client-http-content-response"></a><a class="link" href="#pg-client-http-content-response">Response Content Handling</a></h5>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> allows applications to handle response content in different ways.</p>
</div>
<div class="paragraph">
<p>You can buffer the response content in memory; this is done when using the <a href="#pg-client-http-blocking">blocking APIs</a> and the content is buffered within a <code>ContentResponse</code> up to 2 MiB.</p>
</div>
<div class="paragraph">
<p>If you want to control the length of the response content (for example limiting to values smaller than the default of 2 MiB), then you can use a <code>org.eclipse.jetty.client.CompletableResponseListener</code> in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Request request = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Limit response content buffer to 512 KiB.</span>
CompletableFuture&lt;ContentResponse&gt; completable = <span class="keyword">new</span> CompletableResponseListener(request, <span class="integer">512</span> * <span class="integer">1024</span>)
    .send();

<span class="comment">// You can attach actions to the CompletableFuture,</span>
<span class="comment">// to be performed when the request+response completes.</span>

<span class="comment">// Wait at most 5 seconds for request+response to complete.</span>
ContentResponse response = completable.get(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the response content length is exceeded, the response will be aborted, and an exception will be thrown by method <code>get(...)</code>.</p>
</div>
<div class="paragraph">
<p>You can buffer the response content in memory also using the <a href="#pg-client-http-non-blocking">non-blocking APIs</a>, via the <code>BufferingResponseListener</code> utility class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Buffer response content up to 8 MiB</span>
    .send(<span class="keyword">new</span> BufferingResponseListener(<span class="integer">8</span> * <span class="integer">1024</span> * <span class="integer">1024</span>)
    {
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> onComplete(<span class="predefined-type">Result</span> result)
        {
            <span class="keyword">if</span> (!result.isFailed())
            {
                <span class="type">byte</span><span class="type">[]</span> responseContent = getContent();
                <span class="comment">// Your logic here</span>
            }
        }
    });</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to avoid buffering, you can wait for the response and then stream the content using the <code>InputStreamResponseListener</code> utility class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">InputStreamResponseListener listener = <span class="keyword">new</span> InputStreamResponseListener();
httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    .send(listener);

<span class="comment">// Wait for the response headers to arrive.</span>
Response response = listener.get(<span class="integer">5</span>, <span class="predefined-type">TimeUnit</span>.SECONDS);

<span class="comment">// Look at the response before streaming the content.</span>
<span class="keyword">if</span> (response.getStatus() == HttpStatus.OK_200)
{
    <span class="comment">// Use try-with-resources to close input stream.</span>
    <span class="keyword">try</span> (<span class="predefined-type">InputStream</span> responseContent = listener.getInputStream())
    {
        <span class="comment">// Your logic here</span>
    }
}
<span class="keyword">else</span>
{
    response.abort(<span class="keyword">new</span> <span class="exception">IOException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Unexpected HTTP response</span><span class="delimiter">&quot;</span></span>));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, let&#8217;s look at the advanced usage of the response content handling.</p>
</div>
<div class="paragraph">
<p>The response content is provided by the <code>HttpClient</code> implementation to application listeners following the read/demand model of <code>org.eclipse.jetty.io.Content.Source</code>.</p>
</div>
<div class="paragraph">
<p>The listener that follows this model is <code>Response.ContentSourceListener</code>.</p>
</div>
<div class="paragraph">
<p>After the response headers have been processed by the <code>HttpClient</code> implementation, <code>Response.ContentSourceListener.onContentSource(response, contentSource)</code> is invoked once and only once.
This allows the application to control precisely the read/demand loop: when to read a chunk, how to process it and when to demand the next one.</p>
</div>
<div class="paragraph">
<p>You must provide a <code>ContentSourceListener</code> whose implementation reads a <code>Content.Chunk</code> from the provided <code>Content.Source</code>, as explained in <a href="#pg-arch-io-content-source">this section</a>.</p>
</div>
<div class="paragraph">
<p>The invocation of <code>onContentSource(Request, Content.Source)</code> and of the demand callback passed to <code>contentSource.demand(Runnable)</code> are serialized with respect to asynchronous events such as timeouts or an asynchronous call to <code>Request.abort(Throwable)</code>.
This means that these asynchronous events are not processed until the invocation of <code>onContentSource(Request, Content.Source)</code> returns, or until the invocation of the demand callback returns.
With this model, applications should not worry too much about concurrent asynchronous events happening during response content handling, because they will eventually see the events as failures while reading the response content.</p>
</div>
<div class="paragraph">
<p>Demanding for content and consuming the content are orthogonal activities.</p>
</div>
<div class="paragraph">
<p>An application can read, store aside the <code>Content.Chunk</code> objects without releasing them (to consume them later), and demand for more chunks, but it must call <code>Chunk.retain()</code> on the stored chunks, and arrange to release them after they have been consumed later.</p>
</div>
<div class="paragraph">
<p>If not done carefully, this may lead to excessive memory consumption, since the <code>ByteBuffer</code> bytes are not consumed.
Releasing the <code>Content.Chunk</code>s will result in the <code>ByteBuffer</code>s to be disposed/recycled and may be performed at any time.</p>
</div>
<div class="paragraph">
<p>An application can also read one chunk of content, consume it, release it, and then <em>not</em> demand for more content until a later time.</p>
</div>
<div class="paragraph">
<p>Subclass <code>Response.AsyncContentListener</code> overrides the behavior of <code>Response.ContentSourceListener</code>; when an application implements <code>AsyncContentListener.onContent(response, chunk, demander)</code>, it can control the disposing/recycling of the <code>ByteBuffer</code> by releasing the chunk <em>and</em> it can control when to demand one more chunk by calling <code>demander.run()</code>.</p>
</div>
<div class="paragraph">
<p>Subclass <code>Response.ContentListener</code> overrides the behavior of <code>Response.AsyncContentListener</code>; when an application implementing its <code>onContent(response, buffer)</code> returns from the method itself, it will <em>both</em> the effect of disposing/recycling the <code>buffer</code> <em>and</em> the effect of demanding one more chunk of content.</p>
</div>
<div class="paragraph">
<p>An application that implements a forwarder between two servers can be implemented efficiently by handling the response content without copying the <code>ByteBuffer</code> bytes as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Prepare a request to server1, the source.</span>
Request request1 = httpClient.newRequest(host1, port1)
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/source</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Prepare a request to server2, the sink.</span>
AsyncRequestContent content2 = <span class="keyword">new</span> AsyncRequestContent();
Request request2 = httpClient.newRequest(host2, port2)
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/sink</span><span class="delimiter">&quot;</span></span>)
    .body(content2);

request1.onResponseContentSource(<span class="keyword">new</span> Response.ContentSourceListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onContentSource(Response response, Content.Source contentSource)
    {
        <span class="comment">// Only execute this method the very first time</span>
        <span class="comment">// to initialize the request to server2.</span>

        request2.onRequestCommit(request -&gt;
        {
            <span class="comment">// Only when the request to server2 has been sent,</span>
            <span class="comment">// then demand response content from server1.</span>
            contentSource.demand(() -&gt; forwardContent(response, contentSource));
        });

        <span class="comment">// Send the request to server2.</span>
        request2.send(result -&gt; <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">forwarder</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Forwarding to server2 complete</span><span class="delimiter">&quot;</span></span>));
    }

    <span class="directive">private</span> <span class="type">void</span> forwardContent(Response response, Content.Source contentSource)
    {
        <span class="comment">// Read one chunk of content.</span>
        Content.Chunk chunk = contentSource.read();
        <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// The read chunk is null, demand to be called back</span>
            <span class="comment">// when the next one is ready to be read.</span>
            contentSource.demand(() -&gt; forwardContent(response, contentSource));
            <span class="comment">// Once a demand is in progress, the content source must not be read</span>
            <span class="comment">// nor demanded again until the demand callback is invoked.</span>
            <span class="keyword">return</span>;
        }
        <span class="comment">// Check if the chunk is last and empty, in which case the</span>
        <span class="comment">// read/demand loop is done. Demanding again when the terminal</span>
        <span class="comment">// chunk has been read will invoke the demand callback with</span>
        <span class="comment">// the same terminal chunk, so this check must be present to</span>
        <span class="comment">// avoid infinitely demanding and reading the terminal chunk.</span>
        <span class="keyword">if</span> (chunk.isLast() &amp;&amp; !chunk.hasRemaining())
        {
            chunk.release();
            <span class="keyword">return</span>;
        }

        <span class="comment">// When a response chunk is received from server1, forward it to server2.</span>
        content2.write(chunk.getByteBuffer(), <span class="predefined-type">Callback</span>.from(() -&gt;
        {
            <span class="comment">// When the request chunk is successfully sent to server2,</span>
            <span class="comment">// release the chunk to recycle the buffer.</span>
            chunk.release();
            <span class="comment">// Then demand more response content from server1.</span>
            contentSource.demand(() -&gt; forwardContent(response, contentSource));
        }, x -&gt;
        {
            chunk.release();
            response.abort(x);
        }));
    }
});

<span class="comment">// When the response content from server1 is complete,</span>
<span class="comment">// complete also the request content to server2.</span>
request1.onResponseSuccess(response -&gt; content2.close());

<span class="comment">// Send the request to server1.</span>
request1.send(result -&gt; <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">forwarder</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Sourcing from server1 complete</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-api-transport"><a class="anchor" href="#pg-client-http-api-transport"></a><a class="link" href="#pg-client-http-api-transport">Request <code>Transport</code></a></h5>
<div class="paragraph">
<p>The communication between client and server happens over a <a href="#pg-client-io-arch-transport">low-level transport</a>, and applications can specify the low-level transport to use for each request.</p>
</div>
<div class="paragraph">
<p>This gives client applications great flexibility, because they can use the same <code>HttpClient</code> instance to communicate, for example, with an external third party web application via TCP, to a different process via Unix-Domain sockets, and efficiently to the same process via memory.</p>
</div>
<div class="paragraph">
<p>Client application can also choose more esoteric configurations such as using QUIC, typically used to transport HTTP/3, to transport HTTP/1.1 or HTTP/2, because QUIC provides reliable and ordered communication like TCP does.</p>
</div>
<div class="paragraph">
<p>Provided you have configured a <a href="#pg-server-http-connector"><code>UnixDomainServerConnector</code></a> on the server, this is how you can configure a request to use Unix-Domain sockets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// This is the path where the server &quot;listens&quot; on.</span>
Path unixDomainPath = Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/server.sock</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Creates a ClientConnector.</span>
ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();

<span class="comment">// You can use Unix-Domain for HTTP/1.1.</span>
HttpClientTransportOverHTTP http1Transport = <span class="keyword">new</span> HttpClientTransportOverHTTP(clientConnector);

<span class="comment">// You can use Unix-Domain also for HTTP/2.</span>
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client(clientConnector);
HttpClientTransportOverHTTP2 http2Transport = <span class="keyword">new</span> HttpClientTransportOverHTTP2(http2Client);

<span class="comment">// You can use Unix-Domain also for the dynamic transport.</span>
ClientConnectionFactory.Info http1 = HttpClientConnectionFactory.HTTP11;
ClientConnectionFactoryOverHTTP2.HTTP2 http2 = <span class="keyword">new</span> ClientConnectionFactoryOverHTTP2.HTTP2(http2Client);
HttpClientTransportDynamic dynamicTransport = <span class="keyword">new</span> HttpClientTransportDynamic(clientConnector, http1, http2);

<span class="comment">// Choose the transport you prefer for HttpClient, for example the dynamic transport.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient(dynamicTransport);
httpClient.start();

ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">jetty.org</span><span class="delimiter">&quot;</span></span>, <span class="integer">80</span>)
    <span class="comment">// Specify that the request must be sent over Unix-Domain.</span>
    .transport(<span class="keyword">new</span> Transport.TCPUnix(unixDomainPath))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same way, if you have configured a <a href="#pg-server-http-connector"><code>MemoryConnector</code></a> on the server, this is how you can configure a request to use memory for communication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// The server-side MemoryConnector speaking HTTP/1.1.</span>
Server server = <span class="keyword">new</span> Server();
MemoryConnector memoryConnector = <span class="keyword">new</span> MemoryConnector(server, <span class="keyword">new</span> HttpConnectionFactory());
server.addConnector(memoryConnector);
<span class="comment">// ...</span>

<span class="comment">// The code above is the server-side.</span>
<span class="comment">// ----</span>
<span class="comment">// The code below is the client-side.</span>

HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();

<span class="comment">// Use the MemoryTransport to communicate with the server-side.</span>
Transport transport = <span class="keyword">new</span> MemoryTransport(memoryConnector);

httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost/</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Specify the Transport to use.</span>
    .transport(transport)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a fancy example of how to mix HTTP versions and low-level transports:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient(<span class="keyword">new</span> HttpClientTransportDynamic(clientConnector, http2, http1, http3));
httpClient.start();

<span class="comment">// Make a TCP request to a 3rd party web application.</span>
ContentResponse thirdPartyResponse = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://third-party.com/api</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// No need to specify the Transport, TCP will be used by default.</span>
    .send();

<span class="comment">// Upload the third party response content to a validation process.</span>
ContentResponse validatedResponse = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost/validate</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// The validation process is available via Unix-Domain.</span>
    .transport(<span class="keyword">new</span> Transport.TCPUnix(unixDomainPath))
    .method(HttpMethod.POST)
    .body(<span class="keyword">new</span> BytesRequestContent(thirdPartyResponse.getContent()))
    .send();

<span class="comment">// Process the validated response intra-process by sending</span>
<span class="comment">// it to another web application in the same Jetty server.</span>
ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost/process</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// The processing is in-memory.</span>
    .transport(<span class="keyword">new</span> MemoryTransport(memoryConnector))
    .method(HttpMethod.POST)
    .body(<span class="keyword">new</span> BytesRequestContent(validatedResponse.getContent()))
    .send();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-configuration"><a class="anchor" href="#pg-client-http-configuration"></a><a class="link" href="#pg-client-http-configuration">HttpClient Configuration</a></h4>
<div class="paragraph">
<p><code>HttpClient</code> has a quite large number of configuration parameters.
Please refer to the <code>HttpClient</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/client/HttpClient.html">javadocs</a> for the complete list of configurable parameters.</p>
</div>
<div class="paragraph">
<p>The most common parameters are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HttpClient.idleTimeout</code>: same as <code>ClientConnector.idleTimeout</code> described in <a href="#pg-client-io-arch-transport">this section</a>.</p>
</li>
<li>
<p><code>HttpClient.connectBlocking</code>: same as <code>ClientConnector.connectBlocking</code> described in <a href="#pg-client-io-arch-transport">this section</a>.</p>
</li>
<li>
<p><code>HttpClient.connectTimeout</code>: same as <code>ClientConnector.connectTimeout</code> described in <a href="#pg-client-io-arch-transport">this section</a>.</p>
</li>
<li>
<p><code>HttpClient.maxConnectionsPerDestination</code>: the max number of TCP connections that are opened for a particular destination (defaults to 64).</p>
</li>
<li>
<p><code>HttpClient.maxRequestsQueuedPerDestination</code>: the max number of requests queued (defaults to 1024).</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="pg-client-http-configuration-tls"><a class="anchor" href="#pg-client-http-configuration-tls"></a><a class="link" href="#pg-client-http-configuration-tls">HttpClient TLS Configuration</a></h5>
<div class="paragraph">
<p><code>HttpClient</code> supports HTTPS requests out-of-the-box like a browser does.</p>
</div>
<div class="paragraph">
<p>The support for HTTPS request is provided by a <code>SslContextFactory.Client</code> instance, typically configured in the <code>ClientConnector</code>.
If not explicitly configured, the <code>ClientConnector</code> will allocate a default one when started.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();

ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
clientConnector.setSslContextFactory(sslContextFactory);

HttpClient httpClient = <span class="keyword">new</span> HttpClient(<span class="keyword">new</span> HttpClientTransportDynamic(clientConnector));
httpClient.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default <code>SslContextFactory.Client</code> verifies the certificate sent by the server by verifying the validity of the certificate with respect to the certificate chain, the expiration date, the server host name, etc.
This means that requests to public websites that have a valid certificate (such as <code>https://google.com</code>) will work out-of-the-box, without the need to specify a KeyStore or a TrustStore.</p>
</div>
<div class="paragraph">
<p>However, requests made to sites that return an invalid or a self-signed certificate will fail (like they will in a browser).
An invalid certificate may be expired or have the wrong server host name; a self-signed certificate has a certificate chain that cannot be verified.</p>
</div>
<div class="paragraph">
<p>The validation of the server host name present in the certificate is important, to guarantee that the client is connected indeed with the intended server.</p>
</div>
<div class="paragraph">
<p>The validation of the server host name is performed at two levels: at the TLS level (in the JDK) and, optionally, at the application level.</p>
</div>
<div class="paragraph">
<p>By default, the validation of the server host name at the TLS level is enabled, while it is disabled at the application level.</p>
</div>
<div class="paragraph">
<p>You can configure the <code>SslContextFactory.Client</code> to skip the validation of the server host name at the TLS level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();
<span class="comment">// Disable the validation of the server host name at the TLS level.</span>
sslContextFactory.setEndpointIdentificationAlgorithm(<span class="predefined-constant">null</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you disable the validation of the server host name at the TLS level, you are strongly recommended to enable it at the application level.
Failing to do so puts you at risk of connecting to a server different from the one you intend to connect to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();
<span class="comment">// Only allow to connect to subdomains of domain.com.</span>
sslContextFactory.setHostnameVerifier((hostName, session) -&gt; hostName.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.domain.com</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enabling server host name validation at both the TLS level and application level allow you to further restrict the set of server hosts the client can connect to, among those allowed in the certificate sent by the server.</p>
</div>
<div class="paragraph">
<p>Entirely disabling server host name validation is not recommended, but may be done in controlled environments.</p>
</div>
<div class="paragraph">
<p>Even with server host name validation disabled, the validation of the certificate chain, by validating cryptographic signatures and validity dates is still performed.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>SslContextFactory.Client</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/util/ssl/SslContextFactory.Client.html">javadocs</a> for the complete list of configurable parameters.</p>
</div>
<div class="sect5">
<h6 id="pg-client-http-configuration-tls-listener"><a class="anchor" href="#pg-client-http-configuration-tls-listener"></a><a class="link" href="#pg-client-http-configuration-tls-listener">HttpClient <code>SslHandshakeListener</code></a></h6>
<div class="paragraph">
<p>Applications may register a <code>org.eclipse.jetty.io.ssl.SslHandshakeListener</code> to be notified of TLS handshakes success or failure, by adding the <code>SslHandshakeListener</code> as a bean to <code>HttpClient</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// Create a SslHandshakeListener.</span>
SslHandshakeListener listener = <span class="keyword">new</span> SslHandshakeListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> handshakeSucceeded(<span class="predefined-type">Event</span> event) <span class="directive">throws</span> <span class="exception">SSLException</span>
    {
        <span class="predefined-type">SSLEngine</span> sslEngine = event.getSSLEngine();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">tls</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">TLS handshake successful to %s</span><span class="delimiter">&quot;</span></span>, sslEngine.getPeerHost());
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> handshakeFailed(<span class="predefined-type">Event</span> event, <span class="predefined-type">Throwable</span> failure)
    {
        <span class="predefined-type">SSLEngine</span> sslEngine = event.getSSLEngine();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">tls</span><span class="delimiter">&quot;</span></span>).log(ERROR, <span class="string"><span class="delimiter">&quot;</span><span class="content">TLS handshake failure to %s</span><span class="delimiter">&quot;</span></span>, sslEngine.getPeerHost(), failure);
    }
};

HttpClient httpClient = <span class="keyword">new</span> HttpClient();

<span class="comment">// Add the SslHandshakeListener as bean to HttpClient.</span>
<span class="comment">// The listener will be notified of TLS handshakes success and failure.</span>
httpClient.addBean(listener);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-client-http-configuration-tls-truststore"><a class="anchor" href="#pg-client-http-configuration-tls-truststore"></a><a class="link" href="#pg-client-http-configuration-tls-truststore">HttpClient TLS TrustStore Configuration</a></h6>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-client-http-configuration-tls-client-certs"><a class="anchor" href="#pg-client-http-configuration-tls-client-certs"></a><a class="link" href="#pg-client-http-configuration-tls-client-certs">HttpClient TLS Client Certificates Configuration</a></h6>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-cookie"><a class="anchor" href="#pg-client-http-cookie"></a><a class="link" href="#pg-client-http-cookie">HttpClient Cookie Support</a></h4>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> supports cookies out of the box.</p>
</div>
<div class="paragraph">
<p>The <code>HttpClient</code> instance receives cookies from HTTP responses and stores them in a <code>java.net.CookieStore</code>, a class that is part of the JDK.
When new requests are made, the cookie store is consulted and if there are matching cookies (that is, cookies that are not expired and that match domain and path of the request) then they are added to the requests.</p>
</div>
<div class="paragraph">
<p>Applications can programmatically access the cookie store to find the cookies that have been set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpCookieStore cookieStore = httpClient.getHttpCookieStore();
<span class="predefined-type">List</span>&lt;HttpCookie&gt; cookies = cookieStore.match(<span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Applications can also programmatically set cookies as if they were returned from a HTTP response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpCookieStore cookieStore = httpClient.getHttpCookieStore();
HttpCookie cookie = HttpCookie.build(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>)
    .domain(<span class="string"><span class="delimiter">&quot;</span><span class="content">domain.com</span><span class="delimiter">&quot;</span></span>)
    .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>)
    .maxAge(<span class="predefined-type">TimeUnit</span>.DAYS.toSeconds(<span class="integer">1</span>))
    .build();
cookieStore.add(<span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com</span><span class="delimiter">&quot;</span></span>), cookie);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cookies may be added explicitly only for a particular request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>)
    .cookie(HttpCookie.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bar</span><span class="delimiter">&quot;</span></span>))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can remove cookies that you do not want to be sent in future HTTP requests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpCookieStore cookieStore = httpClient.getHttpCookieStore();
<span class="predefined-type">URI</span> uri = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">List</span>&lt;HttpCookie&gt; cookies = cookieStore.match(uri);
<span class="keyword">for</span> (HttpCookie cookie : cookies)
{
    cookieStore.remove(uri, cookie);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to totally disable cookie handling, you can install a <code>HttpCookieStore.Empty</code>.
This must be done when <code>HttpClient</code> is used in a proxy application, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.setHttpCookieStore(<span class="keyword">new</span> HttpCookieStore.Empty());</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can enable cookie filtering by installing a cookie store that performs the filtering logic in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">GoogleOnlyCookieStore</span> <span class="directive">extends</span> HttpCookieStore.Default
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> add(<span class="predefined-type">URI</span> uri, HttpCookie cookie)
    {
        <span class="keyword">if</span> (uri.getHost().endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">google.com</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="local-variable">super</span>.add(uri, cookie);
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}

httpClient.setHttpCookieStore(<span class="keyword">new</span> GoogleOnlyCookieStore());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above will retain only cookies that come from the <code>google.com</code> domain or sub-domains.</p>
</div>
<div class="sect4">
<h5 id="pg-special-characters-in-cookies"><a class="anchor" href="#pg-special-characters-in-cookies"></a><a class="link" href="#pg-special-characters-in-cookies">Special Characters in Cookies</a></h5>
<div class="paragraph">
<p>Jetty is compliant with <a href="https://tools.ietf.org/html/rfc6265">RFC6265</a>, and as such care must be taken when setting a cookie value that includes special characters such as <code>;</code>.</p>
</div>
<div class="paragraph">
<p>Previously, <code>Version=1</code> cookies defined in <a href="https://tools.ietf.org/html/rfc2109">RFC2109</a> (and continued in <a href="https://tools.ietf.org/html/rfc2965">RFC2965</a>) allowed for special/reserved characters to be enclosed within double quotes when declared in a <code>Set-Cookie</code> response header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Set-Cookie: foo=&quot;bar;baz&quot;;Version=1;Path=&quot;/secure&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This was added to the HTTP Response as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">protected</span> <span class="type">void</span> service(HttpServletRequest request, HttpServletResponse response)
{
    jakarta.servlet.http.Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">bar;baz</span><span class="delimiter">&quot;</span></span>);
    cookie.setPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/secure</span><span class="delimiter">&quot;</span></span>);
    response.addCookie(cookie);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The introduction of RFC6265 has rendered this approach no longer possible; users are now required to encode cookie values that use these special characters.
This can be done utilizing <code>jakarta.servlet.http.Cookie</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">jakarta.servlet.http.Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string"><span class="delimiter">&quot;</span><span class="content">foo</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">URLEncoder</span>.encode(<span class="string"><span class="delimiter">&quot;</span><span class="content">bar;baz</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">UTF-8</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetty validates all cookie names and values being added to the <code>HttpServletResponse</code> via the <code>addCookie(Cookie)</code> method.
If an illegal value is discovered Jetty will throw an <code>IllegalArgumentException</code> with the details.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-authentication"><a class="anchor" href="#pg-client-http-authentication"></a><a class="link" href="#pg-client-http-authentication">HttpClient Authentication Support</a></h4>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> supports the <code>BASIC</code> and <code>DIGEST</code> authentication mechanisms defined by <a href="https://tools.ietf.org/html/rfc7235">RFC 7235</a>, as well as the SPNEGO authentication mechanism defined in <a href="https://tools.ietf.org/html/rfc4559">RFC 4559</a>.</p>
</div>
<div class="paragraph">
<p>The HTTP <em>conversation</em>, the sequence of related HTTP requests, for a request that needs authentication is the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-136e615bb97d8356ceb17a851c86817a.png" alt="Diagram" width="366" height="207">
</div>
</div>
<div class="paragraph">
<p>Upon receiving a HTTP 401 response code, <code>HttpClient</code> looks at the <code>WWW-Authenticate</code> response header (the server <em>challenge</em>) and then tries to match configured authentication credentials to produce an <code>Authentication</code> header that contains the authentication credentials to access the resource.</p>
</div>
<div class="paragraph">
<p>You can configure authentication credentials in the <code>HttpClient</code> instance as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Add authentication credentials.</span>
AuthenticationStore auth = httpClient.getAuthenticationStore();

<span class="predefined-type">URI</span> uri1 = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://mydomain.com/secure</span><span class="delimiter">&quot;</span></span>);
auth.addAuthentication(<span class="keyword">new</span> BasicAuthentication(uri1, <span class="string"><span class="delimiter">&quot;</span><span class="content">MyRealm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">userName1</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password1</span><span class="delimiter">&quot;</span></span>));

<span class="predefined-type">URI</span> uri2 = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://otherdomain.com/admin</span><span class="delimiter">&quot;</span></span>);
auth.addAuthentication(<span class="keyword">new</span> BasicAuthentication(uri1, <span class="string"><span class="delimiter">&quot;</span><span class="content">AdminRealm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">admin</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Authentication</code>s are matched against the server challenge first by mechanism (e.g. <code>BASIC</code> or <code>DIGEST</code>), then by realm and then by URI.</p>
</div>
<div class="paragraph">
<p>If an <code>Authentication</code> match is found, the application does not receive events related to the HTTP 401 response.
These events are handled internally by <code>HttpClient</code> which produces another (internal) request similar to the original request but with an additional <code>Authorization</code> header.</p>
</div>
<div class="paragraph">
<p>If the authentication is successful, the server responds with a HTTP 200 and <code>HttpClient</code> caches the <code>Authentication.Result</code> so that subsequent requests for a matching URI will not incur in the additional rountrip caused by the HTTP 401 response.</p>
</div>
<div class="paragraph">
<p>It is possible to clear <code>Authentication.Result</code>s in order to force authentication again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">httpClient.getAuthenticationStore().clearAuthenticationResults();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Authentication results may be preempted to avoid the additional roundtrip due to the server challenge in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AuthenticationStore auth = httpClient.getAuthenticationStore();
<span class="predefined-type">URI</span> uri = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/secure</span><span class="delimiter">&quot;</span></span>);
auth.addAuthenticationResult(<span class="keyword">new</span> BasicAuthentication.BasicResult(uri, <span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this way, requests for the given URI are enriched immediately with the <code>Authorization</code> header, and the server should respond with HTTP 200 (and the resource content) rather than with the 401 and the challenge.</p>
</div>
<div class="paragraph">
<p>It is also possible to preempt the authentication for a single request only, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">URI</span> uri = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/secure</span><span class="delimiter">&quot;</span></span>);
Authentication.Result authn = <span class="keyword">new</span> BasicAuthentication.BasicResult(uri, <span class="string"><span class="delimiter">&quot;</span><span class="content">username</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">password</span><span class="delimiter">&quot;</span></span>);
Request request = httpClient.newRequest(uri);
authn.apply(request);
request.send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <a href="#pg-client-http-proxy-authentication">proxy authentication section</a> for further information about how authentication works with HTTP proxies.</p>
</div>
<div class="sect4">
<h5 id="pg-client-http-authentication-spnego"><a class="anchor" href="#pg-client-http-authentication-spnego"></a><a class="link" href="#pg-client-http-authentication-spnego">HttpClient SPNEGO Authentication Support</a></h5>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-proxy"><a class="anchor" href="#pg-client-http-proxy"></a><a class="link" href="#pg-client-http-proxy">HttpClient Proxy Support</a></h4>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> can be configured to use proxies to connect to destinations.</p>
</div>
<div class="paragraph">
<p>These types of proxies are available out of the box:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP proxy (provided by class <code>org.eclipse.jetty.client.HttpProxy</code>)</p>
</li>
<li>
<p>SOCKS 4 proxy (provided by class <code>org.eclipse.jetty.client.Socks4Proxy</code>)</p>
</li>
<li>
<p><a href="#pg-client-http-proxy-socks5">SOCKS 5 proxy</a> (provided by class <code>org.eclipse.jetty.client.Socks5Proxy</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other implementations may be written by subclassing <code>ProxyConfiguration.Proxy</code>.</p>
</div>
<div class="paragraph">
<p>The following is a typical configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpProxy proxy = <span class="keyword">new</span> HttpProxy(<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyHost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8888</span>);

<span class="comment">// Do not proxy requests for localhost:8080.</span>
proxy.getExcludedAddresses().add(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost:8080</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add the new proxy to the list of proxies already registered.</span>
ProxyConfiguration proxyConfig = httpClient.getProxyConfiguration();
proxyConfig.addProxy(proxy);

ContentResponse response = httpClient.GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You specify the proxy host and proxy port, and optionally also the addresses that you do not want to be proxied, and then add the proxy configuration on the <code>ProxyConfiguration</code> instance.</p>
</div>
<div class="paragraph">
<p>Configured in this way, <code>HttpClient</code> makes requests to the HTTP proxy (for plain-text HTTP requests) or establishes a tunnel via HTTP <code>CONNECT</code> (for encrypted HTTPS requests).</p>
</div>
<div class="paragraph">
<p>Proxying is supported for any version of the HTTP protocol.</p>
</div>
<div class="paragraph">
<p>The communication between the client and the proxy may be encrypted, so that it would not be possible for another party on the same network as the client to know what servers the client connects to.</p>
</div>
<div class="sect4">
<h5 id="pg-client-http-proxy-socks5"><a class="anchor" href="#pg-client-http-proxy-socks5"></a><a class="link" href="#pg-client-http-proxy-socks5">SOCKS5 Proxy Support</a></h5>
<div class="paragraph">
<p>SOCKS 5 (defined in <a href="https://datatracker.ietf.org/doc/html/rfc1928">RFC 1928</a>) offers choices for authentication methods and supports IPv6 (things that SOCKS 4 does not support).</p>
</div>
<div class="paragraph">
<p>A typical SOCKS 5 proxy configuration with the username/password authentication method is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Socks5Proxy proxy = <span class="keyword">new</span> Socks5Proxy(<span class="string"><span class="delimiter">&quot;</span><span class="content">proxyHost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8888</span>);
<span class="predefined-type">String</span> socks5User = <span class="string"><span class="delimiter">&quot;</span><span class="content">jetty</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">String</span> socks5Pass = <span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>;
<span class="type">var</span> socks5AuthenticationFactory = <span class="keyword">new</span> Socks5.UsernamePasswordAuthenticationFactory(socks5User, socks5Pass);
<span class="comment">// Add the authentication method to the proxy.</span>
proxy.putAuthenticationFactory(socks5AuthenticationFactory);

<span class="comment">// Do not proxy requests for localhost:8080.</span>
proxy.getExcludedAddresses().add(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost:8080</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add the new proxy to the list of proxies already registered.</span>
ProxyConfiguration proxyConfig = httpClient.getProxyConfiguration();
proxyConfig.addProxy(proxy);

ContentResponse response = httpClient.GET(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/path</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-proxy-authentication"><a class="anchor" href="#pg-client-http-proxy-authentication"></a><a class="link" href="#pg-client-http-proxy-authentication">HTTP Proxy Authentication Support</a></h5>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> supports HTTP proxy authentication in the same way it supports <a href="#pg-client-http-authentication">server authentication</a>.</p>
</div>
<div class="paragraph">
<p>In the example below, the HTTP proxy requires <code>BASIC</code> authentication, but the server requires <code>DIGEST</code> authentication, and therefore:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">AuthenticationStore auth = httpClient.getAuthenticationStore();

<span class="comment">// Proxy credentials.</span>
<span class="predefined-type">URI</span> proxyURI = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://proxy.net:8080</span><span class="delimiter">&quot;</span></span>);
auth.addAuthentication(<span class="keyword">new</span> BasicAuthentication(proxyURI, <span class="string"><span class="delimiter">&quot;</span><span class="content">ProxyRealm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">proxyUser</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">proxyPass</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// Server credentials.</span>
<span class="predefined-type">URI</span> serverURI = <span class="keyword">new</span> <span class="predefined-type">URI</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com/secure</span><span class="delimiter">&quot;</span></span>);
auth.addAuthentication(<span class="keyword">new</span> DigestAuthentication(serverURI, <span class="string"><span class="delimiter">&quot;</span><span class="content">ServerRealm</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">serverUser</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">serverPass</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// Proxy configuration.</span>
ProxyConfiguration proxyConfig = httpClient.getProxyConfiguration();
HttpProxy proxy = <span class="keyword">new</span> HttpProxy(<span class="string"><span class="delimiter">&quot;</span><span class="content">proxy.net</span><span class="delimiter">&quot;</span></span>, <span class="integer">8080</span>);
proxyConfig.addProxy(proxy);

ContentResponse response = httpClient.newRequest(serverURI).send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The HTTP conversation for successful authentications on both the proxy and the server is the following:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-e7fd1b7ba54e07262bd726c9fe979363.png" alt="Diagram" width="703" height="411">
</div>
</div>
<div class="paragraph">
<p>The application does not receive events related to the responses with code 407 and 401 since they are handled internally by <code>HttpClient</code>.</p>
</div>
<div class="paragraph">
<p>Similarly to the <a href="#pg-client-http-authentication">authentication section</a>, the proxy authentication result and the server authentication result can be preempted to avoid, respectively, the 407 and 401 roundtrips.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http-transport"><a class="anchor" href="#pg-client-http-transport"></a><a class="link" href="#pg-client-http-transport">HttpClient Pluggable Transports</a></h4>
<div class="paragraph">
<p>Jetty&#8217;s <code>HttpClient</code> can be configured to use different HTTP formats to carry the semantic of HTTP requests and responses, by specifying different <code>HttpClientTransport</code> implementations.</p>
</div>
<div class="paragraph">
<p>This means that the intention of a client to request resource <code>/index.html</code> using the <code>GET</code> method can be carried over a <a href="#pg-client-http-api-transport">low-level transport</a> in different formats.</p>
</div>
<div class="paragraph">
<p>An <code>HttpClientTransport</code> is the component that is in charge of converting a high-level, semantic, HTTP requests such as " <code>GET</code> resource <code>/index.html</code> " into the specific format understood by the server (for example, HTTP/2 or HTTP/3), and to convert the server response from the specific format (HTTP/2 or HTTP/3) into high-level, semantic objects that can be used by applications.</p>
</div>
<div class="paragraph">
<p>The most common protocol format is HTTP/1.1, a textual protocol with lines separated by <code>\r\n</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">GET /index.html HTTP/1.1\r\n
Host: domain.com\r\n
...
\r\n</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the same request can be made using FastCGI, a binary protocol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">x01 x01 x00 x01 x00 x08 x00 x00
x00 x01 x01 x00 x00 x00 x00 x00
x01 x04 x00 x01 xLL xLL x00 x00
x0C x0B  D   O   C   U   M   E
 N   T   _   U   R   I   /   i
 n   d   e   x   .   h   t   m
 l
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, HTTP/2 is a binary protocol that transports the same information in a yet different format via TCP, while HTTP/3 is a binary protocol that transports the same information in yet another format via QUIC.</p>
</div>
<div class="paragraph">
<p>The HTTP protocol version may be <em>negotiated</em> between client and server.
A request for a resource may be sent using one protocol (for example, HTTP/1.1), but the response may arrive in a different protocol (for example, HTTP/2).</p>
</div>
<div class="paragraph">
<p><code>HttpClient</code> supports these <code>HttpClientTransport</code> implementations, each speaking only one protocol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HttpClientTransportOverHTTP</code>, for <a href="#pg-client-http-transport-http11">HTTP/1.1</a> (both clear-text and TLS encrypted)</p>
</li>
<li>
<p><code>HttpClientTransportOverHTTP2</code>, for <a href="#pg-client-http-transport-http2">HTTP/2</a> (both clear-text and TLS encrypted)</p>
</li>
<li>
<p><code>HttpClientTransportOverHTTP3</code>, for <a href="#pg-client-http-transport-http3">HTTP/3</a> (only encrypted via QUIC)</p>
</li>
<li>
<p><code>HttpClientTransportOverFCGI</code>, for <a href="#pg-client-http-transport-fcgi">FastCGI</a> (both clear-text and TLS encrypted)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>HttpClient</code> also supports <code>HttpClientTransportDynamic</code>, a <a href="#pg-client-http-transport-dynamic">dynamic transport</a> that can speak different HTTP formats and can select the right protocol by negotiating it with the server or by explicit indication from applications.</p>
</div>
<div class="paragraph">
<p>Furthermore, every HTTP format can be sent over different <a href="#pg-client-http-api-transport">low-level transports</a> such as TCP, Unix-Domain, QUIC or memory.
Supports for Unix-Domain sockets requires Java 16 or later, since Unix-Domain sockets support has been introduced in OpenJDK with <a href="https://openjdk.java.net/jeps/380">JEP 380</a>.</p>
</div>
<div class="paragraph">
<p>Applications are typically not aware of the actual HTTP format or low-level transport being used.
This allows them to write their logic against a high-level API that hides the details of the specific HTTP format and low-level transport being used.</p>
</div>
<div class="sect4">
<h5 id="pg-client-http-transport-http11"><a class="anchor" href="#pg-client-http-transport-http11"></a><a class="link" href="#pg-client-http-transport-http11">HTTP/1.1 Transport</a></h5>
<div class="paragraph">
<p>HTTP/1.1 is the default transport.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// No transport specified, using default.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to customize the HTTP/1.1 transport, you can explicitly configure it in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Configure HTTP/1.1 transport.</span>
HttpClientTransportOverHTTP transport = <span class="keyword">new</span> HttpClientTransportOverHTTP();
transport.setHeaderCacheSize(<span class="integer">16384</span>);

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-transport-http2"><a class="anchor" href="#pg-client-http-transport-http2"></a><a class="link" href="#pg-client-http-transport-http2">HTTP/2 Transport</a></h5>
<div class="paragraph">
<p>The HTTP/2 transport can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// The HTTP2Client powers the HTTP/2 transport.</span>
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client();
http2Client.setInitialSessionRecvWindow(<span class="integer">64</span> * <span class="integer">1024</span> * <span class="integer">1024</span>);

<span class="comment">// Create and configure the HTTP/2 transport.</span>
HttpClientTransportOverHTTP2 transport = <span class="keyword">new</span> HttpClientTransportOverHTTP2(http2Client);
transport.setUseALPN(<span class="predefined-constant">true</span>);

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HTTP2Client</code> is the lower-level client that provides an API based on HTTP/2 concepts such as <em>sessions</em>, <em>streams</em> and <em>frames</em> that are specific to HTTP/2. See <a href="#pg-client-http2">the HTTP/2 client section</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>HttpClientTransportOverHTTP2</code> uses <code>HTTP2Client</code> to format high-level semantic HTTP requests into the HTTP/2 specific format.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-transport-http3"><a class="anchor" href="#pg-client-http-transport-http3"></a><a class="link" href="#pg-client-http-transport-http3">HTTP/3 Transport</a></h5>
<div class="paragraph">
<p>The HTTP/3 transport can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// HTTP/3 requires secure communication.</span>
SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();
<span class="comment">// The HTTP3Client powers the HTTP/3 transport.</span>
ClientQuicConfiguration clientQuicConfig = <span class="keyword">new</span> ClientQuicConfiguration(sslContextFactory, <span class="predefined-constant">null</span>);
HTTP3Client http3Client = <span class="keyword">new</span> HTTP3Client(clientQuicConfig);
http3Client.getQuicConfiguration().setSessionRecvWindow(<span class="integer">64</span> * <span class="integer">1024</span> * <span class="integer">1024</span>);

<span class="comment">// Create and configure the HTTP/3 transport.</span>
HttpClientTransportOverHTTP3 transport = <span class="keyword">new</span> HttpClientTransportOverHTTP3(http3Client);

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HTTP3Client</code> is the lower-level client that provides an API based on HTTP/3 concepts such as <em>sessions</em>, <em>streams</em> and <em>frames</em> that are specific to HTTP/3. See <a href="#pg-client-http3">the HTTP/3 client section</a> for more information.</p>
</div>
<div class="paragraph">
<p><code>HttpClientTransportOverHTTP3</code> uses <code>HTTP3Client</code> to format high-level semantic HTTP requests into the HTTP/3 specific format.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-transport-fcgi"><a class="anchor" href="#pg-client-http-transport-fcgi"></a><a class="link" href="#pg-client-http-transport-fcgi">FastCGI Transport</a></h5>
<div class="paragraph">
<p>The FastCGI transport can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">String</span> scriptRoot = <span class="string"><span class="delimiter">&quot;</span><span class="content">/var/www/wordpress</span><span class="delimiter">&quot;</span></span>;
HttpClientTransportOverFCGI transport = <span class="keyword">new</span> HttpClientTransportOverFCGI(scriptRoot);

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to make requests using the FastCGI transport, you need to have a FastCGI server such as <a href="https://en.wikipedia.org/wiki/PHP#PHPFPM">PHP-FPM</a> (see also link:http://php.net/manual/en/install.fpm.php).</p>
</div>
<div class="paragraph">
<p>The FastCGI transport is primarily used by Jetty&#8217;s <a href="#pg-server-fastcgi">FastCGI support</a> to serve PHP pages (WordPress for example).</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-http-transport-dynamic"><a class="anchor" href="#pg-client-http-transport-dynamic"></a><a class="link" href="#pg-client-http-transport-dynamic">Dynamic Transport</a></h5>
<div class="paragraph">
<p>The static <code>HttpClientTransport</code> implementations work well if you know in advance the protocol you want to speak with the server, or if the server only supports one protocol (such as FastCGI).</p>
</div>
<div class="paragraph">
<p>With the advent of HTTP/2 and HTTP/3, however, servers are now able to support multiple protocols.</p>
</div>
<div class="paragraph">
<p>The HTTP/2 protocol is typically negotiated between client and server.
This negotiation can happen via ALPN, a TLS extension that allows the client to tell the server the list of protocol that the client supports, so that the server can pick one of the client supported protocols that also the server supports; or via HTTP/1.1 upgrade by means of the <code>Upgrade</code> header.</p>
</div>
<div class="paragraph">
<p>Applications can configure the dynamic transport with one or more HTTP versions such as HTTP/1.1, HTTP/2 or HTTP/3.
The implementation will take care of using TLS for HTTPS URIs, using ALPN if necessary, negotiating protocols, upgrading from one protocol to another, etc.</p>
</div>
<div class="paragraph">
<p>By default, the dynamic transport only speaks HTTP/1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Dynamic transport speaks HTTP/1.1 by default.</span>
HttpClientTransportDynamic transport = <span class="keyword">new</span> HttpClientTransportDynamic();

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The dynamic transport can be configured with just one protocol, making it equivalent to the corresponding static transport:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientConnector connector = <span class="keyword">new</span> ClientConnector();

<span class="comment">// Equivalent to HttpClientTransportOverHTTP.</span>
HttpClientTransportDynamic http11Transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, HttpClientConnectionFactory.HTTP11);

<span class="comment">// Equivalent to HttpClientTransportOverHTTP2.</span>
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client(connector);
HttpClientTransportDynamic http2Transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, <span class="keyword">new</span> ClientConnectionFactoryOverHTTP2.HTTP2(http2Client));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The dynamic transport, however, has been implemented to support multiple transports, in particular HTTP/1.1, HTTP/2 and HTTP/3:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();

ClientConnector connector = <span class="keyword">new</span> ClientConnector();
connector.setSslContextFactory(sslContextFactory);

ClientConnectionFactory.Info http1 = HttpClientConnectionFactory.HTTP11;

HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client(connector);
ClientConnectionFactoryOverHTTP2.HTTP2 http2 = <span class="keyword">new</span> ClientConnectionFactoryOverHTTP2.HTTP2(http2Client);

ClientQuicConfiguration quicConfiguration = <span class="keyword">new</span> ClientQuicConfiguration(sslContextFactory, <span class="predefined-constant">null</span>);
HTTP3Client http3Client = <span class="keyword">new</span> HTTP3Client(quicConfiguration, connector);
ClientConnectionFactoryOverHTTP3.HTTP3 http3 = <span class="keyword">new</span> ClientConnectionFactoryOverHTTP3.HTTP3(http3Client);

<span class="comment">// The order of the protocols indicates the client's preference.</span>
<span class="comment">// The first is the most preferred, the last is the least preferred, but</span>
<span class="comment">// the protocol version to use can be explicitly specified in the request.</span>
HttpClientTransportDynamic transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, http1, http2, http3);

HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The order in which the protocols are specified to <code>HttpClientTransportDynamic</code> indicates what is the client preference (first the most preferred).</p>
</div>
<div class="paragraph">
<p>When clear-text communication is used (i.e. URIs with the <code>http</code> scheme) there is no HTTP protocol version negotiation, and therefore the application must know <em>a priori</em> whether the server supports the HTTP version or not.
For example, if the server only supports clear-text HTTP/2, and <code>HttpClientTransportDynamic</code> is configured as in the example above, where HTTP/1.1 has precedence over HTTP/2, the client will send, by default, a clear-text HTTP/1.1 request to a clear-text HTTP/2 only server, which will result in a communication failure.</p>
</div>
<div class="paragraph">
<p>When using TLS (i.e. URIs with the <code>https</code> scheme), the HTTP protocol version is <em>negotiated</em> between client and server via ALPN, and it is the server that decides what is the application protocol to use for the communication, regardless of the client preference.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>HTTP/1.1 and HTTP/2 are <em>compatible</em> because they both use TCP, while HTTP/3 is incompatible with previous HTTP versions because it uses QUIC.</p>
</div>
<div class="paragraph">
<p>Only compatible HTTP versions can negotiate the HTTP protocol version to use via ALPN, and only compatible HTTP versions can be upgraded from an older version to a newer version.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Provided that the server supports HTTP/1.1, HTTP/2 and HTTP/3, client applications can explicitly hint the version they want to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">HttpClientTransportDynamic transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, http1, http2, http3);
HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();

<span class="comment">// The server supports HTTP/1.1, HTTP/2 and HTTP/3.</span>

ContentResponse http1Response = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Specify the version explicitly.</span>
    .version(HttpVersion.HTTP_1_1)
    .send();

ContentResponse http2Response = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Specify the version explicitly.</span>
    .version(HttpVersion.HTTP_2)
    .send();

ContentResponse http3Response = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Specify the version explicitly.</span>
    .version(HttpVersion.HTTP_3)
    .send();

<span class="comment">// Make a clear-text upgrade request from HTTP/1.1 to HTTP/2.</span>
<span class="comment">// The request will start as HTTP/1.1, but the response will be HTTP/2.</span>
ContentResponse upgradedResponse = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    .headers(headers -&gt; headers
        .put(HttpHeader.UPGRADE, <span class="string"><span class="delimiter">&quot;</span><span class="content">h2c</span><span class="delimiter">&quot;</span></span>)
        .put(HttpHeader.HTTP2_SETTINGS, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>)
        .put(HttpHeader.CONNECTION, <span class="string"><span class="delimiter">&quot;</span><span class="content">Upgrade, HTTP2-Settings</span><span class="delimiter">&quot;</span></span>))
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the client application explicitly specifies the HTTP version, then ALPN is not used by the client.
By specifying the HTTP version explicitly, the client application has prior-knowledge of what HTTP version the server supports, and therefore ALPN is not needed.
If the server does not support the HTTP version chosen by the client, then the communication will fail.</p>
</div>
<div class="paragraph">
<p>If the client application does not explicitly specify the HTTP version, then ALPN will be used by the client, but only for compatible protocols.
If the server also supports ALPN, then the protocol will be negotiated via ALPN and the server will choose the protocol to use.
If the server does not support ALPN, the client will try to use the first protocol configured in <code>HttpClientTransportDynamic</code>, and the communication may succeed or fail depending on whether the server supports the protocol chosen by the client.</p>
</div>
<div class="paragraph">
<p>For example, HTTP/3 is not compatible with previous HTTP version; if <code>HttpClientTransportDynamic</code> is configured to prefer HTTP/3, it will be the only protocol attempted by the client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// Client prefers HTTP/3.</span>
HttpClientTransportDynamic transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, http3, http2, http1);
HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();

<span class="comment">// No explicit HTTP version specified.</span>
<span class="comment">// Either HTTP/3 succeeds, or communication failure.</span>
ContentResponse httpResponse = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    .send();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the client application configures <code>HttpClientTransportDynamic</code> to prefer HTTP/2, there could be ALPN negotiation between HTTP/2 and HTTP/1.1 (but not HTTP/3 because it is incompatible); HTTP/3 will only be possible by specifying the HTTP version explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// Client prefers HTTP/2.</span>
HttpClientTransportDynamic transport = <span class="keyword">new</span> HttpClientTransportDynamic(connector, http2, http1, http3);
HttpClient client = <span class="keyword">new</span> HttpClient(transport);
client.start();

<span class="comment">// No explicit HTTP version specified.</span>
<span class="comment">// Either HTTP/1.1 or HTTP/2 will be negotiated via ALPN.</span>
<span class="comment">// HTTP/3 only possible by specifying the version explicitly.</span>
ContentResponse httpResponse = client.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">https://host/</span><span class="delimiter">&quot;</span></span>)
    .send();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-client-http2"><a class="anchor" href="#pg-client-http2"></a><a class="link" href="#pg-client-http2">HTTP/2 Client Library</a></h3>
<div class="paragraph">
<p>In the vast majority of cases, client applications should use the generic, high-level, <a href="#pg-client-http">HTTP client library</a> that also provides HTTP/2 support via the pluggable <a href="#pg-client-http-transport-http2">HTTP/2 transport</a> or the <a href="#pg-client-http-transport-dynamic">dynamic transport</a>.</p>
</div>
<div class="paragraph">
<p>The high-level HTTP library supports cookies, authentication, redirection, connection pooling and a number of other features that are absent in the low-level HTTP/2 library.</p>
</div>
<div class="paragraph">
<p>The HTTP/2 client library has been designed for those applications that need low-level access to HTTP/2 features such as <em>sessions</em>, <em>streams</em> and <em>frames</em>, and this is quite a rare use case.</p>
</div>
<div class="paragraph">
<p>See also the correspondent <a href="#pg-server-http2">HTTP/2 server library</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-client-http2-intro"><a class="anchor" href="#pg-client-http2-intro"></a><a class="link" href="#pg-client-http2-intro">Introducing HTTP2Client</a></h4>
<div class="paragraph">
<p>The Maven artifact coordinates for the HTTP/2 client library are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.http2<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-http2-client<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main class is named <code>org.eclipse.jetty.http2.client.HTTP2Client</code>, and must be created, configured and started before use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Instantiate HTTP2Client.</span>
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client();

<span class="comment">// Configure HTTP2Client, for example:</span>
http2Client.setStreamIdleTimeout(<span class="integer">15000</span>);

<span class="comment">// Start HTTP2Client.</span>
http2Client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When your application stops, or otherwise does not need <code>HTTP2Client</code> anymore, it should stop the <code>HTTP2Client</code> instance (or instances) that were started:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Stop HTTP2Client.</span>
http2Client.stop();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HTTP2Client</code> allows client applications to connect to an HTTP/2 server.
A <em>session</em> represents a single TCP connection to an HTTP/2 server and is defined by class <code>org.eclipse.jetty.http2.api.Session</code>.
A <em>session</em> typically has a long life&#8201;&#8212;&#8201;once the TCP connection is established, it remains open until it is not used anymore (and therefore it is closed by the idle timeout mechanism), until a fatal error occurs (for example, a network failure), or if one of the peers decides unilaterally to close the TCP connection.</p>
</div>
<div class="paragraph">
<p>HTTP/2 is a multiplexed protocol: it allows multiple HTTP/2 requests to be sent on the same TCP connection, or <em>session</em>.
Each request/response cycle is represented by a <em>stream</em>.
Therefore, a single <em>session</em> manages multiple concurrent <em>streams</em>.
A <em>stream</em> has typically a very short life compared to the <em>session</em>: a <em>stream</em> only exists for the duration of the request/response cycle and then disappears.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-flow-control"><a class="anchor" href="#pg-client-http2-flow-control"></a><a class="link" href="#pg-client-http2-flow-control">HTTP/2 Flow Control</a></h4>
<div class="paragraph">
<p>The HTTP/2 protocol is <em>flow controlled</em> (see <a href="https://tools.ietf.org/html/rfc7540#section-5.2">the specification</a>).
This means that a sender and a receiver maintain a <em>flow control window</em> that tracks the number of data bytes sent and received, respectively.
When a sender sends data bytes, it reduces its flow control window.
When a receiver receives data bytes, it also reduces its flow control window, and then passes the received data bytes to the application.
The application consumes the data bytes and tells back the receiver that it has consumed the data bytes.
The receiver then enlarges the flow control window, and the implementation arranges to send a message to the sender with the number of bytes consumed, so that the sender can enlarge its flow control window.</p>
</div>
<div class="paragraph">
<p>A sender can send data bytes up to its whole flow control window, then it must stop sending.
The sender may resume sending data bytes when it receives a message from the receiver that the data bytes sent previously have been consumed.
This message enlarges the sender flow control window, which allows the sender to send more data bytes.</p>
</div>
<div class="paragraph">
<p>HTTP/2 defines <em>two</em> flow control windows: one for each <em>session</em>, and one for each <em>stream</em>.
Let&#8217;s see with an example how they interact, assuming that in this example the session flow control window is 120 bytes and the stream flow control window is 100 bytes.</p>
</div>
<div class="paragraph">
<p>The sender opens a session, and then opens <code>stream_1</code> on that session, and sends <code>80</code> data bytes.
At this point the session flow control window is <code>40</code> bytes (<code>120 - 80</code>), and <code>stream_1</code>'s flow control window is <code>20</code> bytes (<code>100 - 80</code>).
The sender now opens <code>stream_2</code> on the same session and sends <code>40</code> data bytes.
At this point, the session flow control window is <code>0</code> bytes (<code>40 - 40</code>), while <code>stream_2</code>'s flow control window is <code>60</code> (<code>100 - 40</code>).
Since now the session flow control window is <code>0</code>, the sender cannot send more data bytes, neither on <code>stream_1</code> nor on <code>stream_2</code>, nor on other streams, despite all the streams having their stream flow control windows greater than <code>0</code>.</p>
</div>
<div class="paragraph">
<p>The receiver consumes <code>stream_2</code>'s <code>40</code> data bytes and sends a message to the sender with this information.
At this point, the session flow control window is <code>40</code> (<code>0 + 40</code>), <code>stream_1</code>'s flow control window is still <code>20</code> and <code>stream_2</code>'s flow control window is <code>100</code> (<code>60 + 40</code>).
If the sender opens <code>stream_3</code> and would like to send <code>50</code> data bytes, it would only be able to send <code>40</code> because that is the maximum allowed by the session flow control window at this point.</p>
</div>
<div class="paragraph">
<p>It is therefore very important that applications notify the fact that they have consumed data bytes as soon as possible, so that the implementation (the receiver) can send a message to the sender (in the form of a <code>WINDOW_UPDATE</code> frame) with the information to enlarge the flow control window, therefore reducing the possibility that sender stalls due to the flow control windows being reduced to <code>0</code>.</p>
</div>
<div class="paragraph">
<p>How a client application should handle HTTP/2 flow control is discussed in details in <a href="#pg-client-http2-response">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-connect"><a class="anchor" href="#pg-client-http2-connect"></a><a class="link" href="#pg-client-http2-connect">Connecting to the Server</a></h4>
<div class="paragraph">
<p>The first thing an application should do is to connect to the server and obtain a <code>Session</code>.
The following example connects to the server on a clear-text port:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Address of the server's clear-text port.</span>
<span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8080</span>);

<span class="comment">// Connect to the server, the CompletableFuture will be</span>
<span class="comment">// notified when the connection is succeeded (or failed).</span>
CompletableFuture&lt;Session&gt; sessionCF = http2Client.connect(serverAddress, <span class="keyword">new</span> Session.Listener() {});

<span class="comment">// Block to obtain the Session.</span>
<span class="comment">// Alternatively you can use the CompletableFuture APIs to avoid blocking.</span>
Session session = sessionCF.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example connects to the server on an encrypted port:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client();
http2Client.start();

ClientConnector connector = http2Client.getClientConnector();

<span class="comment">// Address of the server's encrypted port.</span>
<span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8443</span>);

<span class="comment">// Connect to the server, the CompletableFuture will be</span>
<span class="comment">// notified when the connection is succeeded (or failed).</span>
CompletableFuture&lt;Session&gt; sessionCF = http2Client.connect(connector.getSslContextFactory(), serverAddress, <span class="keyword">new</span> Session.Listener() {});

<span class="comment">// Block to obtain the Session.</span>
<span class="comment">// Alternatively you can use the CompletableFuture APIs to avoid blocking.</span>
Session session = sessionCF.get();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Applications must know in advance whether they want to connect to a clear-text or encrypted port, and pass the <code>SslContextFactory</code> parameter accordingly to the <code>connect(...)</code> method.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-configure"><a class="anchor" href="#pg-client-http2-configure"></a><a class="link" href="#pg-client-http2-configure">Configuring the Session</a></h4>
<div class="paragraph">
<p>The <code>connect(...)</code> method takes a <code>Session.Listener</code> parameter.
This listener&#8217;s <code>onPreface(...)</code> method is invoked just before establishing the connection to the server to gather the client configuration to send to the server.
Client applications can override this method to change the default configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8080</span>);
http2Client.connect(serverAddress, <span class="keyword">new</span> Session.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt; onPreface(Session session)
    {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt; configuration = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

        <span class="comment">// Disable push from the server.</span>
        configuration.put(SettingsFrame.ENABLE_PUSH, <span class="integer">0</span>);

        <span class="comment">// Override HTTP2Client.initialStreamRecvWindow for this session.</span>
        configuration.put(SettingsFrame.INITIAL_WINDOW_SIZE, <span class="integer">1024</span> * <span class="integer">1024</span>);

        <span class="keyword">return</span> configuration;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Session.Listener</code> is notified of session events originated by the server such as receiving a <code>SETTINGS</code> frame from the server, or the server closing the connection, or the client timing out the connection due to idleness.
Please refer to the <code>Session.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http2/api/Session.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>Once a <code>Session</code> has been established, the communication with the server happens by exchanging <em>frames</em>, as specified in the <a href="https://tools.ietf.org/html/rfc7540#section-4">HTTP/2 specification</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-request"><a class="anchor" href="#pg-client-http2-request"></a><a class="link" href="#pg-client-http2-request">Sending a Request</a></h4>
<div class="paragraph">
<p>Sending an HTTP request to the server, and receiving a response, creates a <em>stream</em> that encapsulates the exchange of HTTP/2 frames that compose the request and the response.</p>
</div>
<div class="paragraph">
<p>In order to send an HTTP request to the server, the client must send a <code>HEADERS</code> frame.
<code>HEADERS</code> frames carry the request method, the request URI and the request headers.
Sending the <code>HEADERS</code> frame opens the <code>Stream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8080</span>);
CompletableFuture&lt;Session&gt; sessionCF = http2Client.connect(serverAddress, <span class="keyword">new</span> Session.Listener() {});
Session session = sessionCF.get();

<span class="comment">// Configure the request headers.</span>
HttpFields requestHeaders = HttpFields.build()
    .put(HttpHeader.USER_AGENT, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jetty HTTP2Client 12.0.10-SNAPSHOT</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The request metadata with method, URI and headers.</span>
MetaData.Request request = <span class="keyword">new</span> MetaData.Request(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, HttpURI.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/path</span><span class="delimiter">&quot;</span></span>), HttpVersion.HTTP_2, requestHeaders);

<span class="comment">// The HTTP/2 HEADERS frame, with endStream=true</span>
<span class="comment">// to signal that this request has no content.</span>
HeadersFrame headersFrame = <span class="keyword">new</span> HeadersFrame(request, <span class="predefined-constant">null</span>, <span class="predefined-constant">true</span>);

<span class="comment">// Open a Stream by sending the HEADERS frame.</span>
session.newStream(headersFrame, <span class="predefined-constant">null</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how <code>Session.newStream(...)</code> takes a <code>Stream.Listener</code> parameter.
This listener is notified of stream events originated by the server such as receiving <code>HEADERS</code> or <code>DATA</code> frames that are part of the response, discussed in more details in the <a href="#pg-client-http2-response">section below</a>.
Please refer to the <code>Stream.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http2/api/Stream.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>HTTP requests may have content, which is sent using the <code>Stream</code> APIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8080</span>);
CompletableFuture&lt;Session&gt; sessionCF = http2Client.connect(serverAddress, <span class="keyword">new</span> Session.Listener() {});
Session session = sessionCF.get();

<span class="comment">// Configure the request headers.</span>
HttpFields requestHeaders = HttpFields.build()
    .put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The request metadata with method, URI and headers.</span>
MetaData.Request request = <span class="keyword">new</span> MetaData.Request(<span class="string"><span class="delimiter">&quot;</span><span class="content">POST</span><span class="delimiter">&quot;</span></span>, HttpURI.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8080/path</span><span class="delimiter">&quot;</span></span>), HttpVersion.HTTP_2, requestHeaders);

<span class="comment">// The HTTP/2 HEADERS frame, with endStream=false to</span>
<span class="comment">// signal that there will be more frames in this stream.</span>
HeadersFrame headersFrame = <span class="keyword">new</span> HeadersFrame(request, <span class="predefined-constant">null</span>, <span class="predefined-constant">false</span>);

<span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newStream(headersFrame, <span class="predefined-constant">null</span>);

<span class="comment">// Block to obtain the Stream.</span>
<span class="comment">// Alternatively you can use the CompletableFuture APIs to avoid blocking.</span>
Stream stream = streamCF.get();

<span class="comment">// The request content, in two chunks.</span>
<span class="predefined-type">String</span> content1 = <span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\&quot;</span><span class="content">greet</span><span class="char">\&quot;</span><span class="content">: </span><span class="char">\&quot;</span><span class="content">hello world</span><span class="char">\&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">ByteBuffer</span> buffer1 = StandardCharsets.UTF_8.encode(content1);
<span class="predefined-type">String</span> content2 = <span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\&quot;</span><span class="content">user</span><span class="char">\&quot;</span><span class="content">: </span><span class="char">\&quot;</span><span class="content">jetty</span><span class="char">\&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">ByteBuffer</span> buffer2 = StandardCharsets.UTF_8.encode(content2);

<span class="comment">// Send the first DATA frame on the stream, with endStream=false</span>
<span class="comment">// to signal that there are more frames in this stream.</span>
CompletableFuture&lt;Stream&gt; dataCF1 = stream.data(<span class="keyword">new</span> DataFrame(stream.getId(), buffer1, <span class="predefined-constant">false</span>));

<span class="comment">// Only when the first chunk has been sent we can send the second,</span>
<span class="comment">// with endStream=true to signal that there are no more frames.</span>
dataCF1.thenCompose(s -&gt; s.data(<span class="keyword">new</span> DataFrame(s.getId(), buffer2, <span class="predefined-constant">true</span>)));</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When sending two <code>DATA</code> frames consecutively, the second call to <code>Stream.data(...)</code> must be done only when the first is completed, or a <code>WritePendingException</code> will be thrown.
Use the <code>Callback</code> APIs or <code>CompletableFuture</code> APIs to ensure that the second <code>Stream.data(...)</code> call is performed when the first completed successfully.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-response"><a class="anchor" href="#pg-client-http2-response"></a><a class="link" href="#pg-client-http2-response">Receiving a Response</a></h4>
<div class="paragraph">
<p>Response events are delivered to the <code>Stream.Listener</code> passed to <code>Session.newStream(...)</code>.</p>
</div>
<div class="paragraph">
<p>An HTTP response is typically composed of a <code>HEADERS</code> frame containing the HTTP status code and the response headers, and optionally one or more <code>DATA</code> frames containing the response content bytes.</p>
</div>
<div class="paragraph">
<p>The HTTP/2 protocol also supports response trailers (that is, headers that are sent after the response content) that also are sent using a <code>HEADERS</code> frame.</p>
</div>
<div class="paragraph">
<p>A client application can therefore receive the HTTP/2 frames sent by the server by implementing the relevant methods in <code>Stream.Listener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
session.newStream(headersFrame, <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onHeaders(Stream stream, HeadersFrame frame)
    {
        MetaData metaData = frame.getMetaData();

        <span class="comment">// Is this HEADERS frame the response or the trailers?</span>
        <span class="keyword">if</span> (metaData.isResponse())
        {
            MetaData.Response response = (MetaData.Response)metaData;
            <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http2</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Received response {0}</span><span class="delimiter">&quot;</span></span>, response);
            <span class="keyword">if</span> (!frame.isEndStream())
            {
                <span class="comment">// Demand for DATA frames, so that onDataAvailable()</span>
                <span class="comment">// below will be called when they are available.</span>
                stream.demand();
            }
        }
        <span class="keyword">else</span>
        {
            <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http2</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Received trailers {0}</span><span class="delimiter">&quot;</span></span>, metaData.getHttpFields());
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
    {
        <span class="comment">// Read a Data object.</span>
        Stream.Data data = stream.readData();

        <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Demand more DATA frames.</span>
            stream.demand();
            <span class="keyword">return</span>;
        }

        <span class="comment">// Get the content buffer.</span>
        <span class="predefined-type">ByteBuffer</span> buffer = data.frame().getByteBuffer();

        <span class="comment">// Consume the buffer, here - as an example - just log it.</span>
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http2</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Consuming buffer {0}</span><span class="delimiter">&quot;</span></span>, buffer);

        <span class="comment">// Tell the implementation that the buffer has been consumed.</span>
        data.release();

        <span class="keyword">if</span> (!data.frame().isEndStream())
        {
            <span class="comment">// Demand more DATA frames when they are available.</span>
            stream.demand();
        }
    }
});</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>onDataAvailable(Stream stream)</code> is invoked, the demand is implicitly cancelled.</p>
</div>
<div class="paragraph">
<p>Just returning from the <code>onDataAvailable(Stream stream)</code> method does <em>not</em> implicitly demand for more <code>DATA</code> frames.</p>
</div>
<div class="paragraph">
<p>Applications must call <code>Stream.demand()</code> to explicitly require that <code>onDataAvailable(Stream stream)</code> is invoked again when more <code>DATA</code> frames are available.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications that consume the content buffer within <code>onDataAvailable(Stream stream)</code> (for example, writing it to a file, or copying the bytes to another storage) should call <code>Data.release()</code> as soon as they have consumed the content buffer.
This allows the implementation to reuse the buffer, reducing the memory requirements needed to handle the content buffers.</p>
</div>
<div class="paragraph">
<p>Alternatively, an application may store away the <code>Data</code> object to consume the buffer bytes later, or pass the <code>Data</code> object to another asynchronous API (this is typical in proxy applications).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The call to <code>Stream.readData()</code> tells the implementation to enlarge the stream and session flow control windows so that the sender will be able to send more <code>DATA</code> frames without stalling.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications can unwrap the <code>Data</code> object into some other object that may be used later, provided that the <em>release</em> semantic is maintained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">record Chunk(<span class="predefined-type">ByteBuffer</span> byteBuffer, <span class="predefined-type">Callback</span> callback)
{
}

<span class="comment">// A queue that consumers poll to consume content asynchronously.</span>
<span class="predefined-type">Queue</span>&lt;Chunk&gt; dataQueue = <span class="keyword">new</span> <span class="predefined-type">ConcurrentLinkedQueue</span>&lt;&gt;();

<span class="comment">// Implementation of Stream.Listener.onDataAvailable(Stream stream)</span>
<span class="comment">// in case of unwrapping of the Data object for asynchronous content</span>
<span class="comment">// consumption and demand.</span>
Stream.Listener listener = <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
    {
        Stream.Data data = stream.readData();

        <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
        {
            stream.demand();
            <span class="keyword">return</span>;
        }

        <span class="comment">// Get the content buffer.</span>
        <span class="predefined-type">ByteBuffer</span> byteBuffer = data.frame().getByteBuffer();

        <span class="comment">// Unwrap the Data object, converting it to a Chunk.</span>
        <span class="comment">// The Data.release() semantic is maintained in the completion of the Callback.</span>
        dataQueue.offer(<span class="keyword">new</span> Chunk(byteBuffer, <span class="predefined-type">Callback</span>.from(() -&gt;
        {
            <span class="comment">// When the buffer has been consumed, then:</span>
            <span class="comment">// A) release the Data object.</span>
            data.release();
            <span class="comment">// B) possibly demand more DATA frames.</span>
            <span class="keyword">if</span> (!data.frame().isEndStream())
                stream.demand();
        })));

        <span class="comment">// Do not demand more data here, to avoid to overflow the queue.</span>
    }
};</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Applications that implement <code>onDataAvailable(Stream stream)</code> must remember to call <code>Stream.demand()</code> eventually.</p>
</div>
<div class="paragraph">
<p>If they do not call <code>Stream.demand()</code>, the implementation will not invoke <code>onDataAvailable(Stream stream)</code> to deliver more <code>DATA</code> frames and the application will stall threadlessly until an idle timeout fires to close the stream or the session.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-reset"><a class="anchor" href="#pg-client-http2-reset"></a><a class="link" href="#pg-client-http2-reset">Resetting a Request or Response</a></h4>
<div class="paragraph">
<p>In HTTP/2, clients and servers have the ability to tell to the other peer that they are not interested anymore in either the request or the response, using a <code>RST_STREAM</code> frame.</p>
</div>
<div class="paragraph">
<p>The <code>HTTP2Client</code> APIs allow client applications to send and receive this "reset" frame:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newStream(headersFrame, <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onReset(Stream stream, ResetFrame frame, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// The server reset this stream.</span>

        <span class="comment">// Succeed the callback to signal that the reset event has been handled.</span>
        callback.succeeded();
    }
});
Stream stream = streamCF.get();

<span class="comment">// Reset this stream (for example, the user closed the application).</span>
stream.reset(<span class="keyword">new</span> ResetFrame(stream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), <span class="predefined-type">Callback</span>.NOOP);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http2-push"><a class="anchor" href="#pg-client-http2-push"></a><a class="link" href="#pg-client-http2-push">Receiving HTTP/2 Pushes</a></h4>
<div class="paragraph">
<p>HTTP/2 servers have the ability to push resources related to a primary resource.
When an HTTP/2 server pushes a resource, it sends to the client a <code>PUSH_PROMISE</code> frame that contains the request URI and headers that a client would use to request explicitly that resource.</p>
</div>
<div class="paragraph">
<p>Client applications can be configured to tell the server to never push resources, see <a href="#pg-client-http2-configure">this section</a>.</p>
</div>
<div class="paragraph">
<p>Client applications can listen to the push events, and act accordingly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newStream(headersFrame, <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onPush(Stream pushedStream, PushPromiseFrame frame)
    {
        <span class="comment">// The &quot;request&quot; the client would make for the pushed resource.</span>
        MetaData.Request pushedRequest = frame.getMetaData();
        <span class="comment">// The pushed &quot;request&quot; URI.</span>
        HttpURI pushedURI = pushedRequest.getHttpURI();
        <span class="comment">// The pushed &quot;request&quot; headers.</span>
        HttpFields pushedRequestHeaders = pushedRequest.getHttpFields();

        <span class="comment">// If needed, retrieve the primary stream that triggered the push.</span>
        Stream primaryStream = pushedStream.getSession().getStream(frame.getStreamId());

        <span class="comment">// Return a Stream.Listener to listen for the pushed &quot;response&quot; events.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onHeaders(Stream stream, HeadersFrame frame)
            {
                <span class="comment">// Handle the pushed stream &quot;response&quot;.</span>

                MetaData metaData = frame.getMetaData();
                <span class="keyword">if</span> (metaData.isResponse())
                {
                    <span class="comment">// The pushed &quot;response&quot; headers.</span>
                    HttpFields pushedResponseHeaders = metaData.getHttpFields();

                    <span class="comment">// Typically a pushed stream has data, so demand for data.</span>
                    stream.demand();
                }
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
            {
                <span class="comment">// Handle the pushed stream &quot;response&quot; content.</span>

                Stream.Data data = stream.readData();

                <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
                {
                    stream.demand();
                    <span class="keyword">return</span>;
                }

                <span class="comment">// The pushed stream &quot;response&quot; content bytes.</span>
                <span class="predefined-type">ByteBuffer</span> buffer = data.frame().getByteBuffer();
                <span class="comment">// Consume the buffer and release the Data object.</span>
                data.release();

                <span class="keyword">if</span> (!data.frame().isEndStream())
                {
                    <span class="comment">// Demand more DATA frames when they are available.</span>
                    stream.demand();
                }
            }
        };
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a client application does not want to handle a particular HTTP/2 push, it can just reset the pushed stream to tell the server to stop sending bytes for the pushed stream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newStream(headersFrame, <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onPush(Stream pushedStream, PushPromiseFrame frame)
    {
        <span class="comment">// Reset the pushed stream to tell the server you are not interested.</span>
        pushedStream.reset(<span class="keyword">new</span> ResetFrame(pushedStream.getId(), ErrorCode.CANCEL_STREAM_ERROR.code), <span class="predefined-type">Callback</span>.NOOP);

        <span class="comment">// Not interested in listening to pushed response events.</span>
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    }
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-client-http3"><a class="anchor" href="#pg-client-http3"></a><a class="link" href="#pg-client-http3">HTTP/3 Client Library</a></h3>
<div class="paragraph">
<p>In the vast majority of cases, client applications should use the generic, high-level, <a href="#pg-client-http">HTTP client library</a> that also provides HTTP/3 support via the pluggable <a href="#pg-client-http-transport-http3">HTTP/3 transport</a> or the <a href="#pg-client-http-transport-dynamic">dynamic transport</a>.</p>
</div>
<div class="paragraph">
<p>The high-level HTTP library supports cookies, authentication, redirection, connection pooling and a number of other features that are absent in the low-level HTTP/3 library.</p>
</div>
<div class="paragraph">
<p>The HTTP/3 client library has been designed for those applications that need low-level access to HTTP/3 features such as <em>sessions</em>, <em>streams</em> and <em>frames</em>, and this is quite a rare use case.</p>
</div>
<div class="paragraph">
<p>See also the correspondent <a href="#pg-server-http3">HTTP/3 server library</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-client-http3-intro"><a class="anchor" href="#pg-client-http3-intro"></a><a class="link" href="#pg-client-http3-intro">Introducing HTTP3Client</a></h4>
<div class="paragraph">
<p>The Maven artifact coordinates for the HTTP/3 client library are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.http3<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-http3-client<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main class is named <code>org.eclipse.jetty.http3.client.HTTP3Client</code>, and must be created, configured and started before use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Instantiate HTTP3Client.</span>
SslContextFactory.Client sslContextFactory = <span class="keyword">new</span> SslContextFactory.Client();
HTTP3Client http3Client = <span class="keyword">new</span> HTTP3Client(<span class="keyword">new</span> ClientQuicConfiguration(sslContextFactory, <span class="predefined-constant">null</span>));

<span class="comment">// Configure HTTP3Client, for example:</span>
http3Client.getHTTP3Configuration().setStreamIdleTimeout(<span class="integer">15000</span>);

<span class="comment">// Start HTTP3Client.</span>
http3Client.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When your application stops, or otherwise does not need <code>HTTP3Client</code> anymore, it should stop the <code>HTTP3Client</code> instance (or instances) that were started:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Stop HTTP3Client.</span>
http3Client.stop();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HTTP3Client</code> allows client applications to connect to an HTTP/3 server.
A <em>session</em> represents a single connection to an HTTP/3 server and is defined by class <code>org.eclipse.jetty.http3.api.Session</code>.
A <em>session</em> typically has a long life&#8201;&#8212;&#8201;once the connection is established, it remains active until it is not used anymore (and therefore it is closed by the idle timeout mechanism), until a fatal error occurs (for example, a network failure), or if one of the peers decides unilaterally to close the connection.</p>
</div>
<div class="paragraph">
<p>HTTP/3 is a multiplexed protocol because it relies on the multiplexing capabilities of QUIC, the protocol based on UDP that transports HTTP/3 frames.
Thanks to multiplexing, multiple HTTP/3 requests are sent on the same QUIC connection, or <em>session</em>.
Each request/response cycle is represented by a <em>stream</em>.
Therefore, a single <em>session</em> manages multiple concurrent <em>streams</em>.
A <em>stream</em> has typically a very short life compared to the <em>session</em>: a <em>stream</em> only exists for the duration of the request/response cycle and then disappears.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http3-connect"><a class="anchor" href="#pg-client-http3-connect"></a><a class="link" href="#pg-client-http3-connect">Connecting to the Server</a></h4>
<div class="paragraph">
<p>The first thing an application should do is to connect to the server and obtain a <code>Session</code>.
The following example connects to the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Address of the server's port.</span>
<span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8444</span>);

<span class="comment">// Connect to the server, the CompletableFuture will be</span>
<span class="comment">// notified when the connection is succeeded (or failed).</span>
CompletableFuture&lt;Session.Client&gt; sessionCF = http3Client.connect(serverAddress, <span class="keyword">new</span> Session.Client.Listener() {});

<span class="comment">// Block to obtain the Session.</span>
<span class="comment">// Alternatively you can use the CompletableFuture APIs to avoid blocking.</span>
Session session = sessionCF.get();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http3-configure"><a class="anchor" href="#pg-client-http3-configure"></a><a class="link" href="#pg-client-http3-configure">Configuring the Session</a></h4>
<div class="paragraph">
<p>The <code>connect(...)</code> method takes a <code>Session.Client.Listener</code> parameter.
This listener&#8217;s <code>onPreface(...)</code> method is invoked just before establishing the connection to the server to gather the client configuration to send to the server.
Client applications can override this method to change the default configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8444</span>);
http3Client.connect(serverAddress, <span class="keyword">new</span> Session.Client.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Long</span>&gt; onPreface(Session session)
    {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Long</span>&gt; configuration = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

        <span class="comment">// Add here configuration settings.</span>

        <span class="keyword">return</span> configuration;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Session.Client.Listener</code> is notified of session events originated by the server such as receiving a <code>SETTINGS</code> frame from the server, or the server closing the connection, or the client timing out the connection due to idleness.
Please refer to the <code>Session.Client.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http3/api/Session.Client.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>Once a <code>Session</code> has been established, the communication with the server happens by exchanging <em>frames</em>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http3-request"><a class="anchor" href="#pg-client-http3-request"></a><a class="link" href="#pg-client-http3-request">Sending a Request</a></h4>
<div class="paragraph">
<p>Sending an HTTP request to the server, and receiving a response, creates a <em>stream</em> that encapsulates the exchange of HTTP/3 frames that compose the request and the response.</p>
</div>
<div class="paragraph">
<p>In order to send an HTTP request to the server, the client must send a <code>HEADERS</code> frame.
<code>HEADERS</code> frames carry the request method, the request URI and the request headers.
Sending the <code>HEADERS</code> frame opens the <code>Stream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8444</span>);
CompletableFuture&lt;Session.Client&gt; sessionCF = http3Client.connect(serverAddress, <span class="keyword">new</span> Session.Client.Listener() {});
Session.Client session = sessionCF.get();

<span class="comment">// Configure the request headers.</span>
HttpFields requestHeaders = HttpFields.build()
    .put(HttpHeader.USER_AGENT, <span class="string"><span class="delimiter">&quot;</span><span class="content">Jetty HTTP3Client 12.0.10-SNAPSHOT</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The request metadata with method, URI and headers.</span>
MetaData.Request request = <span class="keyword">new</span> MetaData.Request(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, HttpURI.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8444/path</span><span class="delimiter">&quot;</span></span>), HttpVersion.HTTP_3, requestHeaders);

<span class="comment">// The HTTP/3 HEADERS frame, with endStream=true</span>
<span class="comment">// to signal that this request has no content.</span>
HeadersFrame headersFrame = <span class="keyword">new</span> HeadersFrame(request, <span class="predefined-constant">true</span>);

<span class="comment">// Open a Stream by sending the HEADERS frame.</span>
session.newRequest(headersFrame, <span class="keyword">new</span> Stream.Client.Listener() {});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how <code>Session.newRequest(...)</code> takes a <code>Stream.Client.Listener</code> parameter.
This listener is notified of stream events originated by the server such as receiving <code>HEADERS</code> or <code>DATA</code> frames that are part of the response, discussed in more details in the <a href="#pg-client-http3-response">section below</a>.
Please refer to the <code>Stream.Client.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http3/api/Stream.Client.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>HTTP requests may have content, which is sent using the <code>Stream</code> APIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">SocketAddress</span> serverAddress = <span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8444</span>);
CompletableFuture&lt;Session.Client&gt; sessionCF = http3Client.connect(serverAddress, <span class="keyword">new</span> Session.Client.Listener() {});
Session.Client session = sessionCF.get();

<span class="comment">// Configure the request headers.</span>
HttpFields requestHeaders = HttpFields.build()
    .put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The request metadata with method, URI and headers.</span>
MetaData.Request request = <span class="keyword">new</span> MetaData.Request(<span class="string"><span class="delimiter">&quot;</span><span class="content">POST</span><span class="delimiter">&quot;</span></span>, HttpURI.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost:8444/path</span><span class="delimiter">&quot;</span></span>), HttpVersion.HTTP_3, requestHeaders);

<span class="comment">// The HTTP/3 HEADERS frame, with endStream=false to</span>
<span class="comment">// signal that there will be more frames in this stream.</span>
HeadersFrame headersFrame = <span class="keyword">new</span> HeadersFrame(request, <span class="predefined-constant">false</span>);

<span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newRequest(headersFrame, <span class="keyword">new</span> Stream.Client.Listener() {});

<span class="comment">// Block to obtain the Stream.</span>
<span class="comment">// Alternatively you can use the CompletableFuture APIs to avoid blocking.</span>
Stream stream = streamCF.get();

<span class="comment">// The request content, in two chunks.</span>
<span class="predefined-type">String</span> content1 = <span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\&quot;</span><span class="content">greet</span><span class="char">\&quot;</span><span class="content">: </span><span class="char">\&quot;</span><span class="content">hello world</span><span class="char">\&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">ByteBuffer</span> buffer1 = StandardCharsets.UTF_8.encode(content1);
<span class="predefined-type">String</span> content2 = <span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\&quot;</span><span class="content">user</span><span class="char">\&quot;</span><span class="content">: </span><span class="char">\&quot;</span><span class="content">jetty</span><span class="char">\&quot;</span><span class="content">}</span><span class="delimiter">&quot;</span></span>;
<span class="predefined-type">ByteBuffer</span> buffer2 = StandardCharsets.UTF_8.encode(content2);

<span class="comment">// Send the first DATA frame on the stream, with endStream=false</span>
<span class="comment">// to signal that there are more frames in this stream.</span>
CompletableFuture&lt;Stream&gt; dataCF1 = stream.data(<span class="keyword">new</span> DataFrame(buffer1, <span class="predefined-constant">false</span>));

<span class="comment">// Only when the first chunk has been sent we can send the second,</span>
<span class="comment">// with endStream=true to signal that there are no more frames.</span>
dataCF1.thenCompose(s -&gt; s.data(<span class="keyword">new</span> DataFrame(buffer2, <span class="predefined-constant">true</span>)));</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When sending two <code>DATA</code> frames consecutively, the second call to <code>Stream.data(...)</code> must be done only when the first is completed, or a <code>WritePendingException</code> will be thrown.
Use the <code>CompletableFuture</code> APIs to ensure that the second <code>Stream.data(...)</code> call is performed when the first completed successfully.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http3-response"><a class="anchor" href="#pg-client-http3-response"></a><a class="link" href="#pg-client-http3-response">Receiving a Response</a></h4>
<div class="paragraph">
<p>Response events are delivered to the <code>Stream.Client.Listener</code> passed to <code>Session.newRequest(...)</code>.</p>
</div>
<div class="paragraph">
<p>An HTTP response is typically composed of a <code>HEADERS</code> frame containing the HTTP status code and the response headers, and optionally one or more <code>DATA</code> frames containing the response content bytes.</p>
</div>
<div class="paragraph">
<p>The HTTP/3 protocol also supports response trailers (that is, headers that are sent after the response content) that also are sent using a <code>HEADERS</code> frame.</p>
</div>
<div class="paragraph">
<p>A client application can therefore receive the HTTP/3 frames sent by the server by implementing the relevant methods in <code>Stream.Client.Listener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
session.newRequest(headersFrame, <span class="keyword">new</span> Stream.Client.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onResponse(Stream.Client stream, HeadersFrame frame)
    {
        MetaData metaData = frame.getMetaData();
        MetaData.Response response = (MetaData.Response)metaData;
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http3</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Received response {0}</span><span class="delimiter">&quot;</span></span>, response);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream.Client stream)
    {
        <span class="comment">// Read a chunk of the content.</span>
        Stream.Data data = stream.readData();
        <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// No data available now, demand to be called back.</span>
            stream.demand();
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Process the content.</span>
            process(data.getByteBuffer());

            <span class="comment">// Notify the implementation that the content has been consumed.</span>
            data.release();

            <span class="keyword">if</span> (!data.isLast())
            {
                <span class="comment">// Demand to be called back.</span>
                stream.demand();
            }
        }
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-http3-reset"><a class="anchor" href="#pg-client-http3-reset"></a><a class="link" href="#pg-client-http3-reset">Resetting a Request or Response</a></h4>
<div class="paragraph">
<p>In HTTP/3, clients and servers have the ability to tell to the other peer that they are not interested anymore in either the request or the response, by resetting the stream.</p>
</div>
<div class="paragraph">
<p>The <code>HTTP3Client</code> APIs allow client applications to send and receive this "reset" event:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Open a Stream by sending the HEADERS frame.</span>
CompletableFuture&lt;Stream&gt; streamCF = session.newRequest(headersFrame, <span class="keyword">new</span> Stream.Client.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFailure(Stream.Client stream, <span class="type">long</span> error, <span class="predefined-type">Throwable</span> failure)
    {
        <span class="comment">// The server reset this stream.</span>
    }
});
Stream stream = streamCF.get();

<span class="comment">// Reset this stream (for example, the user closed the application).</span>
stream.reset(HTTP3ErrorCode.REQUEST_CANCELLED_ERROR.code(), <span class="keyword">new</span> <span class="exception">ClosedChannelException</span>());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-client-websocket"><a class="anchor" href="#pg-client-websocket"></a><a class="link" href="#pg-client-websocket">WebSocket Client</a></h3>
<div class="paragraph">
<p>Jetty&#8217;s <code>WebSocketClient</code> is a more powerful alternative to the WebSocket client provided by the standard JSR 356 <code>javax.websocket</code> APIs.</p>
</div>
<div class="paragraph">
<p>Similarly to Jetty&#8217;s <a href="#pg-client-http"><code>HttpClient</code></a>, the <code>WebSocketClient</code> is non-blocking and asynchronous, making it very efficient in resource utilization.
A synchronous, blocking, API is also offered for simpler cases.</p>
</div>
<div class="paragraph">
<p>Since the first step of establishing a WebSocket communication is an HTTP request, <code>WebSocketClient</code> makes use of <code>HttpClient</code> and therefore depends on it.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-websocket-jetty-client<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-websocket-start"><a class="anchor" href="#pg-client-websocket-start"></a><a class="link" href="#pg-client-websocket-start">Starting WebSocketClient</a></h4>
<div class="paragraph">
<p>The main class is <code>org.eclipse.jetty.websocket.client.WebSocketClient</code>; you instantiate it, configure it, and then start it like many other Jetty components.
This is a minimal example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Instantiate WebSocketClient.</span>
WebSocketClient webSocketClient = <span class="keyword">new</span> WebSocketClient();

<span class="comment">// Configure WebSocketClient, for example:</span>
webSocketClient.setMaxTextMessageSize(<span class="integer">8</span> * <span class="integer">1024</span>);

<span class="comment">// Start WebSocketClient.</span>
webSocketClient.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, it is recommended that you explicitly pass an <code>HttpClient</code> instance to <code>WebSocketClient</code> so that you can have control over the HTTP configuration as well:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Instantiate and configure HttpClient.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient();
<span class="comment">// For example, configure a proxy.</span>
httpClient.getProxyConfiguration().addProxy(<span class="keyword">new</span> HttpProxy(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">8888</span>));

<span class="comment">// Instantiate WebSocketClient, passing HttpClient to the constructor.</span>
WebSocketClient webSocketClient = <span class="keyword">new</span> WebSocketClient(httpClient);
<span class="comment">// Configure WebSocketClient, for example:</span>
webSocketClient.setMaxTextMessageSize(<span class="integer">8</span> * <span class="integer">1024</span>);

<span class="comment">// Start WebSocketClient; this implicitly starts also HttpClient.</span>
webSocketClient.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may create multiple instances of <code>WebSocketClient</code>, but typically one instance is enough for most applications.
Creating multiple instances may be necessary for example when you need to specify different configuration parameters for different instances.
For example, you may need different instances when you need to configure the <code>HttpClient</code> differently: different transports, different proxies, different cookie stores, different authentications, etc.</p>
</div>
<div class="paragraph">
<p>The configuration that is not WebSocket specific (such as idle timeout, etc.) should be directly configured on the associated <code>HttpClient</code> instance.</p>
</div>
<div class="paragraph">
<p>The WebSocket specific configuration can be configured directly on the <code>WebSocketClient</code> instance.
Configuring the <code>WebSocketClient</code> allows to give default values to various parameters, whose values may be overridden more specifically, as described in <a href="#pg-websocket-session-configure">this section</a>.</p>
</div>
<div class="paragraph">
<p>Refer to the  <code>WebSocketClient</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/websocket/client/WebSocketClient.html">javadocs</a> for the setter methods available to customize the WebSocket specific configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-websocket-stop"><a class="anchor" href="#pg-client-websocket-stop"></a><a class="link" href="#pg-client-websocket-stop">Stopping WebSocketClient</a></h4>
<div class="paragraph">
<p>It is recommended that when your application stops, you also stop the <code>WebSocketClient</code> instance (or instances) that you are using.</p>
</div>
<div class="paragraph">
<p>Similarly to <a href="#pg-client-http-stop">stopping <code>HttpClient</code></a>, you want to stop <code>WebSocketClient</code> from a thread that is not owned by <code>WebSocketClient</code> itself, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Stop WebSocketClient.</span>
<span class="comment">// Use LifeCycle.stop(...) to rethrow checked exceptions as unchecked.</span>
<span class="keyword">new</span> <span class="predefined-type">Thread</span>(() -&gt; LifeCycle.stop(webSocketClient)).start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-client-websocket-connect"><a class="anchor" href="#pg-client-websocket-connect"></a><a class="link" href="#pg-client-websocket-connect">Connecting to a Remote Host</a></h4>
<div class="paragraph">
<p>A WebSocket client may initiate the communication with the server either <a href="#pg-client-websocket-connect-http11">using HTTP/1.1</a> or <a href="#pg-client-websocket-connect-http2">using HTTP/2</a>.
The two mechanism are quite different and detailed in the following sections.</p>
</div>
<div class="sect4">
<h5 id="pg-client-websocket-connect-http11"><a class="anchor" href="#pg-client-websocket-connect-http11"></a><a class="link" href="#pg-client-websocket-connect-http11">Using HTTP/1.1</a></h5>
<div class="paragraph">
<p>Initiating a WebSocket communication with a server using HTTP/1.1 is detailed in <a href="https://tools.ietf.org/html/rfc6455#section-1.8">RFC 6455</a>.</p>
</div>
<div class="paragraph">
<p>A WebSocket client first establishes a TCP connection to the server, then sends an HTTP/1.1 <em>upgrade</em> request.</p>
</div>
<div class="paragraph">
<p>If the server supports upgrading to WebSocket, it responds with HTTP status code <code>101</code>, and then switches the communication over that connection, either incoming or outgoing, to happen using the WebSocket protocol.</p>
</div>
<div class="paragraph">
<p>When the client receives the HTTP status code <code>101</code>, it switches the communication over that connection, either incoming or outgoing, to happen using the WebSocket protocol.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-fada5fbf7628dc70c998680727a069bd.png" alt="Diagram" width="704" height="508">
</div>
</div>
<div class="paragraph">
<p>In code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Use a standard, HTTP/1.1, HttpClient.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient();

<span class="comment">// Create and start WebSocketClient.</span>
WebSocketClient webSocketClient = <span class="keyword">new</span> WebSocketClient(httpClient);
webSocketClient.start();

<span class="comment">// The client-side WebSocket EndPoint that</span>
<span class="comment">// receives WebSocket messages from the server.</span>
ClientEndPoint clientEndPoint = <span class="keyword">new</span> ClientEndPoint();
<span class="comment">// The server URI to connect to.</span>
<span class="predefined-type">URI</span> serverURI = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Connect the client EndPoint to the server.</span>
CompletableFuture&lt;Session&gt; clientSessionPromise = webSocketClient.connect(clientEndPoint, serverURI);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WebSocketClient.connect()</code> links the client-side WebSocket <em>endpoint</em> to a specific server URI, and returns a <code>CompletableFuture</code> of an <code>org.eclipse.jetty.websocket.api.Session</code>.</p>
</div>
<div class="paragraph">
<p>The endpoint offers APIs to <em>receive</em> WebSocket data (or errors) from the server, while the session offers APIs to <em>send</em> WebSocket data to the server.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-websocket-connect-http2"><a class="anchor" href="#pg-client-websocket-connect-http2"></a><a class="link" href="#pg-client-websocket-connect-http2">Using HTTP/2</a></h5>
<div class="paragraph">
<p>Initiating a WebSocket communication with a server using HTTP/1.1 is detailed in <a href="https://tools.ietf.org/html/rfc8441">RFC 8441</a>.</p>
</div>
<div class="paragraph">
<p>A WebSocket client establishes a TCP connection to the server or reuses an existing one currently used for HTTP/2, then sends an HTTP/2 <em>CONNECT</em> request over an HTTP/2 stream.</p>
</div>
<div class="paragraph">
<p>If the server supports upgrading to WebSocket, it responds with HTTP status code <code>200</code>, then switches the communication over that stream, either incoming or outgoing, to happen using HTTP/2 <code>DATA</code> frames wrapping WebSocket frames.</p>
</div>
<div class="paragraph">
<p>When the client receives the HTTP status code <code>200</code>, it switches the communication over that stream, either incoming or outgoing, to happen using HTTP/2 <code>DATA</code> frames wrapping WebSocket frames.</p>
</div>
<div class="paragraph">
<p>From an external point of view, it will look like client is sending chunks of an infinite HTTP/2 request upload, and the server is sending chunks of an infinite HTTP/2 response download, as they will exchange HTTP/2 <code>DATA</code> frames; but the HTTP/2 <code>DATA</code> frames will contain each one or more WebSocket frames that both client and server know how to deliver to the respective WebSocket endpoints.</p>
</div>
<div class="paragraph">
<p>When either WebSocket endpoint decides to terminate the communication, the HTTP/2 stream will be closed as well.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-1ed737fca2f0d63f7ebac20672a2e222.png" alt="Diagram" width="686" height="569">
</div>
</div>
<div class="paragraph">
<p>In code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Use the HTTP/2 transport for HttpClient.</span>
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client();
HttpClient httpClient = <span class="keyword">new</span> HttpClient(<span class="keyword">new</span> HttpClientTransportOverHTTP2(http2Client));

<span class="comment">// Create and start WebSocketClient.</span>
WebSocketClient webSocketClient = <span class="keyword">new</span> WebSocketClient(httpClient);
webSocketClient.start();

<span class="comment">// The client-side WebSocket EndPoint that</span>
<span class="comment">// receives WebSocket messages from the server.</span>
ClientEndPoint clientEndPoint = <span class="keyword">new</span> ClientEndPoint();
<span class="comment">// The server URI to connect to.</span>
<span class="predefined-type">URI</span> serverURI = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">wss://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Connect the client EndPoint to the server.</span>
CompletableFuture&lt;Session&gt; clientSessionPromise = webSocketClient.connect(clientEndPoint, serverURI);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use the <a href="#pg-client-http-transport-dynamic">dynamic <code>HttpClient</code> transport</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Use the dynamic HTTP/2 transport for HttpClient.</span>
ClientConnector clientConnector = <span class="keyword">new</span> ClientConnector();
HTTP2Client http2Client = <span class="keyword">new</span> HTTP2Client(clientConnector);
HttpClient httpClient = <span class="keyword">new</span> HttpClient(<span class="keyword">new</span> HttpClientTransportDynamic(clientConnector, <span class="keyword">new</span> ClientConnectionFactoryOverHTTP2.HTTP2(http2Client)));

<span class="comment">// Create and start WebSocketClient.</span>
WebSocketClient webSocketClient = <span class="keyword">new</span> WebSocketClient(httpClient);
webSocketClient.start();

ClientEndPoint clientEndPoint = <span class="keyword">new</span> ClientEndPoint();
<span class="predefined-type">URI</span> serverURI = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">wss://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Connect the client EndPoint to the server.</span>
CompletableFuture&lt;Session&gt; clientSessionPromise = webSocketClient.connect(clientEndPoint, serverURI);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-websocket-connect-custom-http-request"><a class="anchor" href="#pg-client-websocket-connect-custom-http-request"></a><a class="link" href="#pg-client-websocket-connect-custom-http-request">Customizing the Initial HTTP Request</a></h5>
<div class="paragraph">
<p>Sometimes you need to add custom cookies, or other HTTP headers, or specify a WebSocket sub-protocol to the HTTP request that initiates the WebSocket communication.</p>
</div>
<div class="paragraph">
<p>You can do this by using overloaded versions of the <code>WebSocketClient.connect(&#8230;&#8203;)</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientEndPoint clientEndPoint = <span class="keyword">new</span> ClientEndPoint();
<span class="predefined-type">URI</span> serverURI = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create a custom HTTP request.</span>
ClientUpgradeRequest customRequest = <span class="keyword">new</span> ClientUpgradeRequest();
<span class="comment">// Specify a cookie.</span>
customRequest.getCookies().add(<span class="keyword">new</span> HttpCookie(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Specify a custom header.</span>
customRequest.setHeader(<span class="string"><span class="delimiter">&quot;</span><span class="content">X-Token</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">0123456789ABCDEF</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Specify a custom sub-protocol.</span>
customRequest.setSubProtocols(<span class="string"><span class="delimiter">&quot;</span><span class="content">chat</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Connect the client EndPoint to the server with a custom HTTP request.</span>
CompletableFuture&lt;Session&gt; clientSessionPromise = webSocketClient.connect(clientEndPoint, serverURI, customRequest);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-client-websocket-connect-inspect-http-response"><a class="anchor" href="#pg-client-websocket-connect-inspect-http-response"></a><a class="link" href="#pg-client-websocket-connect-inspect-http-response">Inspecting the Initial HTTP Response</a></h5>
<div class="paragraph">
<p>If you want to inspect the HTTP response returned by the server as a reply to the  HTTP request that initiates the WebSocket communication, you may provide a <code>JettyUpgradeListener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ClientEndPoint clientEndPoint = <span class="keyword">new</span> ClientEndPoint();
<span class="predefined-type">URI</span> serverURI = <span class="predefined-type">URI</span>.create(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws://domain.com/path</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The listener to inspect the HTTP response.</span>
JettyUpgradeListener listener = <span class="keyword">new</span> JettyUpgradeListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onHandshakeResponse(Request request, Response response)
    {
        <span class="comment">// Inspect the HTTP response here.</span>
    }
};

<span class="comment">// Connect the client EndPoint to the server with a custom HTTP request.</span>
CompletableFuture&lt;Session&gt; clientSessionPromise = webSocketClient.connect(clientEndPoint, serverURI, <span class="predefined-constant">null</span>, listener);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-websocket-architecture"><a class="anchor" href="#pg-websocket-architecture"></a><a class="link" href="#pg-websocket-architecture">Jetty WebSocket Architecture</a></h4>
<div class="paragraph">
<p>The Jetty WebSocket architecture is organized around the concept of a logical <em>connection</em> between the client and the server.</p>
</div>
<div class="paragraph">
<p>The connection may be physical, when connecting to the server using HTTP/1.1, as the WebSocket bytes are carried directly by the TCP connection.</p>
</div>
<div class="paragraph">
<p>The connection may be virtual, when connecting to the server using HTTP/2, as the WebSocket bytes are wrapped into HTTP/2 <code>DATA</code> frames of an HTTP/2 stream.
In this case, a single TCP connection may carry several WebSocket virtual connections, each wrapped in its own HTTP/2 stream.</p>
</div>
<div class="paragraph">
<p>Each side of a WebSocket connection, either client or server, is made of two entities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <a href="#pg-websocket-endpoints">WebSocket <em>endpoint</em></a>, the entity that <em>receives</em> WebSocket events.</p>
</li>
<li>
<p>A <a href="#pg-websocket-session">WebSocket <em>session</em></a>, the entity that offers an API to <em>send</em> WebSocket data (and to close the WebSocket connection), as well as to configure WebSocket connection parameters.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="pg-websocket-endpoints"><a class="anchor" href="#pg-websocket-endpoints"></a><a class="link" href="#pg-websocket-endpoints">WebSocket Endpoints</a></h4>
<div class="paragraph">
<p>A WebSocket endpoint is the entity that receives WebSocket events.</p>
</div>
<div class="paragraph">
<p>The WebSocket events are the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>open</em> event.
This event is emitted when the WebSocket communication has been successfully established.
Applications interested in the open event receive the WebSocket <em>session</em> so that they can use it to send data to the remote peer.</p>
</li>
<li>
<p>The <em>close</em> event.
This event is emitted when the WebSocket communication has been closed.
Applications interested in the close event receive a WebSocket status code and an optional close reason message.</p>
</li>
<li>
<p>The <em>error</em> event.
This event is emitted when the WebSocket communication encounters a fatal error, such as an I/O error (for example, the network connection has been broken), or a protocol error (for example, the remote peer sends an invalid WebSocket frame).
Applications interested in the error event receive a <code>Throwable</code> that represent the error.</p>
</li>
<li>
<p>The <em>frame</em> events.
The frame events are emitted when a WebSocket frame is received, either a control frame such as PING, PONG or CLOSE, or a data frame such as BINARY or TEXT.
One or more data frames of the same type define a <em>message</em>.</p>
</li>
<li>
<p>The <em>message</em> events.
The message event are emitted when a WebSocket message is received.
The message event can be of two types:</p>
<div class="ulist">
<ul>
<li>
<p>TEXT.
Applications interested in this type of messages receive a <code>String</code> representing the UTF-8 bytes received.</p>
</li>
<li>
<p>BINARY.
Applications interested in this type of messages receive a <code>ByteBuffer</code> representing the raw bytes received.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#pg-websocket-endpoints-listener">Listener endpoints</a> are notified of events by invoking the correspondent method defined by the <code>org.eclipse.jetty.websocket.api.Session.Listener</code> interface.</p>
</div>
<div class="paragraph">
<p><a href="#pg-websocket-endpoints-annotated">Annotated endpoints</a> are notified of events by invoking the correspondent method annotated with the correspondent annotation from the <code>org.eclipse.jetty.websocket.api.annotations.*</code> package.</p>
</div>
<div class="paragraph">
<p>Jetty uses <code>MethodHandle</code>s to instantiate WebSocket endpoints and invoke WebSocket event methods, so WebSocket endpoint classes and WebSocket event methods must be <code>public</code>.</p>
</div>
<div class="paragraph">
<p>When using JPMS, your classes must be <code>public</code> and must be exported using the <code>exports</code> directive in your <code>module-info.java</code>.
It is not recommended to use the <code>opens</code> directive in your <code>module-info.java</code> for your classes, as it would expose your classes to deep reflection, which is unnecessary, as the <code>exports</code> directive is sufficient.</p>
</div>
<div class="paragraph">
<p>This guarantees that WebSocket endpoints can be accessed by the Jetty implementation without additional configuration, no matter whether you are using only the class-path, or the module-path.</p>
</div>
<div class="paragraph">
<p>For both types of WebSocket endpoints, only one thread at a time will be delivering frame or message events to the corresponding methods; the next frame or message event will not be delivered until the previous call to the corresponding method has exited, and if there is <a href="#pg-websocket-endpoints-demand">demand</a> for it.
Endpoints will always be notified of message events in the same order they were received over the network.</p>
</div>
<div class="sect4">
<h5 id="pg-websocket-endpoints-demand"><a class="anchor" href="#pg-websocket-endpoints-demand"></a><a class="link" href="#pg-websocket-endpoints-demand">WebSocket Events Demand</a></h5>
<div class="paragraph">
<p>In order to receive WebSocket events, you must <em>demand</em> for them; the only exception is the <em>open</em> event, because it is the initial event that applications can interact with.</p>
</div>
<div class="paragraph">
<p>When a WebSocket event is received by an endpoint, the demand for WebSocket events (for that endpoint) is reset, so that no more WebSocket events will be received by the endpoint.
It is responsibility of the endpoint to demand to receive more WebSocket events.</p>
</div>
<div class="paragraph">
<p>For simple cases, you can just annotate your WebSocket endpoint with <code>@WebSocket(autoDemand = true)</code>, or implement <code>Session.Listener.AutoDemanding</code>.
In these two cases, when a method that receives a WebSocket event returns, the Jetty implementation automatically demands for another WebSocket event.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Attribute autoDemand is true by default.</span>
<span class="annotation">@WebSocket</span>(autoDemand = <span class="predefined-constant">true</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">AutoDemandAnnotatedEndPoint</span>
{
    <span class="annotation">@OnWebSocketOpen</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen(Session session)
    {
        <span class="comment">// No need to demand here, because this endpoint is auto-demanding.</span>
    }

    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onText(<span class="predefined-type">String</span> message)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws.message</span><span class="delimiter">&quot;</span></span>).log(INFO, message);
        <span class="comment">// No need to demand here, because this endpoint is auto-demanding.</span>
    }
}

<span class="directive">public</span> <span class="type">class</span> <span class="class">AutoDemandListenerEndPoint</span> <span class="directive">implements</span> Session.Listener.AutoDemanding
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="local-variable">this</span>.session = session;
        <span class="comment">// No need to demand here, because this endpoint is auto-demanding.</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketText(<span class="predefined-type">String</span> message)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">ws.message</span><span class="delimiter">&quot;</span></span>).log(INFO, message);
        <span class="comment">// No need to demand here, because this endpoint is auto-demanding.</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While auto-demand works for simple cases, it may not work in all cases, especially those where the method that receives the WebSocket event performs asynchronous operations.</p>
</div>
<div class="paragraph">
<p>The following example shows the problem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">WrongAutoDemandListenerEndPoint</span> <span class="directive">implements</span> Session.Listener.AutoDemanding
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="local-variable">this</span>.session = session;
        <span class="comment">// No need to demand here, because this endpoint is auto-demanding.</span>
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketText(<span class="predefined-type">String</span> message)
    {
        <span class="comment">// Perform an asynchronous operation, such as invoking</span>
        <span class="comment">// a third party service or just echoing the message back.</span>
        session.sendText(message, <span class="predefined-type">Callback</span>.NOOP);

        <span class="comment">// Returning from this method will automatically demand,</span>
        <span class="comment">// so this method may be entered again before sendText()</span>
        <span class="comment">// has been completed, causing a WritePendingException.</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how, in the example above, auto-demanding has the problem that receiving WebSocket text messages may happen faster than echoing them back, because the call to <code>sendText(...)</code> may return almost immediately but be slow to complete because it is asynchronous.</p>
</div>
<div class="paragraph">
<p>In the example above, if another WebSocket text message arrives, and the <code>sendText(...)</code> operation is not complete, a <code>WritePendingException</code> will be thrown.</p>
</div>
<div class="paragraph">
<p>In other cases, this may lead to infinite buffering of data, eventually causing <code>OutOfMemoryError</code>s, and in general excessive resource consumption that may be difficult to diagnose and troubleshoot.</p>
</div>
<div class="paragraph">
<p>For more information, see also the <a href="#pg-websocket-session-send">section about sending data</a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Always be careful when using auto-demand.</p>
</div>
<div class="paragraph">
<p>Analyze the operations that your endpoint performs and make sure they complete synchronously within the method.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To solve the problem outlined above, you must explicitly demand for the next WebSocket event, only when the processing of the previous events is complete.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExplicitDemandListenerEndPoint</span> <span class="directive">implements</span> Session.Listener
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="local-variable">this</span>.session = session;

        <span class="comment">// Explicitly demand here, otherwise no other event is received.</span>
        session.demand();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketText(<span class="predefined-type">String</span> message)
    {
        <span class="comment">// Perform an asynchronous operation, such as invoking</span>
        <span class="comment">// a third party service or just echoing the message back.</span>

        <span class="comment">// We want to demand only when sendText() has completed,</span>
        <span class="comment">// which is notified to the callback passed to sendText().</span>
        session.sendText(message, <span class="predefined-type">Callback</span>.from(session::demand, failure -&gt;
        {
            <span class="comment">// Handle the failure, in this case just closing the session.</span>
            session.close(StatusCode.SERVER_ERROR, <span class="string"><span class="delimiter">&quot;</span><span class="content">failure</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.NOOP);
        }));

        <span class="comment">// Return from the method without demanding yet,</span>
        <span class="comment">// waiting for the completion of sendText() to demand.</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how it is necessary to invoke <code>Session.demand()</code> from the <em>open</em> event, in order to receive <em>message</em> events.</p>
</div>
<div class="paragraph">
<p>Furthermore, note how every time a text message is received, a possibly slow asynchronous operation is initiated (which returns almost immediately, although it may not be completed yet) and then the method returns.</p>
</div>
<div class="paragraph">
<p>Because there is no demand when the method returns (because the asynchronous operation is not completed yet), the implementation will not notify any other WebSocket event (not even <em>frame</em>, <em>close</em> or <em>error</em> events).</p>
</div>
<div class="paragraph">
<p>When the asynchronous operation completes successfully the callback is notified; this, in turn, invokes <code>Session.demand()</code>, and the implementation may notify another WebSocket event (if any) to the WebSocket endpoint.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket-endpoints-listener"><a class="anchor" href="#pg-websocket-endpoints-listener"></a><a class="link" href="#pg-websocket-endpoints-listener">Listener Endpoints</a></h5>
<div class="paragraph">
<p>A WebSocket endpoint may implement the <code>org.eclipse.jetty.websocket.api.Session.Listener</code> interface to receive WebSocket events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ListenerEndPoint</span> <span class="directive">implements</span> Session.Listener
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="comment">// The WebSocket endpoint has been opened.</span>

        <span class="comment">// Store the session to be able to send data to the remote peer.</span>
        <span class="local-variable">this</span>.session = session;

        <span class="comment">// You may configure the session.</span>
        session.setMaxTextMessageSize(<span class="integer">16</span> * <span class="integer">1024</span>);

        <span class="comment">// You may immediately send a message to the remote peer.</span>
        session.sendText(<span class="string"><span class="delimiter">&quot;</span><span class="content">connected</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.from(session::demand, <span class="predefined-type">Throwable</span>::printStackTrace));
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketText(<span class="predefined-type">String</span> message)
    {
        <span class="comment">// A WebSocket text message is received.</span>

        <span class="comment">// You may echo it back if it matches certain criteria.</span>
        <span class="keyword">if</span> (message.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">echo:</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="comment">// Only demand for more events when sendText() is completed successfully.</span>
            session.sendText(message.substring(<span class="string"><span class="delimiter">&quot;</span><span class="content">echo:</span><span class="delimiter">&quot;</span></span>.length()), <span class="predefined-type">Callback</span>.from(session::demand, <span class="predefined-type">Throwable</span>::printStackTrace));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Discard the message, and demand for more events.</span>
            session.demand();
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketBinary(<span class="predefined-type">ByteBuffer</span> payload, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// A WebSocket binary message is received.</span>

        <span class="comment">// Save only PNG images.</span>
        <span class="type">boolean</span> isPNG = <span class="predefined-constant">true</span>;
        <span class="type">byte</span><span class="type">[]</span> pngBytes = <span class="keyword">new</span> <span class="type">byte</span><span class="type">[]</span>{(<span class="type">byte</span>)<span class="hex">0x89</span>, <span class="string"><span class="delimiter">'</span><span class="content">P</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">G</span><span class="delimiter">'</span></span>};
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; pngBytes.length; ++i)
        {
            <span class="keyword">if</span> (pngBytes[i] != payload.get(i))
            {
                <span class="comment">// Not a PNG image.</span>
                isPNG = <span class="predefined-constant">false</span>;
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">if</span> (isPNG)
            savePNGImage(payload);

        <span class="comment">// Complete the callback to release the payload ByteBuffer.</span>
        callback.succeed();

        <span class="comment">// Demand for more events.</span>
        session.demand();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketError(<span class="predefined-type">Throwable</span> cause)
    {
        <span class="comment">// The WebSocket endpoint failed.</span>

        <span class="comment">// You may log the error.</span>
        cause.printStackTrace();

        <span class="comment">// You may dispose resources.</span>
        disposeResources();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketClose(<span class="type">int</span> statusCode, <span class="predefined-type">String</span> reason)
    {
        <span class="comment">// The WebSocket endpoint has been closed.</span>

        <span class="comment">// You may dispose resources.</span>
        disposeResources();
    }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="pg-message-streaming-reads"><a class="anchor" href="#pg-message-streaming-reads"></a><a class="link" href="#pg-message-streaming-reads">Message Streaming Reads</a></h6>
<div class="paragraph">
<p>If you need to deal with large WebSocket messages, you may reduce the memory usage by streaming the message content.
For large WebSocket messages, the memory usage may be large due to the fact that the text or the bytes must be accumulated until the message is complete before delivering the message event.</p>
</div>
<div class="paragraph">
<p>To stream textual or binary messages, you override either <code>org.eclipse.jetty.websocket.api.Session.Listener.onWebSocketPartialText(...)</code> or <code>org.eclipse.jetty.websocket.api.Session.Listener.onWebSocketPartialBinary(...)</code>.</p>
</div>
<div class="paragraph">
<p>These methods receive <em>chunks</em> of, respectively, text and bytes that form the whole WebSocket message.</p>
</div>
<div class="paragraph">
<p>You may accumulate the chunks yourself, or process each chunk as it arrives, or stream the chunks elsewhere, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">StreamingListenerEndpoint</span> <span class="directive">implements</span> Session.Listener
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="local-variable">this</span>.session = session;
        session.demand();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketPartialText(<span class="predefined-type">String</span> payload, <span class="type">boolean</span> fin)
    {
        <span class="comment">// Forward chunks to external REST service, asynchronously.</span>
        <span class="comment">// Only demand when the forwarding completed successfully.</span>
        CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; result = forwardToREST(payload, fin);
        result.whenComplete((ignored, failure) -&gt;
        {
            <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                session.demand();
            <span class="keyword">else</span>
                failure.printStackTrace();
        });
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketPartialBinary(<span class="predefined-type">ByteBuffer</span> payload, <span class="type">boolean</span> fin, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Save chunks to file.</span>
        appendToFile(payload, fin);

        <span class="comment">// Complete the callback to release the payload ByteBuffer.</span>
        callback.succeed();

        <span class="comment">// Demand for more events.</span>
        session.demand();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket-endpoints-annotated"><a class="anchor" href="#pg-websocket-endpoints-annotated"></a><a class="link" href="#pg-websocket-endpoints-annotated">Annotated Endpoints</a></h5>
<div class="paragraph">
<p>A WebSocket endpoint may annotate methods with <code>org.eclipse.jetty.websocket.api.annotations.*</code> annotations to receive WebSocket events.</p>
</div>
<div class="paragraph">
<p>Each annotated event method may take an optional <code>Session</code> argument as its first parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>(autoDemand = <span class="predefined-constant">false</span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="type">class</span> <span class="class">AnnotatedEndPoint</span>
{
    <span class="annotation">@OnWebSocketOpen</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> <span class="type">void</span> onOpen(Session session)
    {
        <span class="comment">// The WebSocket endpoint has been opened.</span>

        <span class="comment">// You may configure the session.</span>
        session.setMaxTextMessageSize(<span class="integer">16</span> * <span class="integer">1024</span>);

        <span class="comment">// You may immediately send a message to the remote peer.</span>
        session.sendText(<span class="string"><span class="delimiter">&quot;</span><span class="content">connected</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.from(session::demand, <span class="predefined-type">Throwable</span>::printStackTrace));
    }

    <span class="annotation">@OnWebSocketMessage</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">void</span> onTextMessage(Session session, <span class="predefined-type">String</span> message)
    {
        <span class="comment">// A WebSocket textual message is received.</span>

        <span class="comment">// You may echo it back if it matches certain criteria.</span>
        <span class="keyword">if</span> (message.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">echo:</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="comment">// Only demand for more events when sendText() is completed successfully.</span>
            session.sendText(message.substring(<span class="string"><span class="delimiter">&quot;</span><span class="content">echo:</span><span class="delimiter">&quot;</span></span>.length()), <span class="predefined-type">Callback</span>.from(session::demand, <span class="predefined-type">Throwable</span>::printStackTrace));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Discard the message, and demand for more events.</span>
            session.demand();
        }
    }

    <span class="annotation">@OnWebSocketMessage</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">void</span> onBinaryMessage(Session session, <span class="predefined-type">ByteBuffer</span> payload, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// A WebSocket binary message is received.</span>

        <span class="comment">// Save only PNG images.</span>
        <span class="type">boolean</span> isPNG = <span class="predefined-constant">true</span>;
        <span class="type">byte</span><span class="type">[]</span> pngBytes = <span class="keyword">new</span> <span class="type">byte</span><span class="type">[]</span>{(<span class="type">byte</span>)<span class="hex">0x89</span>, <span class="string"><span class="delimiter">'</span><span class="content">P</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">N</span><span class="delimiter">'</span></span>, <span class="string"><span class="delimiter">'</span><span class="content">G</span><span class="delimiter">'</span></span>};
        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; pngBytes.length; ++i)
        {
            <span class="keyword">if</span> (pngBytes[i] != payload.get(i))
            {
                <span class="comment">// Not a PNG image.</span>
                isPNG = <span class="predefined-constant">false</span>;
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">if</span> (isPNG)
            savePNGImage(payload);

        <span class="comment">// Complete the callback to release the payload ByteBuffer.</span>
        callback.succeed();

        <span class="comment">// Demand for more events.</span>
        session.demand();
    }

    <span class="annotation">@OnWebSocketError</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="directive">public</span> <span class="type">void</span> onError(<span class="predefined-type">Throwable</span> cause)
    {
        <span class="comment">// The WebSocket endpoint failed.</span>

        <span class="comment">// You may log the error.</span>
        cause.printStackTrace();

        <span class="comment">// You may dispose resources.</span>
        disposeResources();
    }

    <span class="annotation">@OnWebSocketClose</span> <i class="conum" data-value="5"></i><b>(5)</b>
    <span class="directive">public</span> <span class="type">void</span> onClose(<span class="type">int</span> statusCode, <span class="predefined-type">String</span> reason)
    {
        <span class="comment">// The WebSocket endpoint has been closed.</span>

        <span class="comment">// You may dispose resources.</span>
        disposeResources();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Use the <code>@WebSocket</code> annotation at the class level to make it a WebSocket endpoint, and disable auto-demand.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the <code>@OnWebSocketOpen</code> annotation for the <em>open</em> event.
As this is the first event notified to the endpoint, you can configure the <code>Session</code> object.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Use the <code>@OnWebSocketMessage</code> annotation for the <em>message</em> event, both for textual and binary messages.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Use the <code>@OnWebSocketError</code> annotation for the <em>error</em> event.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Use the <code>@OnWebSocketClose</code> annotation for the <em>close</em> event.</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="pg-websocket-endpoints-annotated-streaming"><a class="anchor" href="#pg-websocket-endpoints-annotated-streaming"></a><a class="link" href="#pg-websocket-endpoints-annotated-streaming">Message Streaming Reads</a></h6>
<div class="paragraph">
<p>If you need to deal with large WebSocket messages, you may reduce the memory usage by streaming the message content.</p>
</div>
<div class="paragraph">
<p>To stream textual or binary messages, you still use the <code>@OnWebSocketMessage</code> annotation, but you change the signature of the method to take an additional <code>boolean</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>(autoDemand = <span class="predefined-constant">false</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">PartialAnnotatedEndpoint</span>
{
    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onTextMessage(Session session, <span class="predefined-type">String</span> partialText, <span class="type">boolean</span> fin)
    {
        <span class="comment">// Forward the partial text.</span>
        <span class="comment">// Demand only when the forward completed.</span>
        CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; result = forwardToREST(partialText, fin);
        result.whenComplete((ignored, failure) -&gt;
        {
            <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                session.demand();
            <span class="keyword">else</span>
                failure.printStackTrace();
        });
    }

    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onBinaryMessage(Session session, <span class="predefined-type">ByteBuffer</span> partialPayload, <span class="type">boolean</span> fin, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Save partial payloads to file.</span>
        appendToFile(partialPayload, fin);
        <span class="comment">// Complete the callback to release the payload ByteBuffer.</span>
        callback.succeed();
        <span class="comment">// Demand for more events.</span>
        session.demand();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, but less efficiently, you can use the <code>@OnWebSocketMessage</code> annotation, but you change the signature of the method to take, respectively, a <code>Reader</code> and an <code>InputStream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">StreamingAnnotatedEndpoint</span>
{
    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onTextMessage(<span class="predefined-type">Reader</span> reader)
    {
        <span class="comment">// Read from the Reader and forward.</span>
        <span class="comment">// Caution: blocking APIs.</span>
        forwardToREST(reader);
    }

    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onBinaryMessage(<span class="predefined-type">InputStream</span> stream)
    {
        <span class="comment">// Read from the InputStream and save to file.</span>
        <span class="comment">// Caution: blocking APIs.</span>
        appendToFile(stream);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Reader</code> or <code>InputStream</code> only offer blocking APIs, so if the remote peers are slow in sending the large WebSocket messages, reading threads may be blocked in <code>Reader.read(char[])</code> or <code>InputStream.read(byte[])</code>, possibly exhausting the thread pool.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that when you use blocking APIs, the invocations to <code>Session.demand()</code> are now performed by the <code>Reader</code> or <code>InputStream</code> implementations (as well as the <code>ByteBuffer</code> lifecycle management).
You indirectly control the demand by deciding when to read from <code>Reader</code> or <code>InputStream</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-websocket-session"><a class="anchor" href="#pg-websocket-session"></a><a class="link" href="#pg-websocket-session">WebSocket Session</a></h4>
<div class="paragraph">
<p>A WebSocket session is the entity that offers an API to send data to the remote peer, to close the WebSocket connection, and to configure WebSocket connection parameters.</p>
</div>
<div class="sect4">
<h5 id="pg-websocket-session-configure"><a class="anchor" href="#pg-websocket-session-configure"></a><a class="link" href="#pg-websocket-session-configure">Configuring the Session</a></h5>
<div class="paragraph">
<p>You may configure the WebSocket session behavior using the <code>org.eclipse.jetty.websocket.api.Session</code> APIs.
You want to do this as soon as you have access to the <code>Session</code> object, typically from the <a href="#pg-websocket-endpoints"><em>open</em> event</a> handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ConfigureEndpoint</span> <span class="directive">implements</span> Session.Listener
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="comment">// Configure the max length of incoming messages.</span>
        session.setMaxTextMessageSize(<span class="integer">16</span> * <span class="integer">1024</span>);

        <span class="comment">// Configure the idle timeout.</span>
        session.setIdleTimeout(<span class="predefined-type">Duration</span>.ofSeconds(<span class="integer">30</span>));

        <span class="comment">// Demand for more events.</span>
        session.demand();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The settings that can be configured include:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">maxBinaryMessageSize</dt>
<dd>
<p>the maximum size in bytes of a binary message (which may be composed of multiple frames) that can be received.</p>
</dd>
<dt class="hdlist1">maxTextMessageSize</dt>
<dd>
<p>the maximum size in bytes of a text message (which may be composed of multiple frames) that can be received.</p>
</dd>
<dt class="hdlist1">maxFrameSize</dt>
<dd>
<p>the maximum payload size in bytes of any WebSocket frame that can be received.</p>
</dd>
<dt class="hdlist1">inputBufferSize</dt>
<dd>
<p>the input (read from network/transport layer) buffer size in bytes; it has no relationship with the WebSocket frame size or message size.</p>
</dd>
<dt class="hdlist1">outputBufferSize</dt>
<dd>
<p>the output (write to network/transport layer) buffer size in bytes; it has no relationship to the WebSocket frame size or message size.</p>
</dd>
<dt class="hdlist1">autoFragment</dt>
<dd>
<p>whether WebSocket frames are automatically fragmented to respect the maximum frame size.</p>
</dd>
<dt class="hdlist1">idleTimeout</dt>
<dd>
<p>the duration that a WebSocket connection may remain idle (that is, there is no network traffic, neither in read nor in write) before being closed by the implementation.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Please refer to the <code>Session</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/websocket/api/Session.html">javadocs</a> for the complete list of configuration APIs.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket-session-send"><a class="anchor" href="#pg-websocket-session-send"></a><a class="link" href="#pg-websocket-session-send">Sending Data</a></h5>
<div class="paragraph">
<p>To send data to the remote peer, you can use the non-blocking APIs offered by <code>Session</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">NonBlockingSendEndpoint</span>
{
    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onText(Session session, <span class="predefined-type">String</span> text)
    {
        <span class="comment">// Send textual data to the remote peer.</span>
        session.sendText(<span class="string"><span class="delimiter">&quot;</span><span class="content">data</span><span class="delimiter">&quot;</span></span>, <span class="keyword">new</span> <span class="predefined-type">Callback</span>() <i class="conum" data-value="1"></i><b>(1)</b>
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> succeed()
            {
                <span class="comment">// Send binary data to the remote peer.</span>
                <span class="predefined-type">ByteBuffer</span> bytes = readImageFromFile();
                session.sendBinary(bytes, <span class="keyword">new</span> <span class="predefined-type">Callback</span>() <i class="conum" data-value="2"></i><b>(2)</b>
                {
                    <span class="annotation">@Override</span>
                    <span class="directive">public</span> <span class="type">void</span> succeed()
                    {
                        <span class="comment">// Both sends succeeded.</span>
                    }

                    <span class="annotation">@Override</span>
                    <span class="directive">public</span> <span class="type">void</span> fail(<span class="predefined-type">Throwable</span> x)
                    {
                        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">websocket</span><span class="delimiter">&quot;</span></span>).log(<span class="predefined-type">System</span>.Logger.Level.WARNING, <span class="string"><span class="delimiter">&quot;</span><span class="content">could not send binary data</span><span class="delimiter">&quot;</span></span>, x);
                    }
                });
            }

            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> fail(<span class="predefined-type">Throwable</span> x)
            {
                <span class="comment">// No need to rethrow or close the session.</span>
                <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">websocket</span><span class="delimiter">&quot;</span></span>).log(<span class="predefined-type">System</span>.Logger.Level.WARNING, <span class="string"><span class="delimiter">&quot;</span><span class="content">could not send textual data</span><span class="delimiter">&quot;</span></span>, x);
            }
        });

        <span class="comment">// remote.sendString(&quot;wrong&quot;, Callback.NOOP); // May throw WritePendingException! </span><i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Non-blocking APIs require a <code>Callback</code> parameter.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Note how the second send must be performed from inside the callback.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Sequential sends may throw <code>WritePendingException</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Non-blocking APIs are more difficult to use since you are required to meet the following condition:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You cannot initiate another send of any kind until the previous send is completed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, if you have initiated a text send, you cannot initiate another text or binary send, until the previous send has completed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This requirement is necessary to avoid unbounded buffering that could lead to <code>OutOfMemoryError</code>s.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We strongly recommend that you follow the condition above.</p>
</div>
<div class="paragraph">
<p>However, there may be cases where you want to explicitly control the number of outgoing buffered messages using <code>RemoteEndpoint.setMaxOutgoingFrames(int)</code>.</p>
</div>
<div class="paragraph">
<p>Remember that trying to control the number of outgoing frames is very difficult and tricky; you may set <code>maxOutgoingFrames=4</code> and have a situation where 6 threads try to concurrently send messages: threads 1 to 4 will be able to successfully buffer their messages, thread 5 may fail, but thread 6 may succeed because one of the previous threads completed its send.
At this point you have an out-of-order message delivery that could be unexpected and very difficult to troubleshoot because it will happen non-deterministically.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While non-blocking APIs are more difficult to use, they don&#8217;t block the sender thread and therefore use less resources, which in turn typically allows for greater scalability under load: with respect to blocking APIs, non-blocking APIs need less resources to cope with the same load.</p>
</div>
<div class="sect5">
<h6 id="pg-websocket-session-send-stream"><a class="anchor" href="#pg-websocket-session-send-stream"></a><a class="link" href="#pg-websocket-session-send-stream">Streaming Send APIs</a></h6>
<div class="paragraph">
<p>If you need to send large WebSocket messages, you may reduce the memory usage by streaming the message content.</p>
</div>
<div class="paragraph">
<p>The Jetty WebSocket APIs offer <code>sendPartial*(...)</code> methods that allow you to send a chunk of the whole message at a time, therefore reducing the memory usage since it is not necessary to have the whole message <code>String</code> or <code>ByteBuffer</code> in memory to send it.</p>
</div>
<div class="paragraph">
<p>The Jetty WebSocket APIs for streaming the message content are non-blocking and therefore you should wait (without blocking!) for the callbacks to complete.</p>
</div>
<div class="paragraph">
<p>Fortunately, Jetty provides the <code>IteratingCallback</code> utility class (described in more details <a href="#pg-arch-io-echo">in this section</a>) which greatly simplify the use of non-blocking APIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>(autoDemand = <span class="predefined-constant">false</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">StreamSendNonBlockingEndpoint</span>
{
    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onText(Session session, <span class="predefined-type">String</span> text)
    {
        <span class="keyword">new</span> Sender(session).iterate();
    }

    <span class="directive">private</span> <span class="type">class</span> <span class="class">Sender</span> <span class="directive">extends</span> IteratingCallback <span class="directive">implements</span> <span class="predefined-type">Callback</span> <i class="conum" data-value="1"></i><b>(1)</b>
    {
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">ByteBuffer</span> byteBuffer = <span class="predefined-type">ByteBuffer</span>.allocateDirect(<span class="integer">1024</span>);
        <span class="directive">private</span> <span class="directive">final</span> Session session;
        <span class="directive">private</span> <span class="type">boolean</span> finished;

        <span class="directive">private</span> Sender(Session session)
        {
            <span class="local-variable">this</span>.session = session;
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="predefined-type">Action</span> process() <span class="directive">throws</span> <span class="predefined-type">Throwable</span> <i class="conum" data-value="2"></i><b>(2)</b>
        {
            <span class="keyword">if</span> (finished)
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.SUCCEEDED; <i class="conum" data-value="4"></i><b>(4)</b>

            <span class="type">int</span> read = readChunkToSendInto(byteBuffer);
            <span class="keyword">if</span> (read &lt; <span class="integer">0</span>)
            {
                <span class="comment">// No more bytes to send, finish the WebSocket message.</span>
                session.sendPartialBinary(byteBuffer, <span class="predefined-constant">true</span>, <span class="local-variable">this</span>); <i class="conum" data-value="3"></i><b>(3)</b>
                finished = <span class="predefined-constant">true</span>;
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.SCHEDULED;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// Send the chunk.</span>
                session.sendPartialBinary(byteBuffer, <span class="predefined-constant">false</span>, <span class="local-variable">this</span>); <i class="conum" data-value="3"></i><b>(3)</b>
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.SCHEDULED;
            }
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> succeed()
        {
            <span class="comment">// When the send succeeds, succeed this IteratingCallback.</span>
            succeeded();
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> fail(<span class="predefined-type">Throwable</span> x)
        {
            <span class="comment">// When the send fails, fail this IteratingCallback.</span>
            failed(x);
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteSuccess()
        {
            session.demand(); <i class="conum" data-value="5"></i><b>(5)</b>
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteFailure(<span class="predefined-type">Throwable</span> x)
        {
            x.printStackTrace();
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Implementing <code>Callback</code> allows to pass <code>this</code> to <code>sendPartialBinary(...)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>process()</code> method is called iteratively when each <code>sendPartialBinary(...)</code> is completed.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Sends the message chunks.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>When the last chunk as been sent, complete successfully the <code>IteratingCallback</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Only when the <code>IteratingCallback</code> is completed successfully, demand for more WebSocket events.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket-session-ping"><a class="anchor" href="#pg-websocket-session-ping"></a><a class="link" href="#pg-websocket-session-ping">Sending Ping/Pong</a></h5>
<div class="paragraph">
<p>The WebSocket protocol defines two special frame, named <code>PING</code> and <code>PONG</code> that may be interesting to applications for these use cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Calculate the round-trip time with the remote peer.</p>
</li>
<li>
<p>Keep the connection from being closed due to idle timeout&#8201;&#8212;&#8201;a heartbeat-like mechanism.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To handle <code>PING</code>/<code>PONG</code> events, you may implement methods <code>Session.Listener.onWebSocketPing(ByteBuffer)</code> and/or <code>Session.Listener.onWebSocketPong(ByteBuffer)</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>PING</code>/<code>PONG</code> events are also supported when using annotations via the <code>OnWebSocketFrame</code> annotation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>PING</code> frames may contain opaque application bytes, and the WebSocket implementation replies to them with a <code>PONG</code> frame containing the same bytes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">RoundTripListenerEndpoint</span> <span class="directive">implements</span> Session.Listener
{
    <span class="directive">private</span> Session session;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketOpen(Session session)
    {
        <span class="local-variable">this</span>.session = session;
        <span class="comment">// Send to the remote peer the local nanoTime.</span>
        <span class="predefined-type">ByteBuffer</span> buffer = <span class="predefined-type">ByteBuffer</span>.allocate(<span class="integer">8</span>).putLong(NanoTime.now()).flip();
        session.sendPing(buffer, <span class="predefined-type">Callback</span>.NOOP);
        <span class="comment">// Demand for more events.</span>
        session.demand();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onWebSocketPong(<span class="predefined-type">ByteBuffer</span> payload)
    {
        <span class="comment">// The remote peer echoed back the local nanoTime.</span>
        <span class="type">long</span> start = payload.getLong();

        <span class="comment">// Calculate the round-trip time.</span>
        <span class="type">long</span> roundTrip = NanoTime.since(start);

        <span class="comment">// Demand for more events.</span>
        session.demand();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket-session-close"><a class="anchor" href="#pg-websocket-session-close"></a><a class="link" href="#pg-websocket-session-close">Closing the Session</a></h5>
<div class="paragraph">
<p>When you want to terminate the communication with the remote peer, you close the <code>Session</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@WebSocket</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CloseEndpoint</span>
{
    <span class="annotation">@OnWebSocketMessage</span>
    <span class="directive">public</span> <span class="type">void</span> onText(Session session, <span class="predefined-type">String</span> text)
    {
        <span class="keyword">if</span> (<span class="string"><span class="delimiter">&quot;</span><span class="content">close</span><span class="delimiter">&quot;</span></span>.equalsIgnoreCase(text))
            session.close(StatusCode.NORMAL, <span class="string"><span class="delimiter">&quot;</span><span class="content">bye</span><span class="delimiter">&quot;</span></span>, <span class="predefined-type">Callback</span>.NOOP);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Closing a WebSocket <code>Session</code> carries a status code and a reason message that the remote peer can inspect in the <em>close</em> event handler (see <a href="#pg-websocket-endpoints">this section</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The reason message is optional, and may be truncated to fit into the WebSocket frame sent to the client.
It is best to use short tokens such as <code>"shutdown"</code>, or <code>"idle_timeout"</code>, etc. or even application specific codes such as <code>"0001"</code> or <code>"00AF"</code> that can be converted by the application into more meaningful messages.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pg-server"><a class="anchor" href="#pg-server"></a><a class="link" href="#pg-server">Server Libraries</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Eclipse Jetty Project provides server-side libraries that allow you to configure and start programmatically an HTTP or WebSocket server from a main class, or embed it in your existing application.
A typical example is a HTTP server that needs to expose a REST endpoint.
Another example is a proxy application that receives HTTP requests, processes them, and then forwards them to third party services, for example using the Jetty <a href="#pg-client">client libraries</a>.</p>
</div>
<div class="paragraph">
<p>While historically Jetty is an HTTP server, it is possible to use the Jetty server-side libraries to write a generic network server that interprets any network protocol (not only HTTP).
If you are interested in the low-level details of how the Eclipse Jetty server libraries work, or are interested in writing a custom protocol, look at the <a href="#pg-server-io-arch">Server I/O Architecture</a>.</p>
</div>
<div class="paragraph">
<p>The Jetty server-side libraries provide:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HTTP high-level support for HTTP/1.0, HTTP/1.1, HTTP/2, clear-text or encrypted, HTTP/3, for applications that want to embed Jetty as a generic HTTP server or proxy (no matter the HTTP version), via the <a href="#pg-server-http">HTTP libraries</a></p>
</li>
<li>
<p>HTTP/2 low-level support, for applications that want to explicitly handle low-level HTTP/2 <em>sessions</em>, <em>streams</em> and <em>frames</em>, via the <a href="#pg-server-http2">HTTP/2 libraries</a></p>
</li>
<li>
<p>HTTP/3 low-level support, for applications that want to explicitly handle low-level HTTP/3 <em>sessions</em>, <em>streams</em> and <em>frames</em>, via the <a href="#pg-server-http3">HTTP/3 libraries</a></p>
</li>
<li>
<p>WebSocket support, for applications that want to embed a WebSocket server, via the <a href="#pg-server-websocket">WebSocket libraries</a></p>
</li>
<li>
<p>FCGI support, to delegate requests to PHP, Python, Ruby or similar scripting languages.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="pg-server-http"><a class="anchor" href="#pg-server-http"></a><a class="link" href="#pg-server-http">HTTP Server Libraries</a></h3>
<div class="paragraph">
<p>Web application development typically involves writing your web applications, packaging them into a web application archive, the <code>*.war</code> file, and then deploy the <code>*.war</code> file into a standalone Servlet Container that you have previously installed.</p>
</div>
<div class="paragraph">
<p>The Jetty server libraries allow you to write web applications components using either the Jetty APIs (by writing <a href="#pg-server-http-handler">Jetty <code>Handler</code>s</a>) or using the standard <a href="#pg-server-http-handler-use-servlet">Servlet APIs</a> (by writing <code>Servlet</code>s and Servlet <code>Filter</code>s).
These components can then be programmatically assembled together, without the need of creating a <code>*.war</code> file, added to a Jetty <code>Server</code> instance that is then started.
This result in your web applications to be available to HTTP clients as if you deployed your <code>*.war</code> files in a standalone Jetty server.</p>
</div>
<div class="paragraph">
<p>Jetty <code>Handler</code> APIs pros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple minimalist asynchronous APIs.</p>
</li>
<li>
<p>Very low overhead, only configure the features you use.</p>
</li>
<li>
<p>Faster turnaround to implement new APIs or new standards.</p>
</li>
<li>
<p>Normal classloading behavior (web application classloading isolation also available).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Servlet APIs pros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard, well known, APIs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-server<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Server</code> instance is the central component that links together a collection of <code>Connector</code>s and a collection of <code>Handler</code>s, with threads from a <code>ThreadPool</code> doing the work.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-05cfcead1245ff0fbcf3af8873998cee.png" alt="Diagram" width="504" height="216">
</div>
</div>
<div class="paragraph">
<p>The components that accept connections from clients are <code>org.eclipse.jetty.server.Connector</code> implementations.</p>
</div>
<div class="paragraph">
<p>When a Jetty server interprets the HTTP protocol (HTTP/1.1, HTTP/2 or HTTP/3), it uses <code>org.eclipse.jetty.server.Handler</code> instances to process incoming requests and eventually produce responses.</p>
</div>
<div class="paragraph">
<p>A <code>Server</code> must be created, configured and started:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create and configure a ThreadPool.</span>
QueuedThreadPool threadPool = <span class="keyword">new</span> QueuedThreadPool();
threadPool.setName(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create a Server instance.</span>
Server server = <span class="keyword">new</span> Server(threadPool);

<span class="comment">// Create a ServerConnector to accept connections from clients.</span>
Connector connector = <span class="keyword">new</span> ServerConnector(server);

<span class="comment">// Add the Connector to the Server</span>
server.addConnector(connector);

<span class="comment">// Set a simple Handler to handle requests/responses.</span>
server.setHandler(<span class="keyword">new</span> <span class="predefined-type">Handler</span>.Abstract()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Succeed the callback to signal that the</span>
        <span class="comment">// request/response processing is complete.</span>
        callback.succeeded();
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
});

<span class="comment">// Start the Server to start accepting connections from clients.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows the simplest HTTP/1.1 server; it has no support for HTTP sessions, nor for HTTP authentication, nor for any of the features required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>These features (HTTP session support, HTTP authentication support, etc.) are provided by the Jetty server libraries, but not all of them may be necessary in your web application.
You need to put together the required Jetty components to provide the features required by your web applications.
The advantage is that you do not pay the cost for features that you do not use, saving resources and likely increasing performance.</p>
</div>
<div class="paragraph">
<p>The built-in <code>Handler</code>s provided by the Jetty server libraries allow you to write web applications that have functionalities similar to Apache HTTPD or Nginx (for example: URL redirection, URL rewriting, serving static content, reverse proxying, etc.), as well as generating content dynamically by processing incoming requests.
Read <a href="#pg-server-http-handler">this section</a> for further details about <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If you are interested in writing your web application based on the Servlet APIs, jump to <a href="#pg-server-http-handler-use-servlet">this section</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-server-http-request-processing"><a class="anchor" href="#pg-server-http-request-processing"></a><a class="link" href="#pg-server-http-request-processing">Request Processing</a></h4>
<div class="paragraph">
<p>The Jetty HTTP request processing is outlined below in the diagram below.
You may want to refer to the <a href="#pg-arch-io">Jetty I/O architecture</a> for additional information about the classes mentioned below.</p>
</div>
<div class="paragraph">
<p>Request handing is slightly different for each protocol; in HTTP/2 Jetty takes into account multiplexing, something that is not present in HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>However, the diagram below captures the essence of request handling that is common among all protocols that carry HTTP requests.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-483677f5d04b6727cafec45f5d1e212a.png" alt="Diagram" width="768" height="337">
</div>
</div>
<div class="paragraph">
<p>First, the Jetty I/O layer emits an event that a socket has data to read.
This event is converted to a call to <code>AbstractConnection.onFillable()</code>, where the <code>Connection</code> first reads from the <code>EndPoint</code> into a <code>ByteBuffer</code>, and then calls a protocol specific parser to parse the bytes in the <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>The parser emit events that are protocol specific; the HTTP/2 parser, for example, emits events for each HTTP/2 frame that has been parsed, and similarly does the HTTP/3 parser.
The parser events are then converted to protocol independent events such as <em>"request start"</em>, <em>"request headers"</em>, <em>"request content chunk"</em>, etc. detailed in <a href="#pg-server-http-request-processing-events">this section</a>.</p>
</div>
<div class="paragraph">
<p>When enough of the HTTP request is arrived, the <code>Connection</code> calls <code>HttpChannel.onRequest()</code>.</p>
</div>
<div class="paragraph">
<p><code>HttpChannel.onRequest()</code> calls the <a href="#pg-server-http-request-customizers">request customizers</a>, that allow to customize the request and/or the response headers on a per-<code>Connector</code> basis.</p>
</div>
<div class="paragraph">
<p>After request customization, if any, the <code>Handler</code> chain is invoked, starting from the <code>Server</code> instance, and eventually your web application code is invoked.</p>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-processing-events"><a class="anchor" href="#pg-server-http-request-processing-events"></a><a class="link" href="#pg-server-http-request-processing-events">Request Processing Events</a></h5>
<div class="paragraph">
<p>Advanced web applications may be interested in the progress of the processing of an HTTP request/response.
A typical case is to know exactly <em>when</em> the HTTP request/response processing starts and when it is complete, for example to monitor processing times.</p>
</div>
<div class="paragraph">
<p>This is conveniently implemented by <code>org.eclipse.jetty.server.handler.EventsHandler</code>, described in more details in <a href="#pg-server-http-handler-use-events">this section</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http-request-logging"><a class="anchor" href="#pg-server-http-request-logging"></a><a class="link" href="#pg-server-http-request-logging">Request Logging</a></h4>
<div class="paragraph">
<p>HTTP requests and responses can be logged to provide data that can be later analyzed with other tools.
These tools can provide information such as the most frequently accessed request URIs, the response status codes, the request/response content lengths, geographical information about the clients, etc.</p>
</div>
<div class="paragraph">
<p>The default request/response log line format is the <a href="https://en.wikipedia.org/wiki/Common_Log_Format">NCSA Format</a> extended with referrer data and user-agent data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typically, the extended NCSA format is the is enough and it&#8217;s the standard used and understood by most log parsing tools and monitoring tools.</p>
</div>
<div class="paragraph">
<p>To customize the request/response log line format see the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/CustomRequestLog.html"><code>CustomRequestLog</code> javadocs</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Request logging can be enabled at the <code>Server</code> level.</p>
</div>
<div class="paragraph">
<p>The request logging output can be directed to an SLF4J logger named <code>"org.eclipse.jetty.server.RequestLog"</code> at <code>INFO</code> level, and therefore to any logging library implementation of your choice (see also <a href="#pg-troubleshooting-logging">this section</a> about logging).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Sets the RequestLog to log to an SLF4J logger named &quot;org.eclipse.jetty.server.RequestLog&quot; at INFO level.</span>
server.setRequestLog(<span class="keyword">new</span> CustomRequestLog(<span class="keyword">new</span> Slf4jRequestLogWriter(), CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the request logging output can be directed to a daily rolling file of your choice, and the file name must contain <code>yyyy_MM_dd</code> so that rolled over files retain their date:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Use a file name with the pattern 'yyyy_MM_dd' so rolled over files retain their date.</span>
RequestLogWriter logWriter = <span class="keyword">new</span> RequestLogWriter(<span class="string"><span class="delimiter">&quot;</span><span class="content">/var/log/yyyy_MM_dd.jetty.request.log</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Retain rolled over files for 2 weeks.</span>
logWriter.setRetainDays(<span class="integer">14</span>);
<span class="comment">// Log times are in the current time zone.</span>
logWriter.setTimeZone(<span class="predefined-type">TimeZone</span>.getDefault().getID());

<span class="comment">// Set the RequestLog to log to the given file, rolling over at midnight.</span>
server.setRequestLog(<span class="keyword">new</span> CustomRequestLog(logWriter, CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>For maximum flexibility, you can log to multiple <code>RequestLog</code>s using class <code>RequestLog.Collection</code>, for example by logging with different formats or to different outputs.</p>
</div>
<div class="paragraph">
<p>You can use <code>CustomRequestLog</code> with a custom <code>RequestLog.Writer</code> to direct the request logging output to your custom targets (for example, an RDBMS).
You can implement your own <code>RequestLog</code> if you want to have functionalities that are not implemented by <code>CustomRequestLog</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http-request-customizers"><a class="anchor" href="#pg-server-http-request-customizers"></a><a class="link" href="#pg-server-http-request-customizers">Request Customizers</a></h4>
<div class="paragraph">
<p>A request customizer is an instance of <code>HttpConfiguration.Customizer</code>, that can customize the HTTP request and/or the HTTP response headers <em>before</em> the <code>Handler</code> chain is invoked.</p>
</div>
<div class="paragraph">
<p>Request customizers are added to a particular <code>HttpConfiguration</code> instance, and therefore are specific to a <code>Connector</code> instance: you can have two different <code>Connector</code>s configured with different request customizers.</p>
</div>
<div class="paragraph">
<p>For example, it is common to configure a secure <code>Connector</code> with the <code>SecureRequestCustomizer</code> that customizes the HTTP request by adding attributes that expose TLS data associated with the secure communication.</p>
</div>
<div class="paragraph">
<p>A request customizer may:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inspect the received HTTP request method, URI, version and headers.</p>
</li>
<li>
<p>Wrap the <code>Request</code> object to allow any method to be overridden and customized. Typically this is done to synthesize additional HTTP request headers, or to change the return value of overridden methods.</p>
</li>
<li>
<p>Add or modify the HTTP response headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The out-of-the-box request customizers include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForwardedRequestCustomizer</code>&#8201;&#8212;&#8201;to interpret the <code>Forwarded</code> (or the the obsolete <code>X-Forwarded-*</code>) HTTP header added by a reverse proxy; see <a href="#pg-server-http-request-customizer-forwarded">this section</a>.</p>
</li>
<li>
<p><code>HostHeaderCustomizer</code>&#8201;&#8212;&#8201;to customize, or synthesize it when original absent, the HTTP <code>Host</code> header; see <a href="#pg-server-http-request-customizer-host">this section</a>.</p>
</li>
<li>
<p><code>ProxyCustomizer</code>&#8201;&#8212;&#8201;to expose as <code>Request</code> attributes the <code>ip:port</code> information carried by the PROXY protocol; see <a href="#pg-server-http-request-customizer-proxy">this section</a>.</p>
</li>
<li>
<p><code>RewriteCustomizer</code>&#8201;&#8212;&#8201;to rewrite the request URI; see <a href="#pg-server-http-request-customizer-rewrite">this section</a>.</p>
</li>
<li>
<p><code>SecureRequestCustomizer</code>&#8201;&#8212;&#8201;to expose TLS data via <code>Request</code> attributes; see <a href="#pg-server-http-request-customizer-secure">this section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also write your own request customizers and add them to the <code>HttpConfiguration</code> instance along existing request customizers.
Multiple request customizers will be invoked in the order they have been added.</p>
</div>
<div class="paragraph">
<p>Below you can find an example of how to add a request customizer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Configure the secure connector.</span>
HttpConfiguration httpsConfig = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// Add the SecureRequestCustomizer.</span>
httpsConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// Configure the SslContextFactory with the KeyStore information.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Configure the Connector to speak HTTP/1.1 and HTTP/2.</span>
HttpConnectionFactory h1 = <span class="keyword">new</span> HttpConnectionFactory(httpsConfig);
HTTP2ServerConnectionFactory h2 = <span class="keyword">new</span> HTTP2ServerConnectionFactory(httpsConfig);
ALPNServerConnectionFactory alpn = <span class="keyword">new</span> ALPNServerConnectionFactory();
alpn.setDefaultProtocol(h1.getProtocol());
SslConnectionFactory ssl = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, alpn.getProtocol());
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, ssl, alpn, h2, h1);
server.addConnector(connector);

server.start();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-customizer-forwarded"><a class="anchor" href="#pg-server-http-request-customizer-forwarded"></a><a class="link" href="#pg-server-http-request-customizer-forwarded"><code>ForwardedRequestCustomizer</code></a></h5>
<div class="paragraph">
<p><code>ForwardedRequestCustomizer</code> should be added when Jetty receives requests from a reverse proxy on behalf of a remote client, and web applications need to access the remote client information.</p>
</div>
<div class="paragraph">
<p>The reverse proxy adds the <code>Forwarded</code> (or the obsolete <code>X-Forwarded-*</code>) HTTP header to the request, and may offload TLS so that the request arrives in clear-text to Jetty.</p>
</div>
<div class="paragraph">
<p>Applications deployed in Jetty may need to access information related to the remote client, for example the remote IP address and port, or whether the request was sent through a secure communication channel.
However, the request is forwarded by the reverse proxy, so the direct information about the remote IP address is that of the proxy, not of the remote client.
Furthermore, the proxy may offload TLS and forward the request in clear-text, so that the URI scheme would be <code>http</code> as forwarded by the reverse proxy, not <code>https</code> as sent by the remote client.</p>
</div>
<div class="paragraph">
<p><code>ForwardedRequestCustomizer</code> reads the <code>Forwarded</code> header where the reverse proxy saved the remote client information, and wraps the original <code>Request</code> so that applications will transparently see the remote client information when calling methods such as <code>Request.isSecure()</code>, or <code>Request.getConnectionMetaData().getRemoteSocketAddress()</code>, etc.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>ForwardedRequestCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ForwardedRequestCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-customizer-host"><a class="anchor" href="#pg-server-http-request-customizer-host"></a><a class="link" href="#pg-server-http-request-customizer-host"><code>HostHeaderCustomizer</code></a></h5>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> should be added when Jetty receives requests that may lack the <code>Host</code> HTTP header, such as HTTP/1.0, HTTP/2 or HTTP/3 requests, and web applications have logic that depends on the value of the <code>Host</code> HTTP header.</p>
</div>
<div class="paragraph">
<p>For HTTP/2 and HTTP/3, the <code>Host</code> HTTP header is missing because the authority information is carried by the <code>:authority</code> pseudo-header, as per the respective specifications.</p>
</div>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> will look at the <code>:authority</code> pseudo-header, then wrap the original <code>Request</code> adding a <code>Host</code> HTTP header synthesized from the <code>:authority</code> pseudo-header.
In this way, web applications that rely on the presence of the <code>Host</code> HTTP header will work seamlessly in any HTTP protocol version.</p>
</div>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> works also for the WebSocket protocol.</p>
</div>
<div class="paragraph">
<p>WebSocket over HTTP/2 or over HTTP/3 initiate the WebSocket communication with an HTTP request that only has the <code>:authority</code> pseudo-header.
<code>HostHeaderCustomizer</code> synthesizes the <code>Host</code> HTTP header for such requests, so that WebSocket web applications that inspect the initial HTTP request before the WebSocket communication will work seamlessly in any HTTP protocol version.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>HostHeaderCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/HostHeaderCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-customizer-proxy"><a class="anchor" href="#pg-server-http-request-customizer-proxy"></a><a class="link" href="#pg-server-http-request-customizer-proxy"><code>ProxyCustomizer</code></a></h5>
<div class="paragraph">
<p><code>ProxyCustomizer</code> should be added when Jetty receives requests from a reverse proxy on behalf of a remote client, prefixed by the PROXY protocol (see also this section about the <a href="#pg-server-http-connector-protocol-proxy-http11">PROXY protocol</a>).</p>
</div>
<div class="paragraph">
<p><code>ProxyCustomizer</code> adds the reverse proxy IP address and port as <code>Request</code> attributes.
Web applications may use these attributes in conjunction with the data exposed by <code>ForwardedRequestCustomizer</code> (see <a href="#pg-server-http-request-customizer-forwarded">this section</a>).</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>ProxyCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ProxyCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-customizer-rewrite"><a class="anchor" href="#pg-server-http-request-customizer-rewrite"></a><a class="link" href="#pg-server-http-request-customizer-rewrite"><code>RewriteCustomizer</code></a></h5>
<div class="paragraph">
<p><code>RewriteCustomizer</code> is similar to <code>RewriteHandler</code> (see <a href="#pg-server-http-handler-use-rewrite">this section</a>), but a <code>RewriteCustomizer</code> cannot send a response or otherwise complete the request/response processing.</p>
</div>
<div class="paragraph">
<p>A <code>RewriteCustomizer</code> is mostly useful if you want to rewrite the request URI <em>before</em> the <code>Handler</code> chain is invoked.
However, a very similar effect can be achieved by having the <code>RewriteHandler</code> as the first <code>Handler</code> (the child <code>Handler</code> of the <code>Server</code> instance).</p>
</div>
<div class="paragraph">
<p>Since <code>RewriteCustomizer</code> cannot send a response or complete the request/response processing, <code>Rule</code>s that do so such as redirect rules have no effect and are ignored; only <code>Rule</code>s that modify or wrap the <code>Request</code> will have effect and be applied.</p>
</div>
<div class="paragraph">
<p>Due to this limitation, it is often a better choice to use <code>RewriteHandler</code> instead of <code>RewriteCustomizer</code>.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>RewriteCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/rewrite/RewriteCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-request-customizer-secure"><a class="anchor" href="#pg-server-http-request-customizer-secure"></a><a class="link" href="#pg-server-http-request-customizer-secure"><code>SecureRequestCustomizer</code></a></h5>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> should be added when Jetty receives requests over a secure <code>Connector</code>.</p>
</div>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> adds TLS information as request attributes, in particular an instance of <code>EndPoint.SslSessionData</code> that contains information about the negotiated TLS cipher suite and possibly client certificates, and an instance of <code>org.eclipse.jetty.util.ssl.X509</code> that contains information about the server certificate.</p>
</div>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> also adds, if configured so, the <code>Strict-Transport-Security</code> HTTP response header (for more information about this header, see <a href="https://datatracker.ietf.org/doc/html/rfc6797">its specification</a>).</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>SecureRequestCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/SecureRequestCustomizer.html">the javadocs</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http-connector"><a class="anchor" href="#pg-server-http-connector"></a><a class="link" href="#pg-server-http-connector">Server Connectors</a></h4>
<div class="paragraph">
<p>A <code>Connector</code> is the component that handles incoming requests from clients, and works in conjunction with <code>ConnectionFactory</code> instances.</p>
</div>
<div class="paragraph">
<p>The available implementations are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.jetty.server.ServerConnector</code>, for TCP/IP sockets.</p>
</li>
<li>
<p><code>org.eclipse.jetty.unixdomain.server.UnixDomainServerConnector</code> for Unix-Domain sockets (requires Java 16 or later).</p>
</li>
<li>
<p><code>org.eclipse.jetty.quic.server.QuicServerConnector</code>, for the low-level QUIC protocol and HTTP/3.</p>
</li>
<li>
<p><code>org.eclipse.jetty.server.MemoryConnector</code>, for memory communication between client and server.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ServerConnector</code> and <code>UnixDomainServerConnector</code> use a <code>java.nio.channels.ServerSocketChannel</code> to listen to a socket address and to accept socket connections.
<code>QuicServerConnector</code> uses a <code>java.nio.channels.DatagramChannel</code> to listen to incoming UDP packets.
<code>MemoryConnector</code> uses memory for the communication between client and server, avoiding the use of sockets.</p>
</div>
<div class="paragraph">
<p>Since <code>ServerConnector</code> wraps a <code>ServerSocketChannel</code>, it can be configured in a similar way, for example the TCP port to listen to, the IP address to bind to, etc.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The number of acceptor threads.</span>
<span class="type">int</span> acceptors = <span class="integer">1</span>;

<span class="comment">// The number of selectors.</span>
<span class="type">int</span> selectors = <span class="integer">1</span>;

<span class="comment">// Create a ServerConnector instance.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, acceptors, selectors, <span class="keyword">new</span> HttpConnectionFactory());

<span class="comment">// Configure TCP/IP parameters.</span>

<span class="comment">// The port to listen to.</span>
connector.setPort(<span class="integer">8080</span>);
<span class="comment">// The address to bind to.</span>
connector.setHost(<span class="string"><span class="delimiter">&quot;</span><span class="content">127.0.0.1</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The TCP accept queue size.</span>
connector.setAcceptQueueSize(<span class="integer">128</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>UnixDomainServerConnector</code> also wraps a <code>ServerSocketChannel</code> and can be configured with the Unix-Domain path to listen to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The number of acceptor threads.</span>
<span class="type">int</span> acceptors = <span class="integer">1</span>;

<span class="comment">// The number of selectors.</span>
<span class="type">int</span> selectors = <span class="integer">1</span>;

<span class="comment">// Create a ServerConnector instance.</span>
UnixDomainServerConnector connector = <span class="keyword">new</span> UnixDomainServerConnector(server, acceptors, selectors, <span class="keyword">new</span> HttpConnectionFactory());

<span class="comment">// Configure Unix-Domain parameters.</span>

<span class="comment">// The Unix-Domain path to listen to.</span>
connector.setUnixDomainPath(Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/jetty.sock</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// The TCP accept queue size.</span>
connector.setAcceptQueueSize(<span class="integer">128</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use Unix-Domain sockets only when you run your server with Java 16 or later.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>QuicServerConnector</code> wraps a <code>DatagramChannel</code> and can be configured in a similar way, as shown in the example below.
Since the communication via UDP does not require to "accept" connections like TCP does, the number of <a href="#pg-server-http-connector-acceptors">acceptors</a> is set to <code>0</code> and there is no API to configure their number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Configure the SslContextFactory with the keyStore information.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create a QuicServerConnector instance.</span>
Path pemWorkDir = Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/pem/dir</span><span class="delimiter">&quot;</span></span>);
ServerQuicConfiguration serverQuicConfig = <span class="keyword">new</span> ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector connector = <span class="keyword">new</span> QuicServerConnector(server, serverQuicConfig, <span class="keyword">new</span> HTTP3ServerConnectionFactory(serverQuicConfig));

<span class="comment">// The port to listen to.</span>
connector.setPort(<span class="integer">8080</span>);
<span class="comment">// The address to bind to.</span>
connector.setHost(<span class="string"><span class="delimiter">&quot;</span><span class="content">127.0.0.1</span><span class="delimiter">&quot;</span></span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MemoryConnector</code> uses in-process memory, not sockets, for the communication between client and server, that therefore must be in the same process.</p>
</div>
<div class="paragraph">
<p>Typical usage of <code>MemoryConnector</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create a MemoryConnector instance that speaks HTTP/1.1.</span>
MemoryConnector connector = <span class="keyword">new</span> MemoryConnector(server, <span class="keyword">new</span> HttpConnectionFactory());

server.addConnector(connector);
server.start();

<span class="comment">// The code above is the server-side.</span>
<span class="comment">// ----</span>
<span class="comment">// The code below is the client-side.</span>

HttpClient httpClient = <span class="keyword">new</span> HttpClient();
httpClient.start();

ContentResponse response = httpClient.newRequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost/</span><span class="delimiter">&quot;</span></span>)
    <span class="comment">// Use the memory Transport to communicate with the server-side.</span>
    .transport(<span class="keyword">new</span> MemoryTransport(connector))
    .send();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-connector-acceptors"><a class="anchor" href="#pg-server-http-connector-acceptors"></a><a class="link" href="#pg-server-http-connector-acceptors">Acceptors</a></h5>
<div class="paragraph">
<p>The <em>acceptors</em> are threads (typically only one) that compete to accept TCP socket connections.
The connectors for the QUIC or HTTP/3 protocol, based on UDP, have no acceptors.</p>
</div>
<div class="paragraph">
<p>When a TCP connection is accepted, <code>ServerConnector</code> wraps the accepted <code>SocketChannel</code> and passes it to the <a href="#pg-arch-io-selector-manager"><code>SelectorManager</code></a>.
Therefore, there is a little moment where the acceptor thread is not accepting new connections because it is busy wrapping the just accepted connection to pass it to the <code>SelectorManager</code>.
Connections that are ready to be accepted but are not accepted yet are queued in a bounded queue (at the OS level) whose capacity can be configured with the <code>acceptQueueSize</code> parameter.</p>
</div>
<div class="paragraph">
<p>If your application must withstand a very high rate of connection opening, configuring more than one acceptor thread may be beneficial: when one acceptor thread accepts one connection, another acceptor thread can take over accepting connections.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-connector-selectors"><a class="anchor" href="#pg-server-http-connector-selectors"></a><a class="link" href="#pg-server-http-connector-selectors">Selectors</a></h5>
<div class="paragraph">
<p>The <em>selectors</em> are components that manage a set of accepted TCP sockets, implemented by <a href="#pg-arch-io-selector-manager"><code>ManagedSelector</code></a>.
For QUIC or HTTP/3, there are no accepted TCP sockets, but only one <code>DatagramChannel</code> and therefore there is only one selector.</p>
</div>
<div class="paragraph">
<p>Each selector requires one thread and uses the Java NIO mechanism to efficiently handle a set of registered channels.</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, a single selector can easily manage up to 1000-5000 TCP sockets, although the number may vary greatly depending on the application.</p>
</div>
<div class="paragraph">
<p>For example, web applications for websites tend to use TCP sockets for one or more HTTP requests to retrieve resources and then the TCP socket is idle for most of the time.
In this case a single selector may be able to manage many TCP sockets because chances are that they will be idle most of the time.
On the contrary, web messaging applications or REST applications tend to send many small messages at a very high frequency so that the TCP sockets are rarely idle.
In this case a single selector may be able to manage less TCP sockets because chances are that many of them will be active at the same time, so you may need more than one selector.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-connector-multiple"><a class="anchor" href="#pg-server-http-connector-multiple"></a><a class="link" href="#pg-server-http-connector-multiple">Multiple Connectors</a></h5>
<div class="paragraph">
<p>It is possible to configure more than one <code>Connector</code> per <code>Server</code>.
Typical cases are a <code>ServerConnector</code> for clear-text HTTP, and another <code>ServerConnector</code> for secure HTTP.
Another case could be a publicly exposed <code>ServerConnector</code> for secure HTTP, and an internally exposed <code>UnixDomainServerConnector</code> or <code>MemoryConnector</code> for clear-text HTTP.
Yet another example could be a <code>ServerConnector</code> for clear-text HTTP, a <code>ServerConnector</code> for secure HTTP/2, and an <code>QuicServerConnector</code> for QUIC+HTTP/3.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create a ServerConnector instance on port 8080.</span>
ServerConnector connector1 = <span class="keyword">new</span> ServerConnector(server, <span class="integer">1</span>, <span class="integer">1</span>, <span class="keyword">new</span> HttpConnectionFactory());
connector1.setPort(<span class="integer">8080</span>);
server.addConnector(connector1);

<span class="comment">// Create another ServerConnector instance on port 9090,</span>
<span class="comment">// for example with a different HTTP configuration.</span>
HttpConfiguration httpConfig2 = <span class="keyword">new</span> HttpConfiguration();
httpConfig2.setHttpCompliance(HttpCompliance.LEGACY);
ServerConnector connector2 = <span class="keyword">new</span> ServerConnector(server, <span class="integer">1</span>, <span class="integer">1</span>, <span class="keyword">new</span> HttpConnectionFactory(httpConfig2));
connector2.setPort(<span class="integer">9090</span>);
server.addConnector(connector2);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not specify the port the connector listens to explicitly, the OS will allocate one randomly when the connector starts.</p>
</div>
<div class="paragraph">
<p>You may need to use the randomly allocated port to configure other components.
One example is to use the randomly allocated port to configure secure redirects (when redirecting from a URI with the <code>http</code> scheme to the <code>https</code> scheme).
Another example is to bind both the HTTP/2 connector and the HTTP/3 connector to the same randomly allocated port.
It is possible that the HTTP/2 connector and the HTTP/3 connector share the same port, because one uses TCP, while the other uses UDP.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

Server server = <span class="keyword">new</span> Server();

<span class="comment">// The plain HTTP configuration.</span>
HttpConfiguration plainConfig = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// The secure HTTP configuration.</span>
HttpConfiguration secureConfig = <span class="keyword">new</span> HttpConfiguration(plainConfig);
secureConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// First, create the secure connector for HTTPS and HTTP/2.</span>
HttpConnectionFactory https = <span class="keyword">new</span> HttpConnectionFactory(secureConfig);
HTTP2ServerConnectionFactory http2 = <span class="keyword">new</span> HTTP2ServerConnectionFactory(secureConfig);
ALPNServerConnectionFactory alpn = <span class="keyword">new</span> ALPNServerConnectionFactory();
alpn.setDefaultProtocol(https.getProtocol());
ConnectionFactory ssl = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, https.getProtocol());
ServerConnector secureConnector = <span class="keyword">new</span> ServerConnector(server, <span class="integer">1</span>, <span class="integer">1</span>, ssl, alpn, http2, https);
server.addConnector(secureConnector);

<span class="comment">// Second, create the plain connector for HTTP.</span>
HttpConnectionFactory http = <span class="keyword">new</span> HttpConnectionFactory(plainConfig);
ServerConnector plainConnector = <span class="keyword">new</span> ServerConnector(server, <span class="integer">1</span>, <span class="integer">1</span>, http);
server.addConnector(plainConnector);

<span class="comment">// Third, create the connector for HTTP/3.</span>
Path pemWorkDir = Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/pem/dir</span><span class="delimiter">&quot;</span></span>);
ServerQuicConfiguration serverQuicConfig = <span class="keyword">new</span> ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector http3Connector = <span class="keyword">new</span> QuicServerConnector(server, serverQuicConfig, <span class="keyword">new</span> HTTP3ServerConnectionFactory(serverQuicConfig));
server.addConnector(http3Connector);

<span class="comment">// Set up a listener so that when the secure connector starts,</span>
<span class="comment">// it configures the other connectors that have not started yet.</span>
secureConnector.addEventListener(<span class="keyword">new</span> NetworkConnector.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen(NetworkConnector connector)
    {
        <span class="type">int</span> port = connector.getLocalPort();

        <span class="comment">// Configure the plain connector for secure redirects from http to https.</span>
        plainConfig.setSecurePort(port);

        <span class="comment">// Configure the HTTP3 connector port to be the same as HTTPS/HTTP2.</span>
        http3Connector.setPort(port);
    }
});

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-connector-protocol"><a class="anchor" href="#pg-server-http-connector-protocol"></a><a class="link" href="#pg-server-http-connector-protocol">Configuring Protocols</a></h5>
<div class="paragraph">
<p>A server <code>Connector</code> can be configured with one or more <code>ConnectionFactory</code>s, and this list of <code>ConnectionFactory</code>s represents the protocols that the <code>Connector</code> can understand.
If no <code>ConnectionFactory</code> is specified then <code>HttpConnectionFactory</code> is implicitly configured.</p>
</div>
<div class="paragraph">
<p>For each accepted connection, the server <code>Connector</code> asks a <code>ConnectionFactory</code> to create a <code>Connection</code> object that handles the traffic on that connection, parsing and generating bytes for a specific protocol (see <a href="#pg-arch-io">this section</a> for more details about <code>Connection</code> objects).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can listen for <code>Connection</code> open and close events as detailed in <a href="#pg-arch-io-connection-listener">this section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Secure protocols like secure HTTP/1.1, secure HTTP/2 or HTTP/3 (HTTP/3 is intrinsically secure&#8201;&#8212;&#8201;there is no clear-text HTTP/3) require an <code>SslContextFactory.Server</code> to be configured with a KeyStore.</p>
</div>
<div class="paragraph">
<p>For HTTP/1.1 and HTTP/2, <code>SslContextFactory.Server</code> is used in conjunction with <code>SSLEngine</code>, which drives the TLS handshake that establishes the secure communication.</p>
</div>
<div class="paragraph">
<p>Applications may register a <code>org.eclipse.jetty.io.ssl.SslHandshakeListener</code> to be notified of TLS handshakes success or failure, by adding the <code>SslHandshakeListener</code> as a bean to the <code>Connector</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a SslHandshakeListener.</span>
SslHandshakeListener listener = <span class="keyword">new</span> SslHandshakeListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> handshakeSucceeded(<span class="predefined-type">Event</span> event) <span class="directive">throws</span> <span class="exception">SSLException</span>
    {
        <span class="predefined-type">SSLEngine</span> sslEngine = event.getSSLEngine();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">tls</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">TLS handshake successful to %s</span><span class="delimiter">&quot;</span></span>, sslEngine.getPeerHost());
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> handshakeFailed(<span class="predefined-type">Event</span> event, <span class="predefined-type">Throwable</span> failure)
    {
        <span class="predefined-type">SSLEngine</span> sslEngine = event.getSSLEngine();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">tls</span><span class="delimiter">&quot;</span></span>).log(ERROR, <span class="string"><span class="delimiter">&quot;</span><span class="content">TLS handshake failure to %s</span><span class="delimiter">&quot;</span></span>, sslEngine.getPeerHost(), failure);
    }
};

Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Add the SslHandshakeListener as bean to ServerConnector.</span>
<span class="comment">// The listener will be notified of TLS handshakes success and failure.</span>
connector.addBean(listener);</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-http11"><a class="anchor" href="#pg-server-http-connector-protocol-http11"></a><a class="link" href="#pg-server-http-connector-protocol-http11">Clear-Text HTTP/1.1</a></h6>
<div class="paragraph">
<p><code>HttpConnectionFactory</code> creates <code>HttpConnection</code> objects that parse bytes and generate bytes for the HTTP/1.1 protocol.</p>
</div>
<div class="paragraph">
<p>This is how you configure Jetty to support clear-text HTTP/1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
<span class="comment">// Configure the HTTP support, for example:</span>
httpConfig.setSendServerVersion(<span class="predefined-constant">false</span>);

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// Create the ServerConnector.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, http11);
connector.setPort(<span class="integer">8080</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-http11-tls"><a class="anchor" href="#pg-server-http-connector-protocol-http11-tls"></a><a class="link" href="#pg-server-http-connector-protocol-http11-tls">Encrypted HTTP/1.1 (https)</a></h6>
<div class="paragraph">
<p>Supporting encrypted HTTP/1.1 (that is, requests with the <code>https</code> scheme) is supported by configuring an <code>SslContextFactory</code> that has access to the KeyStore containing the private server key and public server certificate, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
<span class="comment">// Add the SecureRequestCustomizer because TLS is used.</span>
httpConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// Configure the SslContextFactory with the keyStore information.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The ConnectionFactory for TLS.</span>
SslConnectionFactory tls = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, http11.getProtocol());

<span class="comment">// The ServerConnector instance.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, tls, http11);
connector.setPort(<span class="integer">8443</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#pg-server-http-connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-http2"><a class="anchor" href="#pg-server-http-connector-protocol-http2"></a><a class="link" href="#pg-server-http-connector-protocol-http2">Clear-Text HTTP/2</a></h6>
<div class="paragraph">
<p>It is well known that the HTTP ports are <code>80</code> (for clear-text HTTP) and <code>443</code> for encrypted HTTP.
By using those ports, a client had <em>prior knowledge</em> that the server would speak, respectively, the HTTP/1.x protocol and the TLS protocol (and, after decryption, the HTTP/1.x protocol).</p>
</div>
<div class="paragraph">
<p>HTTP/2 was designed to be a smooth transition from HTTP/1.1 for users and as such the HTTP ports were not changed.
However the HTTP/2 protocol is, on the wire, a binary protocol, completely different from HTTP/1.1.
Therefore, with HTTP/2, clients that connect to port <code>80</code> (or to a specific Unix-Domain path) may speak either HTTP/1.1 or HTTP/2, and the server must figure out which version of the HTTP protocol the client is speaking.</p>
</div>
<div class="paragraph">
<p>Jetty can support both HTTP/1.1 and HTTP/2 on the same clear-text port by configuring both the HTTP/1.1 and the HTTP/2 <code>ConnectionFactory</code>s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// The ConnectionFactory for clear-text HTTP/2.</span>
HTTP2CServerConnectionFactory h2c = <span class="keyword">new</span> HTTP2CServerConnectionFactory(httpConfig);

<span class="comment">// The ServerConnector instance.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, http11, h2c);
connector.setPort(<span class="integer">8080</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first HTTP/1.1, then HTTP/2.
This is necessary to support both protocols on the same port: Jetty will start parsing the incoming bytes as HTTP/1.1, but then realize that they are HTTP/2 bytes and will therefore <em>upgrade</em> from HTTP/1.1 to HTTP/2.</p>
</div>
<div class="paragraph">
<p>This configuration is also typical when Jetty is installed in backend servers behind a load balancer that also takes care of offloading TLS.
When Jetty is behind a load balancer, you can always prepend the PROXY protocol as described in <a href="#pg-server-http-connector-protocol-proxy-http11">this section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-http2-tls"><a class="anchor" href="#pg-server-http-connector-protocol-http2-tls"></a><a class="link" href="#pg-server-http-connector-protocol-http2-tls">Encrypted HTTP/2</a></h6>
<div class="paragraph">
<p>When using encrypted HTTP/2, the unencrypted protocol is negotiated by client and server using an extension to the TLS protocol called ALPN.</p>
</div>
<div class="paragraph">
<p>Jetty supports ALPN and encrypted HTTP/2 with this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
<span class="comment">// Add the SecureRequestCustomizer because TLS is used.</span>
httpConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// The ConnectionFactory for HTTP/2.</span>
HTTP2ServerConnectionFactory h2 = <span class="keyword">new</span> HTTP2ServerConnectionFactory(httpConfig);

<span class="comment">// The ALPN ConnectionFactory.</span>
ALPNServerConnectionFactory alpn = <span class="keyword">new</span> ALPNServerConnectionFactory();
<span class="comment">// The default protocol to use in case there is no negotiation.</span>
alpn.setDefaultProtocol(http11.getProtocol());

<span class="comment">// Configure the SslContextFactory with the keyStore information.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The ConnectionFactory for TLS.</span>
SslConnectionFactory tls = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, alpn.getProtocol());

<span class="comment">// The ServerConnector instance.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, tls, alpn, h2, http11);
connector.setPort(<span class="integer">8443</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: TLS, ALPN, HTTP/2, HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>Jetty starts parsing TLS bytes so that it can obtain the ALPN extension.
With the ALPN extension information, Jetty can negotiate a protocol and pick, among the <code>ConnectionFactory</code>s supported by the <code>ServerConnector</code>, the <code>ConnectionFactory</code> correspondent to the negotiated protocol.</p>
</div>
<div class="paragraph">
<p>The fact that the HTTP/2 protocol comes before the HTTP/1.1 protocol indicates that HTTP/2 is the preferred protocol for the server.</p>
</div>
<div class="paragraph">
<p>Note also that the default protocol set in the ALPN <code>ConnectionFactory</code>, which is used in case ALPN is not supported by the client, is HTTP/1.1&#8201;&#8212;&#8201;if the client does not support ALPN is probably an old client so HTTP/1.1 is the safest choice.</p>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#pg-server-http-connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-http3"><a class="anchor" href="#pg-server-http-connector-protocol-http3"></a><a class="link" href="#pg-server-http-connector-protocol-http3">HTTP/3</a></h6>
<div class="paragraph">
<p>The HTTP/3 protocol is layered on top of the <a href="https://datatracker.ietf.org/doc/html/rfc9000">QUIC</a> protocol, which is based on UDP.
This is rather different with respect to HTTP/1 and HTTP/2, that are based on TCP.</p>
</div>
<div class="paragraph">
<p>Jetty only implements the HTTP/3 layer in Java; the QUIC implementation is provided by the <a href="https://github.com/cloudflare/quiche">Quiche</a> native library, that Jetty calls via <a href="https://github.com/java-native-access/jna">JNA</a> (and possibly, in the future, via the <a href="https://openjdk.org/jeps/454">Foreign APIs</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jetty&#8217;s HTTP/3 support can only be used on the platforms (OS and CPU) supported by the Quiche native library.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>HTTP/3 clients may not know in advance if the server supports QUIC (over UDP), but the server typically supports either HTTP/1 or HTTP/2 (over TCP) on the default HTTP secure port <code>443</code>, and advertises the availability HTTP/3 as an <a href="https://datatracker.ietf.org/doc/html/rfc7838"><em>HTTP alternate service</em></a>, possibly on a different port and/or on a different host.</p>
</div>
<div class="paragraph">
<p>For example, an HTTP/2 response may include the following header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code>Alt-Svc: h3=&quot;:843&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The presence of this header indicates that protocol <code>h3</code> is available on the same host (since no host is defined before the port), but on port <code>843</code> (although it may be the same port <code>443</code>).
The HTTP/3 client may now initiate a QUIC connection on port <code>843</code> and make HTTP/3 requests.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is nowadays common to use the same port <code>443</code> for both HTTP/2 and HTTP/3. This does not cause problems because HTTP/2 listens on the TCP port <code>443</code>, while QUIC listens on the UDP port <code>443</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is therefore common for HTTP/3 clients to initiate connections using the HTTP/2 protocol over TCP, and if the server supports HTTP/3 switch to HTTP/3 as indicated by the server.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-24a0ef88281611e6f6ebbb9d395e2e68.png" alt="Diagram" width="321" height="250">
</div>
</div>
<div class="paragraph">
<p>The code necessary to configure HTTP/2 is described in <a href="#pg-server-http-connector-protocol-http2-tls">this section</a>.</p>
</div>
<div class="paragraph">
<p>To setup HTTP/3, for example on port <code>843</code>, you need the following code (some of which could be shared with other connectors such as HTTP/2&#8217;s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
httpConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// Create and configure the HTTP/3 connector.</span>
<span class="comment">// It is mandatory to configure the PEM directory.</span>
Path pemWorkDir = Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/pem/dir</span><span class="delimiter">&quot;</span></span>);
ServerQuicConfiguration serverQuicConfig = <span class="keyword">new</span> ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector connector = <span class="keyword">new</span> QuicServerConnector(server, serverQuicConfig, <span class="keyword">new</span> HTTP3ServerConnectionFactory(serverQuicConfig));
connector.setPort(<span class="integer">843</span>);

server.addConnector(connector);

server.start();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The use of the Quiche native library requires the private key and public certificate present in the KeyStore to be exported as PEM files for Quiche to use them.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to configure the PEM directory as shown above.</p>
</div>
<div class="paragraph">
<p>The PEM directory must also be adequately protected using file system permissions, because it stores the private key PEM file.
You want to grant as few permissions as possible, typically the equivalent of POSIX <code>rwx</code> only to the user that runs the Jetty process. Using <code>/tmp</code> or any other directory accessible by any user is not a secure choice.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-tls-conscrypt"><a class="anchor" href="#pg-server-http-connector-protocol-tls-conscrypt"></a><a class="link" href="#pg-server-http-connector-protocol-tls-conscrypt">Using Conscrypt as SSL/TLS Provider</a></h6>
<div class="paragraph">
<p>If not explicitly configured, the TLS implementation is provided by the JDK you are using at runtime.</p>
</div>
<div class="paragraph">
<p>OpenJDK&#8217;s vendors may replace the default TLS provider with their own, but you can also explicitly configure an alternative TLS provider.</p>
</div>
<div class="paragraph">
<p>The standard TLS provider from OpenJDK is implemented in Java (no native code), and its performance is not optimal, both in CPU usage and memory usage.</p>
</div>
<div class="paragraph">
<p>A faster alternative, implemented natively, is Google&#8217;s <a href="https://github.com/google/conscrypt/">Conscrypt</a>, which is built on <a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a>, which is Google&#8217;s fork of <a href="https://www.openssl.org/">OpenSSL</a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As Conscrypt eventually binds to a native library, there is a higher risk that a bug in Conscrypt or in the native library causes a JVM crash, while the Java implementation will not cause a JVM crash.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use Conscrypt as TLS provider, you must have the Conscrypt jar and the Jetty dependency <code>jetty-alpn-conscrypt-server-12.0.10-SNAPSHOT.jar</code> in the class-path or module-path.</p>
</div>
<div class="paragraph">
<p>Then, you must configure the JDK with the Conscrypt provider, and configure Jetty to use the Conscrypt provider, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java"><span class="comment">// Configure the JDK with the Conscrypt provider.</span>
<span class="predefined-type">Security</span>.addProvider(<span class="keyword">new</span> OpenSSLProvider());

SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Configure Jetty's SslContextFactory to use Conscrypt.</span>
sslContextFactory.setProvider(<span class="string"><span class="delimiter">&quot;</span><span class="content">Conscrypt</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-connector-protocol-proxy-http11"><a class="anchor" href="#pg-server-http-connector-protocol-proxy-http11"></a><a class="link" href="#pg-server-http-connector-protocol-proxy-http11">Jetty Behind a Load Balancer</a></h6>
<div class="paragraph">
<p>It is often the case that Jetty receives connections from a load balancer configured to distribute the load among many Jetty backend servers.</p>
</div>
<div class="paragraph">
<p>From the Jetty point of view, all the connections arrive from the load balancer, rather than the real clients, but is possible to configure the load balancer to forward the real client IP address and IP port to the backend Jetty server using the <a href="https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt">PROXY protocol</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The PROXY protocol is widely supported by load balancers such as <a href="http://cbonte.github.io/haproxy-dconv/2.2/configuration.html#5.2-send-proxy">HAProxy</a> (via its <code>send-proxy</code> directive), <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol">Nginx</a>(via its <code>proxy_protocol on</code> directive) and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To support this case, Jetty can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
<span class="comment">// Configure the HTTP support, for example:</span>
httpConfig.setSendServerVersion(<span class="predefined-constant">false</span>);

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// The ConnectionFactory for the PROXY protocol.</span>
ProxyConnectionFactory proxy = <span class="keyword">new</span> ProxyConnectionFactory(http11.getProtocol());

<span class="comment">// Create the ServerConnector.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, proxy, http11);
connector.setPort(<span class="integer">8080</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first PROXY, then HTTP/1.1.
Note also how the PROXY <code>ConnectionFactory</code> needs to know its <em>next</em> protocol (in this example, HTTP/1.1).</p>
</div>
<div class="paragraph">
<p>Each <code>ConnectionFactory</code> is asked to create a <code>Connection</code> object for each accepted TCP connection; the <code>Connection</code> objects will be chained together to handle the bytes, each for its own protocol.
Therefore the <code>ProxyConnection</code> will handle the PROXY protocol bytes and <code>HttpConnection</code> will handle the HTTP/1.1 bytes producing a request object and response object that will be processed by <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>The load balancer may be configured to communicate with Jetty backend servers via Unix-Domain sockets (requires Java 16 or later).
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// The HTTP configuration object.</span>
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
<span class="comment">// Configure the HTTP support, for example:</span>
httpConfig.setSendServerVersion(<span class="predefined-constant">false</span>);

<span class="comment">// The ConnectionFactory for HTTP/1.1.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpConfig);

<span class="comment">// The ConnectionFactory for the PROXY protocol.</span>
ProxyConnectionFactory proxy = <span class="keyword">new</span> ProxyConnectionFactory(http11.getProtocol());

<span class="comment">// Create the ServerConnector.</span>
UnixDomainServerConnector connector = <span class="keyword">new</span> UnixDomainServerConnector(server, proxy, http11);
connector.setUnixDomainPath(Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/jetty.sock</span><span class="delimiter">&quot;</span></span>));

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the only difference when using Unix-Domain sockets is instantiating <code>UnixDomainServerConnector</code> instead of <code>ServerConnector</code> and configuring the Unix-Domain path instead of the IP port.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http-handler"><a class="anchor" href="#pg-server-http-handler"></a><a class="link" href="#pg-server-http-handler">Server Handlers</a></h4>
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Handler</code> is the component that processes incoming HTTP requests and eventually produces HTTP responses.</p>
</div>
<div class="paragraph">
<p><code>Handler</code>s can process the HTTP request themselves, or they can be <code>Handler.Container</code>s that delegate HTTP request processing to one or more contained <code>Handler</code>s.
This allows <code>Handler</code>s to be organized as a tree comprised of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Leaf <code>Handler</code>s that generate a response, complete the <code>Callback</code>, and return <code>true</code> from the <code>handle(...)</code> method.</p>
</li>
<li>
<p>A <code>Handler.Wrapper</code> can be used to form a chain of <code>Handler</code>s where request, response or callback objects may be wrapped in the <code>handle(...)</code> method before being passed down the chain.</p>
</li>
<li>
<p>A <code>Handler.Sequence</code> that contains a sequence of <code>Handler</code>s, with each <code>Handler</code> being called in sequence until one returns <code>true</code> from its <code>handle(...)</code> method.</p>
</li>
<li>
<p>A specialized <code>Handler.Container</code> that may use properties of the request (for example, the URI, or a header, etc.) to select from one or more contained <code>Handler</code>s to delegate the HTTP request processing to, for example <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/PathMappingsHandler.html"><code>PathMappingsHandler</code></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>Handler</code> tree is created by composing <code>Handler</code>s together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

GzipHandler gzipHandler = <span class="keyword">new</span> GzipHandler();
server.setHandler(gzipHandler);

<span class="predefined-type">Handler</span>.Sequence sequence = <span class="keyword">new</span> <span class="predefined-type">Handler</span>.Sequence();
gzipHandler.setHandler(sequence);

sequence.addHandler(<span class="keyword">new</span> App1Handler());
sequence.addHandler(<span class="keyword">new</span> App2Handler());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── GzipHandler
    └── Handler.Sequence
        ├── App1Handler
        └── App2Handler</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should prefer using existing <code>Handler</code>s provided by the Jetty server libraries for managing web application contexts, security, HTTP sessions and Servlet support.
Refer to <a href="#pg-server-http-handler-use">this section</a> for more information about how to use the <code>Handler</code>s provided by the Jetty server libraries.</p>
</div>
<div class="paragraph">
<p>You should write your own leaf <code>Handler</code>s to implement your web application logic.
Refer to <a href="#pg-server-http-handler-impl">this section</a> for more information about how to write your own <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>A <code>Handler</code> may be declared as non-blocking (by extending <code>Handler.Abstract.NonBlocking</code>) or as blocking (by extending <code>Handler.Abstract</code>), to allow interaction with the <a href="#pg-arch-threads">Jetty threading architecture</a> for more efficient thread and CPU utilization during the request/response processing.</p>
</div>
<div class="paragraph">
<p>Container <code>Handler</code>s typically inherit whether they are blocking or non-blocking from their child or children.</p>
</div>
<div class="paragraph">
<p>Furthermore, container <code>Handler</code>s may be declared as dynamic: they allow adding/removing child <code>Handler</code>s after they have been started (see <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Handler.AbstractContainer.html">Handler.AbstractContainer</a> for more information).
Dynamic container <code>Handler</code>s are therefore always blocking, as it is not possible to know if a child <code>Handler</code> added in the future will be blocking or non-blocking.</p>
</div>
<div class="paragraph">
<p>If the <code>Handler</code> tree is not dynamic, then it is possible to create a non-blocking <code>Handler</code> tree, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── RewriteHandler
    └── GzipHandler
        └── ContextHandler
            └── AppHandler extends Handler.Abstract.NonBlocking</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>Handler</code> tree is non-blocking, Jetty may use the <a href="#pg-arch-threads-execution-strategy-pc"><code>Produce-Consume</code></a> mode to invoke the <code>Handler</code> tree, therefore avoiding a thread hand-off, and saving the cost of being scheduled on a different CPU with cold caches.</p>
</div>
<div class="paragraph">
<p>The <code>Produce-Consume</code> mode is equivalent to what other servers call "event loop" or "selector thread loop" architectures.</p>
</div>
<div class="paragraph">
<p>This mode has the benefit of reducing OS context switches and CPU cache misses, using fewer threads, and it is overall very efficient.
On the other hand, it requires writing quick, non-blocking code, and partially sequentializes the request/response processing, so that the Nth request in the sequence pays the latency of the processing of the N-1 requests in front of it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you declare your <code>Handler</code> to be non-blocking by extending <code>Handler.Abstract.NonBlocking</code>, the code you write in <code>handle(...)</code> (and recursively all the code called from there) must truly be non-blocking, and possibly execute quickly.</p>
</div>
<div class="paragraph">
<p>If the code blocks, you risk a server lock-up.
If the code takes a long time to execute, requests from other connections may be delayed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="pg-server-http-handler-use"><a class="anchor" href="#pg-server-http-handler-use"></a><a class="link" href="#pg-server-http-handler-use">Jetty Handlers</a></h5>
<div class="paragraph">
<p>Web applications are the unit of deployment in an HTTP server or Servlet container such as Jetty.</p>
</div>
<div class="paragraph">
<p>Two different web applications are typically deployed on different <em>context path</em>s, where a <em>context path</em> is the initial segment of the URI path.
For example, web application <code>webappA</code> that implements a web user interface for an e-commerce site may be deployed to context path <code>/shop</code>, while web application <code>webappB</code> that implements a REST API for the e-commerce business may be deployed to <code>/api</code>.</p>
</div>
<div class="paragraph">
<p>A client making a request to URI <code>/shop/cart</code> is directed by Jetty to <code>webappA</code>, while a request to URI <code>/api/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>An alternative way to deploy the two web applications of the example above is to use <em>virtual hosts</em>.
A <em>virtual host</em> is a subdomain of the primary domain that shares the same IP address with the primary domain.
If the e-commerce business primary domain is <code>domain.com</code>, then a virtual host for <code>webappA</code> could be <code>shop.domain.com</code>, while a virtual host for <code>webappB</code> could be <code>api.domain.com</code>.</p>
</div>
<div class="paragraph">
<p>Web application <code>webappA</code> can now be deployed to virtual host <code>shop.domain.com</code> and context path <code>/</code>, while web application <code>webappB</code> can be deployed to virtual host <code>api.domain.com</code> and context path <code>/</code>.
Both applications have the same context path <code>/</code>, but they can be distinguished by the subdomain.</p>
</div>
<div class="paragraph">
<p>A client making a request to <code>https://shop.domain.com/cart</code> is directed by Jetty to <code>webappA</code>, while a request to <code>https://api.domain.com/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, in general, a web application is deployed to a <em>context</em> which can be seen as the pair <code>(virtual_host, context_path)</code>.
In the first case the contexts were <code>(domain.com, /shop)</code> and <code>(domain.com, /api)</code>, while in the second case the contexts were <code>(shop.domain.com, /)</code> and <code>(api.domain.com, /)</code>.
Server applications using the Jetty Server Libraries create and configure a <em>context</em> for each web application.
Many <em>context</em>s can be deployed together to enrich the web application offering&#8201;&#8212;&#8201;for example a catalog context, a shop context, an API context, an administration context, etc.</p>
</div>
<div class="paragraph">
<p>Web applications can be written using exclusively the Servlet APIs, since developers know well the Servlet API and because they guarantee better portability across Servlet container implementations, as described in <a href="#pg-server-http-handler-use-servlet">this section</a>.</p>
</div>
<div class="paragraph">
<p>On the other hand, web applications can be written using the Jetty APIs, for better performance, or to be able to  access to Jetty specific APIs, or to use features such as redirection from HTTP to HTTPS, support for <code>gzip</code> content compression, URI rewriting, etc.
The Jetty Server Libraries provides a number of out-of-the-box <code>Handler</code>s that implement the most common functionalities and are described in the next sections.</p>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-context"><a class="anchor" href="#pg-server-http-handler-use-context"></a><a class="link" href="#pg-server-http-handler-use-context">ContextHandler</a></h6>
<div class="paragraph">
<p><code>ContextHandler</code> is a <code>Handler</code> that represents a <em>context</em> for a web application.
It is a <code>Handler.Wrapper</code> that performs some action before and after delegating to the nested <code>Handler</code>.</p>
</div>
<div class="paragraph">
<p>The simplest use of <code>ContextHandler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ShopHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Implement the shop, remembering to complete the callback.</span>
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create a ContextHandler with contextPath.</span>
ContextHandler context = <span class="keyword">new</span> ContextHandler(<span class="keyword">new</span> ShopHandler(), <span class="string"><span class="delimiter">&quot;</span><span class="content">/shop</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Link the context to the server.</span>
server.setHandler(context);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── ContextHandler /shop
    └── ShopHandler</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-context-collection"><a class="anchor" href="#pg-server-http-handler-use-context-collection"></a><a class="link" href="#pg-server-http-handler-use-context-collection">ContextHandlerCollection</a></h6>
<div class="paragraph">
<p>Server applications may need to deploy to Jetty more than one web application.</p>
</div>
<div class="paragraph">
<p>Recall from the <a href="#pg-server-http-handler">introduction</a> that Jetty offers <code>Handler.Collection</code> that contains a sequence of child <code>Handler</code>s.
However, this has no knowledge of the concept of <em>context</em> and just iterates through the sequence of <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>A better choice for multiple web application is <code>ContextHandlerCollection</code>, that matches a <em>context</em> from either its <em>context path</em> or <em>virtual host</em>, without iterating through the <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If <code>ContextHandlerCollection</code> does not find a match, it just returns <code>false</code> from its <code>handle(...)</code> method.
What happens next depends on the <code>Handler</code> tree structure: other <code>Handler</code>s may be invoked after <code>ContextHandlerCollection</code>, for example <code>DefaultHandler</code> (see <a href="#pg-server-http-handler-use-default">this section</a>).
Eventually, if no <code>Handler</code> returns <code>true</code> from their own <code>handle(...)</code> method, then Jetty returns an HTTP <code>404</code> response to the client.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ShopHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Implement the shop, remembering to complete the callback.</span>
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

<span class="type">class</span> <span class="class">RESTHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Implement the REST APIs, remembering to complete the callback.</span>
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();

<span class="comment">// Create the context for the shop web application and add it to ContextHandlerCollection.</span>
contextCollection.addHandler(<span class="keyword">new</span> ContextHandler(<span class="keyword">new</span> ShopHandler(), <span class="string"><span class="delimiter">&quot;</span><span class="content">/shop</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// Link the ContextHandlerCollection to the Server.</span>
server.setHandler(contextCollection);

server.start();

<span class="comment">// Create the context for the API web application.</span>
ContextHandler apiContext = <span class="keyword">new</span> ContextHandler(<span class="keyword">new</span> RESTHandler(), <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Web applications can be deployed after the Server is started.</span>
contextCollection.deployHandler(apiContext, <span class="predefined-type">Callback</span>.NOOP);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── ContextHandlerCollection
    ├── ContextHandler /shop
    │   └── ShopHandler
    └── ContextHandler /api
        └── RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-resource"><a class="anchor" href="#pg-server-http-handler-use-resource"></a><a class="link" href="#pg-server-http-handler-use-resource">ResourceHandler&#8201;&#8212;&#8201;Static Content</a></h6>
<div class="paragraph">
<p>Static content such as images or files (HTML, JavaScript, CSS) can be sent by Jetty very efficiently because Jetty can write the content asynchronously, using direct <code>ByteBuffer</code>s to minimize data copy, and using a memory cache for faster access to the data to send.</p>
</div>
<div class="paragraph">
<p>Being able to write content asynchronously means that if the network gets congested (for example, the client reads the content very slowly) and the server stalls the send of the requested data, then Jetty will wait to resume the send <em>without</em> blocking a thread to finish the send.</p>
</div>
<div class="paragraph">
<p><code>ResourceHandler</code> supports the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Welcome files, for example serving <code>/index.html</code> for request URI <code>/</code></p>
</li>
<li>
<p>Precompressed resources, serving a precompressed <code>/document.txt.gz</code> for request URI <code>/document.txt</code></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7233">Range requests</a>, for requests containing the <code>Range</code> header, which allows clients to pause and resume downloads of large files</p>
</li>
<li>
<p>Directory listing, serving a HTML page with the file list of the requested directory</p>
</li>
<li>
<p>Conditional headers, for requests containing the <code>If-Match</code>, <code>If-None-Match</code>, <code>If-Modified-Since</code>, <code>If-Unmodified-Since</code> headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of features supported and the efficiency in sending static content are on the same level as those of common front-end servers used to serve static content such as Nginx or Apache.
Therefore, the traditional architecture where Nginx/Apache was the front-end server used only to send static content and Jetty was the back-end server used only to send dynamic content is somehow obsolete as Jetty can perform efficiently both tasks.
This leads to simpler systems (less components to configure and manage) and more performance (no need to proxy dynamic requests from front-end servers to back-end servers).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is common to use Nginx/Apache as load balancers, or as rewrite/redirect servers.
We typically recommend <a href="https://haproxy.org">HAProxy</a> as load balancer, and Jetty has <a href="#pg-server-http-handler-use-rewrite">rewrite/redirect features</a> as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is how you configure a <code>ResourceHandler</code> to create a simple file server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and configure a ResourceHandler.</span>
ResourceHandler handler = <span class="keyword">new</span> ResourceHandler();
<span class="comment">// Configure the directory where static resources are located.</span>
handler.setBaseResource(ResourceFactory.of(handler).newResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/static/resources/</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Configure directory listing.</span>
handler.setDirAllowed(<span class="predefined-constant">false</span>);
<span class="comment">// Configure welcome files.</span>
handler.setWelcomeFiles(<span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">index.html</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Configure whether to accept range requests.</span>
handler.setAcceptRanges(<span class="predefined-constant">true</span>);

<span class="comment">// Link the context to the server.</span>
server.setHandler(handler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to serve static resources from multiple directories:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ResourceHandler handler = <span class="keyword">new</span> ResourceHandler();

<span class="comment">// For multiple directories, use ResourceFactory.combine().</span>
Resource resource = ResourceFactory.combine(
    ResourceFactory.of(handler).newResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/static/resources/</span><span class="delimiter">&quot;</span></span>),
    ResourceFactory.of(handler).newResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/another/path/to/static/resources/</span><span class="delimiter">&quot;</span></span>)
);
handler.setBaseResource(resource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the resource is not found, <code>ResourceHandler</code> will not return <code>true</code> from the <code>handle(...)</code> method, so what happens next depends on the <code>Handler</code> tree structure.
See also <a href="#pg-server-http-handler-use-default">how to use</a> <code>DefaultHandler</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-gzip"><a class="anchor" href="#pg-server-http-handler-use-gzip"></a><a class="link" href="#pg-server-http-handler-use-gzip">GzipHandler</a></h6>
<div class="paragraph">
<p><code>GzipHandler</code> provides supports for automatic decompression of compressed request content and automatic compression of response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> is a <code>Handler.Wrapper</code> that inspects the request and, if the request matches the <code>GzipHandler</code> configuration, just installs the required components to eventually perform decompression of the request content or compression of the response content.
The decompression/compression is not performed until the web application reads request content or writes response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> can be configured at the server level in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and configure GzipHandler.</span>
GzipHandler gzipHandler = <span class="keyword">new</span> GzipHandler();
server.setHandler(gzipHandler);
<span class="comment">// Only compress response content larger than this.</span>
gzipHandler.setMinGzipSize(<span class="integer">1024</span>);
<span class="comment">// Do not compress these URI paths.</span>
gzipHandler.setExcludedPaths(<span class="string"><span class="delimiter">&quot;</span><span class="content">/uncompressed</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Also compress POST responses.</span>
gzipHandler.addIncludedMethods(<span class="string"><span class="delimiter">&quot;</span><span class="content">POST</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Do not compress these mime types.</span>
gzipHandler.addExcludedMimeTypes(<span class="string"><span class="delimiter">&quot;</span><span class="content">font/ttf</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create a ContextHandlerCollection to manage contexts.</span>
ContextHandlerCollection contexts = <span class="keyword">new</span> ContextHandlerCollection();
gzipHandler.setHandler(contexts);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── GzipHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in less common cases, you can configure <code>GzipHandler</code> on a per-context basis, for example because you want to configure <code>GzipHandler</code> with different parameters for each context, or because you want only some contexts to have compression support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();
<span class="comment">// Link the ContextHandlerCollection to the Server.</span>
server.setHandler(contextCollection);

<span class="comment">// Create the context for the shop web application wrapped with GzipHandler so only the shop will do gzip.</span>
GzipHandler shopGzipHandler = <span class="keyword">new</span> GzipHandler(<span class="keyword">new</span> ContextHandler(<span class="keyword">new</span> ShopHandler(), <span class="string"><span class="delimiter">&quot;</span><span class="content">/shop</span><span class="delimiter">&quot;</span></span>));

<span class="comment">// Add it to ContextHandlerCollection.</span>
contextCollection.addHandler(shopGzipHandler);

<span class="comment">// Create the context for the API web application.</span>
ContextHandler apiContext = <span class="keyword">new</span> ContextHandler(<span class="keyword">new</span> RESTHandler(), <span class="string"><span class="delimiter">&quot;</span><span class="content">/api</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add it to ContextHandlerCollection.</span>
contextCollection.addHandler(apiContext);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── ContextHandlerCollection
    └── ContextHandlerCollection
        ├── GzipHandler
        │   └── ContextHandler /shop
        │       └── ShopHandler
        └── ContextHandler /api
            └── RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-rewrite"><a class="anchor" href="#pg-server-http-handler-use-rewrite"></a><a class="link" href="#pg-server-http-handler-use-rewrite">RewriteHandler</a></h6>
<div class="paragraph">
<p><code>RewriteHandler</code> provides support for URL rewriting, very similarly to <a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html">Apache&#8217;s mod_rewrite</a> or <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html">Nginx rewrite module</a>.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-rewrite<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RewriteHandler</code> can be configured with a set of <em>rule</em>s; a <em>rule</em> inspects the request and when it matches it performs some change to the request (for example, changes the URI path, adds/removes headers, etc.).</p>
</div>
<div class="paragraph">
<p>The Jetty Server Libraries provide rules for the most common usages, but you can write your own rules by extending the <code>org.eclipse.jetty.rewrite.handler.Rule</code> class.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>jetty-rewrite</code> module <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/rewrite/handler/package-summary.html">javadocs</a> for the complete list of available rules.</p>
</div>
<div class="paragraph">
<p>You typically want to configure <code>RewriteHandler</code> at the server level, although it is possible to configure it on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and link the RewriteHandler to the Server.</span>
RewriteHandler rewriteHandler = <span class="keyword">new</span> RewriteHandler();
server.setHandler(rewriteHandler);

<span class="comment">// Compacts URI paths with double slashes, e.g. /ctx//path/to//resource.</span>
rewriteHandler.addRule(<span class="keyword">new</span> CompactPathRule());
<span class="comment">// Rewrites */products/* to */p/*.</span>
rewriteHandler.addRule(<span class="keyword">new</span> RewriteRegexRule(<span class="string"><span class="delimiter">&quot;</span><span class="content">/(.*)/product/(.*)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/$1/p/$2</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Redirects permanently to a different URI.</span>
RedirectRegexRule redirectRule = <span class="keyword">new</span> RedirectRegexRule(<span class="string"><span class="delimiter">&quot;</span><span class="content">/documentation/(.*)</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">https://docs.domain.com/$1</span><span class="delimiter">&quot;</span></span>);
redirectRule.setStatusCode(HttpStatus.MOVED_PERMANENTLY_301);
rewriteHandler.addRule(redirectRule);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();
rewriteHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── RewriteHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-sizelimit"><a class="anchor" href="#pg-server-http-handler-use-sizelimit"></a><a class="link" href="#pg-server-http-handler-use-sizelimit">SizeLimitHandler</a></h6>
<div class="paragraph">
<p><code>SizeLimitHandler</code> tracks the sizes of request content and response content, and fails the request processing with an HTTP status code of <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-large"><code>413 Content Too Large</code></a>.</p>
</div>
<div class="paragraph">
<p>Server applications can set up the <code>SizeLimitHandler</code> before or after handlers that modify the request content or response content such as <a href="#pg-server-http-handler-use-gzip"><code>GzipHandler</code></a>.
When <code>SizeLimitHandler</code> is before <code>GzipHandler</code> in the <code>Handler</code> tree, it will limit the compressed content; when it is after, it will limit the uncompressed content.</p>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure look like the following, to limit uncompressed content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── GzipHandler
    └── SizeLimitHandler
        └── ContextHandlerCollection
            ├── ContextHandler 1
            :── ...
            └── ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-statistics"><a class="anchor" href="#pg-server-http-handler-use-statistics"></a><a class="link" href="#pg-server-http-handler-use-statistics">StatisticsHandler</a></h6>
<div class="paragraph">
<p><code>StatisticsHandler</code> gathers and exposes a number of statistic values related to request processing such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total number of requests</p>
</li>
<li>
<p>Current number of concurrent requests</p>
</li>
<li>
<p>Minimum, maximum, average and standard deviation of request processing times</p>
</li>
<li>
<p>Number of responses grouped by HTTP code (i.e. how many <code>2xx</code> responses, how many <code>3xx</code> responses, etc.)</p>
</li>
<li>
<p>Total response content bytes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Server applications can read these values and use them internally, or expose them via some service, or <a href="#pg-arch-jmx">export them to JMX</a>.</p>
</div>
<div class="paragraph">
<p><code>StatisticsHandler</code> can be configured at the server level or at the context level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and link the StatisticsHandler to the Server.</span>
StatisticsHandler statsHandler = <span class="keyword">new</span> StatisticsHandler();
server.setHandler(statsHandler);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();
statsHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── StatisticsHandler
    └── ContextHandlerCollection
        ├── ContextHandler 1
        :── ...
        └── ContextHandler N</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to act on those statistics by subclassing <code>StatisticsHandler</code>.
For instance, <code>StatisticsHandler.MinimumDataRateHandler</code> can be used to enforce a minimum read rate and a minimum write rate based of the figures collected by the <code>StatisticsHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and link the MinimumDataRateHandler to the Server.</span>
<span class="comment">// Create the MinimumDataRateHandler with a minimum read rate of 1KB per second and no minimum write rate.</span>
StatisticsHandler.MinimumDataRateHandler dataRateHandler = <span class="keyword">new</span> StatisticsHandler.MinimumDataRateHandler(<span class="integer">1024L</span>, <span class="integer">0L</span>);
server.setHandler(dataRateHandler);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();
dataRateHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-events"><a class="anchor" href="#pg-server-http-handler-use-events"></a><a class="link" href="#pg-server-http-handler-use-events">EventsHandler</a></h6>
<div class="paragraph">
<p><code>EventsHandler</code> allows applications to be notified of <a href="#pg-server-http-request-processing-events">request processing</a> events.</p>
</div>
<div class="paragraph">
<p><code>EventsHandler</code> must be subclassed, and the relevant <code>onXYZ()</code> methods overridden to capture the request processing events you are interested in.
The request processing events can be used in conjunction with <code>Request</code> APIs that provide the information you may be interested in.</p>
</div>
<div class="paragraph">
<p>For example, if you want to use <code>EventsHandler</code> to record processing times, you can use the request processing events with the following <code>Request</code> APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Request.getBeginNanoTime()</code>, which returns the earliest possible nanoTime the request was received.</p>
</li>
<li>
<p><code>Request.getHeadersNanoTime()</code>, which returns the nanoTime at which the parsing of the HTTP headers was completed.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Request</code> and <code>Response</code> objects may be inspected during events, but it is recommended to avoid modifying them, for example by adding/removing headers or by reading/writing content, because any modification may interfere with the processing performed by other <code>Handler</code>s.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EventsHandler</code> emits the following events:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>beforeHandling</code></dt>
<dd>
<p>Emitted just before <code>EventsHandler</code> invokes the <code>Handler.handle(...)</code> method of the next <code>Handler</code> in the <code>Handler</code> tree.</p>
</dd>
<dt class="hdlist1"><code>afterHandling</code></dt>
<dd>
<p>Emitted just after the invocation to the <code>Handler.handle(...)</code> method of the next <code>Handler</code> in the <code>Handler</code> tree returns, either normally or by throwing.</p>
</dd>
<dt class="hdlist1"><code>requestRead</code></dt>
<dd>
<p>Emitted every time a chunk of content is read from the <code>Request</code>.</p>
</dd>
<dt class="hdlist1"><code>responseBegin</code></dt>
<dd>
<p>Emitted when the response first write happens.</p>
</dd>
<dt class="hdlist1"><code>responseWrite</code></dt>
<dd>
<p>Emitted every time the write of some response content is initiated.</p>
</dd>
<dt class="hdlist1"><code>responseWriteComplete</code></dt>
<dd>
<p>Emitted every time the write of some response content is completed, either successfully or with a failure.</p>
</dd>
<dt class="hdlist1"><code>responseTrailersComplete</code></dt>
<dd>
<p>Emitted when the write of the response trailers is completed.</p>
</dd>
<dt class="hdlist1"><code>complete</code></dt>
<dd>
<p>Emitted when both request and the response have been completely processed.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Your <code>EventsHandler</code> subclass should then be linked in the <code>Handler</code> tree in the relevant position, typically as the outermost <code>Handler</code> after <code>Server</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyEventsHandler</span> <span class="directive">extends</span> EventsHandler
{
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onBeforeHandling(Request request)
    {
        <span class="comment">// The nanoTime at which the request is first received.</span>
        <span class="type">long</span> requestBeginNanoTime = request.getBeginNanoTime();

        <span class="comment">// The nanoTime just before invoking the next Handler.</span>
        request.setAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeHandlingNanoTime</span><span class="delimiter">&quot;</span></span>, NanoTime.now());
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onComplete(Request request, <span class="type">int</span> status, HttpFields headers, <span class="predefined-type">Throwable</span> failure)
    {
        <span class="comment">// Retrieve the before handling nanoTime.</span>
        <span class="type">long</span> beforeHandlingNanoTime = (<span class="type">long</span>)request.getAttribute(<span class="string"><span class="delimiter">&quot;</span><span class="content">beforeHandlingNanoTime</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Record the request processing time and the status that was sent back to the client.</span>
        <span class="type">long</span> processingTime = NanoTime.millisSince(beforeHandlingNanoTime);
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">trackTime</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">processing request %s took %d ms and ended with status code %d</span><span class="delimiter">&quot;</span></span>, request, processingTime, status);
    }
}

Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Link the EventsHandler as the outermost Handler after Server.</span>
MyEventsHandler eventsHandler = <span class="keyword">new</span> MyEventsHandler();
server.setHandler(eventsHandler);

ContextHandler appHandler = <span class="keyword">new</span> ContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app</span><span class="delimiter">&quot;</span></span>);
eventsHandler.setHandler(appHandler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── MyEventsHandler
    └── ContextHandler /app</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can link the <code>EventsHandler</code> at any point in the <code>Handler</code> tree structure, and even have multiple <code>EventsHandler</code>s to be notified of the request processing events at the different stages of the <code>Handler</code> tree, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── TotalEventsHandler
    └── SlowHandler
        └── AppEventsHandler
            └── ContextHandler /app</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>TotalEventsHandler</code> may record the total times of request processing, from <code>SlowHandler</code> all the way to the <code>ContextHandler</code>.
On the other hand, <code>AppEventsHandler</code> may record both the time it takes for the request to flow from <code>TotalEventsHandler</code> to <code>AppEventsHandler</code>, therefore effectively measuring the processing time due to <code>SlowHandler</code>, and the time it takes to process the request by the <code>ContextHandler</code>.</p>
</div>
<div class="paragraph">
<p>Refer to the <code>EventsHandler</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/EventsHandler.html">javadocs</a> for further information.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-qos"><a class="anchor" href="#pg-server-http-handler-use-qos"></a><a class="link" href="#pg-server-http-handler-use-qos">QoSHandler</a></h6>
<div class="paragraph">
<p><code>QoSHandler</code> allows web applications to limit the number of concurrent requests, therefore implementing a quality of service (QoS) mechanism for end users.</p>
</div>
<div class="paragraph">
<p>Web applications may need to access resources with limited capacity, for example a relational database accessed through a JDBC connection pool.</p>
</div>
<div class="paragraph">
<p>Consider the case where each HTTP request results in a JDBC query, and the capacity of the database is of 400 queries/s.
Allowing more than 400 HTTP requests/s into the system, for example 500 requests/s, results in 100 requests blocking waiting for a JDBC connection <em>for every second</em>.
It is evident that even a short load spike of few seconds eventually results in consuming all the server threads: some will be processing requests and queries, the remaining will be blocked waiting for a JDBC connection.
When no more threads are available, additional requests will queue up as tasks in the thread pool, consuming more memory and potentially causing a complete server failure.
This situation affects the whole server, so one bad behaving web application may affect other well behaving web applications.
From the end user perspective the quality of service is terrible, because requests will take a lot of time to be served and eventually time out.</p>
</div>
<div class="paragraph">
<p>In cases of load spikes, caused for example by popular events (weather or social events), usage bursts (Black Friday sales), or even denial of service attacks, it is desirable to give priority to certain requests rather than others.
For example, in an e-commerce site requests that lead to the checkout and to the payments should have higher priorities than requests to browse the products.
Another example is to prioritize requests for certain users such as paying users or administrative users.</p>
</div>
<div class="paragraph">
<p><code>QoSHandler</code> allows you to configure the maximum number of concurrent requests; by extending <code>QoSHandler</code> you can prioritize suspended requests for faster processing.</p>
</div>
<div class="paragraph">
<p>A simple example that just limits the number of concurrent requests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ShopHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Implement the shop, remembering to complete the callback.</span>
        callback.succeeded();
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

<span class="type">int</span> maxThreads = <span class="integer">256</span>;
QueuedThreadPool serverThreads = <span class="keyword">new</span> QueuedThreadPool(maxThreads);
Server server = <span class="keyword">new</span> Server(serverThreads);
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create and configure QoSHandler.</span>
QoSHandler qosHandler = <span class="keyword">new</span> QoSHandler();
<span class="comment">// Set the max number of concurrent requests,</span>
<span class="comment">// for example in relation to the thread pool.</span>
qosHandler.setMaxRequestCount(maxThreads / <span class="integer">2</span>);
<span class="comment">// A suspended request may stay suspended for at most 15 seconds.</span>
qosHandler.setMaxSuspend(<span class="predefined-type">Duration</span>.ofSeconds(<span class="integer">15</span>));
server.setHandler(qosHandler);

<span class="comment">// Provide quality of service to the shop</span>
<span class="comment">// application by wrapping ShopHandler with QoSHandler.</span>
qosHandler.setHandler(<span class="keyword">new</span> ShopHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of a <code>QoSHandler</code> subclass where you can implement a custom prioritization logic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">PriorityQoSHandler</span> <span class="directive">extends</span> QoSHandler
{
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">int</span> getPriority(Request request)
    {
        <span class="predefined-type">String</span> pathInContext = Request.getPathInContext(request);

        <span class="comment">// Payment requests have the highest priority.</span>
        <span class="keyword">if</span> (pathInContext.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/payment/</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="integer">3</span>;

        <span class="comment">// Login, checkout and admin requests.</span>
        <span class="keyword">if</span> (pathInContext.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/login/</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="integer">2</span>;
        <span class="keyword">if</span> (pathInContext.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/checkout/</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="integer">2</span>;
        <span class="keyword">if</span> (pathInContext.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/admin/</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="integer">2</span>;

        <span class="comment">// Health-check requests from the load balancer.</span>
        <span class="keyword">if</span> (pathInContext.equals(<span class="string"><span class="delimiter">&quot;</span><span class="content">/health-check</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="integer">1</span>;

        <span class="comment">// Other requests have the lowest priority.</span>
        <span class="keyword">return</span> <span class="integer">0</span>;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-secured"><a class="anchor" href="#pg-server-http-handler-use-secured"></a><a class="link" href="#pg-server-http-handler-use-secured">SecuredRedirectHandler&#8201;&#8212;&#8201;Redirect from HTTP to HTTPS</a></h6>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> allows to redirect requests made with the <code>http</code> scheme (and therefore to the clear-text port) to the <code>https</code> scheme (and therefore to the encrypted port).</p>
</div>
<div class="paragraph">
<p>For example a request to <code>http://domain.com:8080/path?param=value</code> is redirected to <code>https://domain.com:8443/path?param=value</code>.</p>
</div>
<div class="paragraph">
<p>Server applications must configure a <code>HttpConfiguration</code> object with the secure scheme and secure port so that <code>SecuredRedirectHandler</code> can build the redirect URI.</p>
</div>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> is typically configured at the server level, although it can be configured on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Configure the HttpConfiguration for the clear-text connector.</span>
<span class="type">int</span> securePort = <span class="integer">8443</span>;
HttpConfiguration httpConfig = <span class="keyword">new</span> HttpConfiguration();
httpConfig.setSecurePort(securePort);

<span class="comment">// The clear-text connector.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, <span class="keyword">new</span> HttpConnectionFactory(httpConfig));
connector.setPort(<span class="integer">8080</span>);
server.addConnector(connector);

<span class="comment">// Configure the HttpConfiguration for the secure connector.</span>
HttpConfiguration httpsConfig = <span class="keyword">new</span> HttpConfiguration(httpConfig);
<span class="comment">// Add the SecureRequestCustomizer because TLS is used.</span>
httpConfig.addCustomizer(<span class="keyword">new</span> SecureRequestCustomizer());

<span class="comment">// The HttpConnectionFactory for the secure connector.</span>
HttpConnectionFactory http11 = <span class="keyword">new</span> HttpConnectionFactory(httpsConfig);

<span class="comment">// Configure the SslContextFactory with the keyStore information.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The ConnectionFactory for TLS.</span>
SslConnectionFactory tls = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, http11.getProtocol());

<span class="comment">// The secure connector.</span>
ServerConnector secureConnector = <span class="keyword">new</span> ServerConnector(server, tls, http11);
secureConnector.setPort(<span class="integer">8443</span>);
server.addConnector(secureConnector);

<span class="comment">// Create and link the SecuredRedirectHandler to the Server.</span>
SecuredRedirectHandler securedHandler = <span class="keyword">new</span> SecuredRedirectHandler();
server.setHandler(securedHandler);

<span class="comment">// Create a ContextHandlerCollection to hold contexts.</span>
ContextHandlerCollection contextCollection = <span class="keyword">new</span> ContextHandlerCollection();
securedHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-cross-origin"><a class="anchor" href="#pg-server-http-handler-use-cross-origin"></a><a class="link" href="#pg-server-http-handler-use-cross-origin">CrossOriginHandler</a></h6>
<div class="paragraph">
<p><code>CrossOriginHandler</code> supports the server-side requirements of the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS protocol</a> implemented by browsers when performing cross-origin requests.</p>
</div>
<div class="paragraph">
<p>An example of a cross-origin request is when a script downloaded from the origin domain <code>http://domain.com</code> uses <code>fetch()</code> or <code>XMLHttpRequest</code> to make a request to a cross domain such as <code>http://cross.domain.com</code> (a subdomain of the origin domain) or to <code>http://example.com</code> (a completely different domain).</p>
</div>
<div class="paragraph">
<p>This is common, for example, when you embed reusable components such as a chat component into a web page: the web page and the chat component files are downloaded from <code>http://domain.com</code>, but the chat server is at <code>http://chat.domain.com</code>, so the chat component must make cross-origin requests to the chat server.</p>
</div>
<div class="paragraph">
<p>This kind of setup exposes to <a href="https://owasp.org/www-community/attacks/csrf">cross-site request forgery (CSRF) attacks</a>, and the CORS protocol has been established to protect against this kind of attacks.</p>
</div>
<div class="paragraph">
<p>For security reasons, browsers by default do not allow cross-origin requests, unless the response from the cross domain contains the right CORS headers.</p>
</div>
<div class="paragraph">
<p><code>CrossOriginHandler</code> relieves server-side web applications from handling CORS headers explicitly.
You can set up your <code>Handler</code> tree with the <code>CrossOriginHandler</code>, configure it, and it will take care of the CORS headers separately from your application, where you can concentrate on the business logic.</p>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── CrossOriginHandler
    └── ContextHandler /app
        └── AppHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most important <code>CrossOriginHandler</code> configuration parameter that must be configured is <code>allowedOrigins</code>, which by default is the empty set, therefore disallowing all origins.</p>
</div>
<div class="paragraph">
<p>You want to restrict requests to your cross domain to only origins you trust.
From the chat example above, the chat server at <code>http://chat.domain.com</code> knows that the chat component is downloaded from the origin server at <code>http://domain.com</code>, so the <code>CrossOriginHandler</code> is configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">CrossOriginHandler crossOriginHandler = <span class="keyword">new</span> CrossOriginHandler();
<span class="comment">// The allowed origins are regex patterns.</span>
crossOriginHandler.setAllowedOriginPatterns(<span class="predefined-type">Set</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain</span><span class="char">\\</span><span class="content">.com</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Browsers send cross-origin requests in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directly, if the cross-origin request meets some simple criteria.</p>
</li>
<li>
<p>By issuing a hidden <em>preflight</em> request before the actual cross-origin request, to verify with the server if it is willing to reply properly to the actual cross-origin request.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both preflight requests and cross-origin requests will be handled by <code>CrossOriginHandler</code>, which will analyze the request and possibly add appropriate CORS response headers.</p>
</div>
<div class="paragraph">
<p>By default, preflight requests are not delivered to the <code>CrossOriginHandler</code> child <code>Handler</code>, but it is possible to configure <code>CrossOriginHandler</code> by setting <code>deliverPreflightRequests=true</code> so that the web application can fine-tune the CORS response headers.</p>
</div>
<div class="paragraph">
<p>Another important <code>CrossOriginHandler</code> configuration parameter is <code>allowCredentials</code>, which controls whether cookies and authentication headers that match the cross-origin request to the cross domain are sent in the cross-origin requests.
By default, <code>allowCredentials=false</code> so that cookies and authentication headers are not sent in cross-origin requests.</p>
</div>
<div class="paragraph">
<p>If the application deployed in the cross domain requires cookies or authentication, then you must set <code>allowCredentials=true</code>, but you also need to restrict the allowed origins only to the ones your trust, otherwise your cross domain application will be vulnerable to CSRF attacks.</p>
</div>
<div class="paragraph">
<p>For more <code>CrossOriginHandler</code> configuration options, refer to the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/CrossOriginHandler.html"><code>CrossOriginHandler</code> javadocs</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-default"><a class="anchor" href="#pg-server-http-handler-use-default"></a><a class="link" href="#pg-server-http-handler-use-default">DefaultHandler</a></h6>
<div class="paragraph">
<p><code>DefaultHandler</code> is a terminal <code>Handler</code> that always returns <code>true</code> from its <code>handle(...)</code> method and performs the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Serves the <code>favicon.ico</code> Jetty icon when it is requested</p>
</li>
<li>
<p>Sends a HTTP <code>404</code> response for any other request</p>
</li>
<li>
<p>The HTTP <code>404</code> response content nicely shows a HTML table with all the contexts deployed on the <code>Server</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DefaultHandler</code> is set directly on the server, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
server.setDefaultHandler(<span class="keyword">new</span> DefaultHandler(<span class="predefined-constant">false</span>, <span class="predefined-constant">true</span>));

Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Add a ContextHandlerCollection to manage contexts.</span>
ContextHandlerCollection contexts = <span class="keyword">new</span> ContextHandlerCollection();

<span class="comment">// Link the contexts to the Server.</span>
server.setHandler(contexts);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
  ├── ContextHandlerCollection
  │   ├── ContextHandler 1
  │   :── ...
  │   └── ContextHandler N
  └── DefaultHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>ContextHandlerCollection</code> will try to match a request to one of the contexts; if the match fails, <code>Server</code> will call the <code>DefaultHandler</code> that will return a HTTP <code>404</code> with an HTML page showing the existing contexts deployed on the <code>Server</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DefaultHandler</code> just sends a nicer HTTP <code>404</code> response in case of wrong requests from clients.
Jetty will send an HTTP <code>404</code> response anyway if <code>DefaultHandler</code> has not been set.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-handler-use-servlet"><a class="anchor" href="#pg-server-http-handler-use-servlet"></a><a class="link" href="#pg-server-http-handler-use-servlet">Servlet API Handlers</a></h5>
<div class="sect5">
<h6 id="pg-server-http-handler-use-servlet-context"><a class="anchor" href="#pg-server-http-handler-use-servlet-context"></a><a class="link" href="#pg-server-http-handler-use-servlet-context">ServletContextHandler</a></h6>
<div class="paragraph">
<p><code>Handler</code>s are easy to write, but often web applications have already been written using the Servlet APIs, using <code>Servlet</code>s and <code>Filter</code>s.</p>
</div>
<div class="paragraph">
<p><code>ServletContextHandler</code> is a <code>ContextHandler</code> that provides support for the Servlet APIs and implements the behaviors required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>However, differently from <a href="#pg-server-http-handler-use-webapp-context"><code>WebAppContext</code></a>, it does not require web application to be packaged as a <code>*.war</code>, nor it requires a <code>web.xml</code> for configuration.</p>
</div>
<div class="paragraph">
<p>With <code>ServletContextHandler</code> you can just put all your Servlet components in a <code>*.jar</code> and configure each component using the <code>ServletContextHandler</code> APIs, in a way equivalent to what you would write in a <code>web.xml</code>.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee{8,9,10}<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee{8,9,10}-servlet<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, for Jakarta EE 10 the coordinates are: <code>org.eclipse.jetty.ee10:jetty-ee10-servlet:12.0.10-SNAPSHOT</code>.</p>
</div>
<div class="paragraph">
<p>Below you can find an example of how to set up a Jakarta EE 10 <code>ServletContextHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ShopCartServlet</span> <span class="directive">extends</span> HttpServlet
{
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> service(HttpServletRequest request, HttpServletResponse response)
    {
        <span class="comment">// Implement the shop cart functionality.</span>
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Add the CrossOriginHandler to protect from CSRF attacks.</span>
CrossOriginHandler crossOriginHandler = <span class="keyword">new</span> CrossOriginHandler();
crossOriginHandler.setAllowedOriginPatterns(<span class="predefined-type">Set</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">http://domain.com</span><span class="delimiter">&quot;</span></span>));
crossOriginHandler.setAllowCredentials(<span class="predefined-constant">true</span>);
server.setHandler(crossOriginHandler);

<span class="comment">// Create a ServletContextHandler with contextPath.</span>
ServletContextHandler context = <span class="keyword">new</span> ServletContextHandler();
context.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/shop</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Link the context to the server.</span>
crossOriginHandler.setHandler(context);

<span class="comment">// Add the Servlet implementing the cart functionality to the context.</span>
ServletHolder servletHolder = context.addServlet(ShopCartServlet.class, <span class="string"><span class="delimiter">&quot;</span><span class="content">/cart/*</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Configure the Servlet with init-parameters.</span>
servletHolder.setInitParameter(<span class="string"><span class="delimiter">&quot;</span><span class="content">maxItems</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">128</span><span class="delimiter">&quot;</span></span>);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> and Servlet components tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── ServletContextHandler /shop
    ├── <em>ShopCartServlet /cart/*</em>
    └── <em>CrossOriginFilter /*</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the Servlet components (they are not <code>Handler</code>s) are represented in <em>italic</em>.</p>
</div>
<div class="paragraph">
<p>Note also how adding a <code>Servlet</code> or a <code>Filter</code> returns a <em>holder</em> object that can be used to specify additional configuration for that particular <code>Servlet</code> or <code>Filter</code>, for example initialization parameters (equivalent to <code>&lt;init-param&gt;</code> in <code>web.xml</code>).</p>
</div>
<div class="paragraph">
<p>When a request arrives to <code>ServletContextHandler</code> the request URI will be matched against the <code>Filter</code>s and <code>Servlet</code> mappings and only those that match will process the request, as dictated by the Servlet specification.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>ServletContextHandler</code> is a terminal <code>Handler</code>, that is it always returns <code>true</code> from its <code>handle(...)</code> method when invoked.
Server applications must be careful when creating the <code>Handler</code> tree to put <code>ServletContextHandler</code>s as last <code>Handler</code>s in any <code>Handler.Collection</code> or as children of a <code>ContextHandlerCollection</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-webapp-context"><a class="anchor" href="#pg-server-http-handler-use-webapp-context"></a><a class="link" href="#pg-server-http-handler-use-webapp-context">WebAppContext</a></h6>
<div class="paragraph">
<p><code>WebAppContext</code> is a <code>ServletContextHandler</code> that autoconfigures itself by reading a <code>web.xml</code> Servlet configuration file.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee{8,9,10}<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee{8,9,10}-webapp<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Server applications can specify a <code>*.war</code> file or a directory with the structure of a <code>*.war</code> file to <code>WebAppContext</code> to deploy a standard Servlet web application packaged as a <code>war</code> (as defined by the Servlet specification).</p>
</div>
<div class="paragraph">
<p>Where server applications using <code>ServletContextHandler</code> must manually invoke methods to add <code>Servlet</code>s and <code>Filter</code>s as described in <a href="#pg-server-http-handler-use-servlet-context">this section</a>, <code>WebAppContext</code> reads <code>WEB-INF/web.xml</code> to add <code>Servlet</code>s and <code>Filter</code>s, and also enforces a number of restrictions defined by the Servlet specification, in particular related to class loading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create a WebAppContext.</span>
WebAppContext context = <span class="keyword">new</span> WebAppContext();
<span class="comment">// Link the context to the server.</span>
server.setHandler(context);

<span class="comment">// Configure the path of the packaged web application (file or directory).</span>
context.setWar(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/webapp.war</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Configure the contextPath.</span>
context.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app</span><span class="delimiter">&quot;</span></span>);

server.start();</code></pre>
</div>
</div>
<div id="pg-server-http-handler-use-webapp-context-class-loading" class="paragraph">
<div class="title">WebAppContext Class Loading</div>
<p>The Servlet specification requires that a web application class loader must load the web application classes from <code>WEB-INF/classes</code> and <code>WEB_INF/lib</code>.
The web application class loader is special because it behaves differently from typical class loaders: where typical class loaders first delegate to their parent class loader and then try to find the class locally, the web application class loader first tries to find the class locally and then delegates to the parent class loader.
The typical class loading model, parent-first, is <em>inverted</em> for web application class loaders, as they use a child-first model.</p>
</div>
<div class="paragraph">
<p>Furthermore, the Servlet specification requires that web applications cannot load or otherwise access the Servlet container implementation classes, also called <em>server classes</em>.
Web applications receive the HTTP request object as an instance of the <code>jakarta.servlet.http.HttpServletRequest</code> interface, and cannot downcast it to the Jetty specific implementation of that interface to access Jetty specific features&#8201;&#8212;&#8201;this ensures maximum web application portability across Servlet container implementations.</p>
</div>
<div class="paragraph">
<p>Lastly, the Servlet specification requires that other classes, also called <em>system classes</em>, such as <code>jakarta.servlet.http.HttpServletRequest</code> or JDK classes such as <code>java.lang.String</code> or <code>java.sql.Connection</code> cannot be modified by web applications by putting, for example, modified versions of those classes in <code>WEB-INF/classes</code> so that they are loaded first by the web application class loader (instead of the class-path class loader where they are normally loaded from).</p>
</div>
<div class="paragraph">
<p><code>WebAppContext</code> implements this class loader logic using a single class loader, <code>WebAppClassLoader</code>, with filtering capabilities: when it loads a class, it checks whether the class is a <em>system class</em> or a <em>server class</em> and acts according to the Servlet specification.</p>
</div>
<div class="paragraph">
<p>When <code>WebAppClassLoader</code> is asked to load a class, it first tries to find the class locally (since it must use the inverted child-first model); if the class is found, and it is not a <em>system class</em>, the class is loaded; otherwise the class is not found locally.
If the class is not found locally, the parent class loader is asked to load the class; the parent class loader uses the standard parent-first model, so it delegates the class loading to its parent, and so on.
If the class is found, and it is not a <em>server class</em>, the class is loaded; otherwise the class is not found and a <code>ClassNotFoundException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the Servlet specification does not define exactly which classes are <em>system classes</em> and which classes are <em>server classes</em>.
However, Jetty picks good defaults and allows server applications to customize <em>system classes</em> and <em>server classes</em> in <code>WebAppContext</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-use-default-servlet"><a class="anchor" href="#pg-server-http-handler-use-default-servlet"></a><a class="link" href="#pg-server-http-handler-use-default-servlet">DefaultServlet&#8201;&#8212;&#8201;Static Content for Servlets</a></h6>
<div class="paragraph">
<p>If you have a <a href="#pg-server-http-handler-use-servlet-context">Servlet web application</a>, you may want to use a <code>DefaultServlet</code> instead of <code>ResourceHandler</code>.
The features are similar, but <code>DefaultServlet</code> is more commonly used to serve static files for Servlet web applications.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee{8,9,10}<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee{8,9,10}-servlet<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Below you can find an example of how to setup <code>DefaultServlet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a ServletContextHandler with contextPath.</span>
ServletContextHandler context = <span class="keyword">new</span> ServletContextHandler();
context.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add the DefaultServlet to serve static content.</span>
ServletHolder servletHolder = context.addServlet(DefaultServlet.class, <span class="string"><span class="delimiter">&quot;</span><span class="content">/</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// Configure the DefaultServlet with init-parameters.</span>
servletHolder.setInitParameter(<span class="string"><span class="delimiter">&quot;</span><span class="content">resourceBase</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/static/resources/</span><span class="delimiter">&quot;</span></span>);
servletHolder.setAsyncSupported(<span class="predefined-constant">true</span>);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-handler-impl"><a class="anchor" href="#pg-server-http-handler-impl"></a><a class="link" href="#pg-server-http-handler-impl">Implementing Handler</a></h5>
<div class="paragraph">
<p>The <code>Handler</code> API consist fundamentally of just one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The code that implements the <code>handle(...)</code> method must respect the following contract:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It may inspect <code>Request</code> immutable information such as URI and headers, typically to decide whether to return <code>true</code> or <code>false</code> (see below).</p>
</li>
<li>
<p>Returning <code>false</code> means that the implementation will not handle the request, and it <strong>must not</strong> complete the <code>callback</code> parameter, nor read the request content, nor write response content.</p>
</li>
<li>
<p>Returning <code>true</code> means that the implementation will handle the request, and it <strong>must</strong> eventually complete the <code>callback</code> parameter.
The completion of the <code>callback</code> parameter may happen synchronously within the invocation to <code>handle(...)</code>, or at a later time, asynchronously, possibly from another thread.
If the response has not been explicitly written when the <code>callback</code> has been completed, the Jetty implementation will write a <code>200</code> response with no content if the <code>callback</code> has been succeeded, or an error response if the <code>callback</code> has been failed.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Violating the contract above may result in undefined or unexpected behavior, and possibly leak resources.</p>
</div>
<div class="paragraph">
<p>For example, returning <code>true</code> from <code>handle(...)</code>, but not completing the <code>callback</code> parameter may result in the request or the response never be completed, likely causing the client to time out.</p>
</div>
<div class="paragraph">
<p>Similarly, returning <code>false</code> from <code>handle(...)</code> but then either writing the response or completing the <code>callback</code> parameter will likely result in a garbled response be sent to the client, as the implementation will either invoke another <code>Handler</code> (that may write a response) or write a default response.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications may wrap the request, the response, or the callback and forward the wrapped request, response and callback to a child <code>Handler</code>.</p>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-hello"><a class="anchor" href="#pg-server-http-handler-impl-hello"></a><a class="link" href="#pg-server-http-handler-impl-hello">Hello World <code>Handler</code></a></h6>
<div class="paragraph">
<p>A simple "Hello World" <code>Handler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">HelloWorldHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        response.setStatus(<span class="integer">200</span>);
        response.getHeaders().put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">text/html; charset=UTF-8</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Write a Hello World response.</span>
        Content.Sink.write(response, <span class="predefined-constant">true</span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
            &lt;head&gt;
              &lt;title&gt;Jetty Hello World Handler&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
              &lt;p&gt;Hello World&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            </span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>, callback);
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Set the Hello World Handler.</span>
server.setHandler(<span class="keyword">new</span> HelloWorldHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a simple <code>Handler</code> can access the request and response main features, such as <a href="#pg-server-http-handler-impl-request">reading request headers and content</a>, or <a href="#pg-server-http-handler-impl-response">writing response headers and content</a>.</p>
</div>
<div class="paragraph">
<p>Note how <code>HelloWorldHandler</code> extends from <code>Handler.Abstract.NonBlocking</code>.
This is a declaration that <code>HelloWorldHandler</code> does not use blocking APIs (of any kind) to perform its logic, allowing Jetty to apply optimizations (see <a href="#pg-server-http-handler">here</a>) that are not applied to <code>Handler</code>s that declare themselves as blocking.</p>
</div>
<div class="paragraph">
<p>If your <code>Handler</code> implementation uses blocking APIs (of any kind), extend from <code>Handler.Abstract</code>.</p>
</div>
<div class="paragraph">
<p>Note how the <code>callback</code> parameter is passed to <code>Content.Sink.write(...)</code>&#8201;&#8212;&#8201;a utility method that eventually calls <code>Response.write(...)</code>, so that when the write completes, also the <code>callback</code> parameter is completed.
Note also that because the <code>callback</code> parameter will eventually be completed, the value returned from <code>handle(...)</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>In this way the <a href="#pg-server-http-handler-impl"><code>Handler</code> contract</a> is fully respected: when <code>true</code> is returned, the <code>callback</code> will eventually be completed.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-filter"><a class="anchor" href="#pg-server-http-handler-impl-filter"></a><a class="link" href="#pg-server-http-handler-impl-filter">Filtering <code>Handler</code></a></h6>
<div class="paragraph">
<p>A filtering <code>Handler</code> is a handler that perform some modification to the request or response, and then either forwards the request to another <code>Handler</code> or produces an error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">FilterHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Wrapper
{
    <span class="directive">public</span> FilterHandler(<span class="predefined-type">Handler</span> handler)
    {
        <span class="local-variable">super</span>(handler);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="predefined-type">String</span> path = Request.getPathInContext(request);
        <span class="keyword">if</span> (path.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/old_path/</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="comment">// Rewrite old paths to new paths.</span>
            HttpURI uri = request.getHttpURI();
            <span class="predefined-type">String</span> newPath = <span class="string"><span class="delimiter">&quot;</span><span class="content">/new_path/</span><span class="delimiter">&quot;</span></span> + path.substring(<span class="string"><span class="delimiter">&quot;</span><span class="content">/old_path/</span><span class="delimiter">&quot;</span></span>.length());
            HttpURI newURI = HttpURI.build(uri).path(newPath).asImmutable();

            <span class="comment">// Modify the request object by wrapping the HttpURI.</span>
            Request newRequest = Request.serveAs(request, newURI);

            <span class="comment">// Forward to the next Handler using the wrapped Request.</span>
            <span class="keyword">return</span> <span class="local-variable">super</span>.handle(newRequest, response, callback);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Forward to the next Handler as-is.</span>
            <span class="keyword">return</span> <span class="local-variable">super</span>.handle(request, response, callback);
        }
    }
}

Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Link the Handlers in a chain.</span>
server.setHandler(<span class="keyword">new</span> FilterHandler(<span class="keyword">new</span> HelloWorldHandler()));

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how a filtering <code>Handler</code> extends from <code>Handler.Wrapper</code> and as such needs another handler to forward the request processing to, and how the two <code>Handler</code>s needs to be linked together to work properly.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-request"><a class="anchor" href="#pg-server-http-handler-impl-request"></a><a class="link" href="#pg-server-http-handler-impl-request">Using the <code>Request</code></a></h6>
<div class="paragraph">
<p>The <code>Request</code> object can be accessed by web applications to inspect the HTTP request URI, the HTTP request headers and read the HTTP request content.</p>
</div>
<div class="paragraph">
<p>Since the <code>Request</code> object may be wrapped by <a href="#pg-server-http-handler-impl-filter">filtering <code>Handler</code>s</a>, the design decision for the <code>Request</code> APIs was to keep the number of virtual methods at a minimum.
This minimizes the effort necessary to write <code>Request</code> wrapper implementations and provides a single source for the data carried by <code>Request</code> objects.</p>
</div>
<div class="paragraph">
<p>To use the <code>Request</code> APIs, you should look up the relevant methods in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Request</code> virtual methods.
For example, <code>Request.getMethod()</code> returns the HTTP method used in the request, such as <code>GET</code>, <code>POST</code>, etc.</p>
</li>
<li>
<p><code>Request</code> <code>static</code> methods.
These are utility methods that provide more convenient access to request features.
For example, the HTTP URI query is a string and can be directly accessed via the non-<code>static</code> method <code>request.getHttpURI().getQuery()</code>; however, the query string typically holds key/value parameters and applications should not have the burden to parse the query string, so the <code>static Request.extractQueryParameters(Request)</code> method is provided.</p>
</li>
<li>
<p>Super class <code>static</code> methods.
Since <code>Request</code> <em>is-a</em> <code>Content.Source</code>, look also for <code>static</code> methods in <code>Content.Source</code> that take a <code>Content.Source</code> as a parameter, so that you can pass the <code>Request</code> object as a parameter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Below you can find a list of the most common <code>Request</code> features and how to access them.
Refer to the <code>Request</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Request.html">javadocs</a> for the complete list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code> URI</dt>
<dd>
<p>The <code>Request</code> URI is accessed via <code>Request.getHttpURI()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpURI.html"><code>HttpURI</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> HTTP headers</dt>
<dd>
<p>The <code>Request</code> HTTP headers are accessed via <code>Request.getHeaders()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpFields.html"><code>HttpFields</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> cookies</dt>
<dd>
<p>The <code>Request</code> cookies are accessed via <code>static Request.getCookies(Request)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCookie.html"><code>HttpCookie</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> parameters</dt>
<dd>
<p>The <code>Request</code> parameters are accessed via <code>static Request.extractQueryParameters(Request)</code> for those present in the HTTP URI query, and via <code>static Request.getParametersAsync(Request)</code> for both query parameters and request content parameters received via form upload with <code>Content-Type: application/x-www-url-form-encoded</code>, and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/util/Fields.html"><code>Fields</code></a> APIs.
If you are only interested in the request content parameters received via form upload, you can use <code>static FormFields.from(Request)</code>, see also <a href="#pg-server-http-handler-impl-request-content">this section</a>.</p>
</dd>
<dt class="hdlist1"><code>Request</code> HTTP session</dt>
<dd>
<p>The <code>Request</code> HTTP session is accessed via <code>Request.getSession(boolean)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Session.html"><code>Session</code></a> APIs.
For more information about how to set up support for HTTP sessions, see <a href="#pg-server-http-session">this section</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-request-content"><a class="anchor" href="#pg-server-http-handler-impl-request-content"></a><a class="link" href="#pg-server-http-handler-impl-request-content">Reading the <code>Request</code> Content</a></h6>
<div class="paragraph">
<p>Since <code>Request</code> <em>is-a</em> <code>Content.Source</code>, the <a href="#pg-arch-io-content-source">section</a> about reading from <code>Content.Source</code> applies to <code>Request</code> as well.
The <code>static Content.Source</code> utility methods will allow you to read the request content as a string, or as an <code>InputStream</code>, for example.</p>
</div>
<div class="paragraph">
<p>There are two special cases that are specific to HTTP for the request content: form parameters (sent when submitting an HTML form) and multipart form data (sent when submitting an HTML form with file upload).</p>
</div>
<div class="paragraph">
<p>For form parameters, typical of HTML form submissions, you can use the <code>FormFields</code> APIs as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">FormHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="predefined-type">String</span> contentType = request.getHeaders().get(HttpHeader.CONTENT_TYPE);
        <span class="keyword">if</span> (MimeTypes.Type.FORM_ENCODED.is(contentType))
        {
            <span class="comment">// Convert the request content into Fields.</span>
            CompletableFuture&lt;Fields&gt; completableFields = FormFields.from(request); <i class="conum" data-value="1"></i><b>(1)</b>

            <span class="comment">// When all the request content has arrived, process the fields.</span>
            completableFields.whenComplete((fields, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            {
                <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                {
                    processFields(fields);
                    <span class="comment">// Send a simple 200 response, completing the callback.</span>
                    response.setStatus(HttpStatus.OK_200);
                    callback.succeeded();
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// Reading the request content failed.</span>
                    <span class="comment">// Send an error response, completing the callback.</span>
                    Response.writeError(request, response, callback, failure);
                }
            });

            <span class="comment">// The callback will be eventually completed in all cases, return true.</span>
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Send an error response, completing the callback, and returning true.</span>
            Response.writeError(request, response, callback, HttpStatus.BAD_REQUEST_400, <span class="string"><span class="delimiter">&quot;</span><span class="content">invalid request</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the <code>Content-Type</code> is <code>x-www-form-urlencoded</code>, read the request content with <code>FormFields</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When all the request content has arrived, process the <code>Fields</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when reading the request content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For multipart form data, typical for HTML form file uploads, you can use the <code>MultiPartFormData.Parser</code> APIs as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MultiPartFormDataHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="predefined-type">String</span> contentType = request.getHeaders().get(HttpHeader.CONTENT_TYPE);
        <span class="keyword">if</span> (MimeTypes.Type.MULTIPART_FORM_DATA.is(contentType))
        {
            <span class="comment">// Extract the multipart boundary.</span>
            <span class="predefined-type">String</span> boundary = MultiPart.extractBoundary(contentType);

            <span class="comment">// Create and configure the multipart parser.</span>
            MultiPartFormData.Parser parser = <span class="keyword">new</span> MultiPartFormData.Parser(boundary);
            <span class="comment">// By default, uploaded files are stored in this directory, to</span>
            <span class="comment">// avoid to read the file content (which can be large) in memory.</span>
            parser.setFilesDirectory(Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp</span><span class="delimiter">&quot;</span></span>));
            <span class="comment">// Convert the request content into parts.</span>
            CompletableFuture&lt;MultiPartFormData.Parts&gt; completableParts = parser.parse(request); <i class="conum" data-value="1"></i><b>(1)</b>

            <span class="comment">// When all the request content has arrived, process the parts.</span>
            completableParts.whenComplete((parts, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            {
                <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                {
                    <span class="comment">// Use the Parts API to process the parts.</span>
                    processParts(parts);
                    <span class="comment">// Send a simple 200 response, completing the callback.</span>
                    response.setStatus(HttpStatus.OK_200);
                    callback.succeeded();
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// Reading the request content failed.</span>
                    <span class="comment">// Send an error response, completing the callback.</span>
                    Response.writeError(request, response, callback, failure);
                }
            });

            <span class="comment">// The callback will be eventually completed in all cases, return true.</span>
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Send an error response, completing the callback, and returning true.</span>
            Response.writeError(request, response, callback, HttpStatus.BAD_REQUEST_400, <span class="string"><span class="delimiter">&quot;</span><span class="content">invalid request</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the <code>Content-Type</code> is <code>multipart/form-data</code>, read the request content with <code>MultiPartFormData.Parser</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When all the request content has arrived, process the <code>MultiPartFormData.Parts</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when reading the request content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-request-listeners"><a class="anchor" href="#pg-server-http-handler-impl-request-listeners"></a><a class="link" href="#pg-server-http-handler-impl-request-listeners"><code>Request</code> Listeners</a></h6>
<div class="paragraph">
<p>Application may add listeners to the <code>Request</code> object to be notified of particular events happening during the request/response processing.</p>
</div>
<div class="paragraph">
<p><code>Request.addIdleTimeoutListener(Predicate&lt;TimeoutException&gt;)</code> allows you to add an idle timeout listener, which is invoked when an idle timeout period elapses during the request/response processing, if the idle timeout event is not notified otherwise.</p>
</div>
<div class="paragraph">
<p>When an idle timeout event happens, it is delivered to the application as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is pending demand (via <code>Request.demand(Runnable)</code>), then the demand <code>Runnable</code> is invoked and the application may see the idle timeout failure by reading from the <code>Request</code>, obtaining a <a href="#pg-arch-io-content-source">transient failure chunk</a>.</p>
</li>
<li>
<p>If there is a pending response write (via <code>Response.write(boolean, ByteBuffer, Callback)</code>), the response write <code>Callback</code> is failed.</p>
</li>
<li>
<p>If neither of the above, the idle timeout listeners are invoked, in the same order they have been added.
The first idle timeout listener that returns <code>true</code> stops the Jetty implementation from invoking the idle timeout listeners that follow.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The idle timeout listeners are therefore invoked only when the application is really idle, neither trying to read nor trying to write.</p>
</div>
<div class="paragraph">
<p>An idle timeout listener may return <code>true</code> to indicate that the idle timeout should be treated as a fatal failure of the request/response processing; otherwise the listener may return <code>false</code> to indicate that no further handling of the idle timeout is needed from the Jetty implementation.</p>
</div>
<div class="paragraph">
<p>When idle timeout listeners return <code>false</code>, then any subsequent idle timeouts are handled as above.
In the case that the application does not initiate any read or write, then the idle timeout listeners are invoked again after another idle timeout period.</p>
</div>
<div class="paragraph">
<p><code>Request.addFailureListener(Consumer&lt;Throwable&gt;)</code> allows you to add a failure listener, which is invoked when a failure happens during the request/response processing.</p>
</div>
<div class="paragraph">
<p>When a failure happens during the request/response processing, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending demand for request content, if any, is invoked; that is, the <code>Runnable</code> passed to <code>Request.demand(Runnable)</code> is invoked.</p>
</li>
<li>
<p>The callback of an outstanding call to <code>Response.write(boolean, ByteBuffer, Callback)</code>, if any, is failed.</p>
</li>
<li>
<p>The failure listeners are invoked, in the same order they have been added.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Failure listeners are invoked also in case of idle timeouts, in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At least one idle timeout listener returned <code>true</code> to indicate to the Jetty implementation to treat the idle timeout as a fatal failure.</p>
</li>
<li>
<p>There are no idle timeout listeners.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Failures reported to a failure listener are always fatal failures; see also <a href="#pg-arch-io-content-source">this section</a> about fatal versus transient failures.
This means that it is not possible to read or write from a failure listener: the read returns a fatal failure chunk, and the write will immediately fail the write callback.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Applications are always required to complete the <code>Handler</code> callback, as described <a href="#pg-server-http-handler-impl">here</a>.
In case of asynchronous failures, failure listeners are a good place to complete (typically by failing it) the <code>Handler</code> callback.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Request.addCompletionListener(Consumer&lt;Throwable&gt;)</code> allows you to add a completion listener, which is invoked at the very end of the request/response processing.
This is equivalent to adding an <code>HttpStream</code> wrapper and overriding both <code>HttpStream.succeeded()</code> and <code>HttpStream.failed(Throwable)</code>.</p>
</div>
<div class="paragraph">
<p>Completion listeners are typically (but not only) used to recycle or dispose resources used during the request/response processing, or get a precise timing for when the request/response processing finishes, to be paired with <code>Request.getBeginNanoTime()</code>.</p>
</div>
<div class="paragraph">
<p>Note that while failure listeners are invoked as soon as the failure happens, completion listeners are invoked only at the very end of the request/response processing: after the <code>Callback</code> passed to <code>Handler.handle(Request, Response, Callback)</code> has been completed, all container dispatched threads have returned, and all the response writes have been completed.</p>
</div>
<div class="paragraph">
<p>In case of many completion listeners, they are invoked in the reverse order they have been added.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-response"><a class="anchor" href="#pg-server-http-handler-impl-response"></a><a class="link" href="#pg-server-http-handler-impl-response">Using the <code>Response</code></a></h6>
<div class="paragraph">
<p>The <code>Response</code> object can be accessed by web applications to set the HTTP response status code, the HTTP response headers and write the HTTP response content.</p>
</div>
<div class="paragraph">
<p>The design of the <code>Response</code> APIs is similar to that of the <code>Request</code> APIs, described in <a href="#pg-server-http-handler-impl-request">this section</a>.</p>
</div>
<div class="paragraph">
<p>To use the <code>Response</code> APIs, you should look up the relevant methods in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Response</code> virtual methods.
For example, <code>Response.setStatus(int)</code> to set the HTTP response status code.</p>
</li>
<li>
<p><code>Request</code> <code>static</code> methods.
These are utility methods that provide more convenient access to response features.
For example, adding an HTTP cookie could be done by adding a <code>Set-Cookie</code> response header, but it would be extremely error-prone.
The utility method <code>static Response.addCookie(Response, HttpCookie)</code> is provided instead.</p>
</li>
<li>
<p>Super class <code>static</code> methods.
Since <code>Response</code> <em>is-a</em> <code>Content.Sink</code>, look also for <code>static</code> methods in <code>Content.Sink</code> that take a <code>Content.Sink</code> as a parameter, so that you can pass the <code>Response</code> object as a parameter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Below you can find a list of the most common <code>Response</code> features and how to access them.
Refer to the <code>Response</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Response.html">javadocs</a> for the complete list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Response</code> status code</dt>
<dd>
<p>The <code>Response</code> HTTP status code is accessed via <code>Response.getStatus()</code> and <code>Response.setStatus(int)</code>.</p>
</dd>
<dt class="hdlist1"><code>Response</code> HTTP headers</dt>
<dd>
<p>The <code>Response</code> HTTP headers are accessed via <code>Response.getHeaders()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpFields.Mutable.html"><code>HttpFields.Mutable</code></a> APIs.
The response headers are mutable until the response is <em>committed</em>, as defined in <a href="#pg-server-http-handler-impl-response-content">this section</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code> cookies</dt>
<dd>
<p>The <code>Response</code> cookies are accessed via <code>static Response.addCookie(Response, HttpCookie)</code>, <code>static Response.replaceCookie(Response, HttpCookie)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCookie.html"><code>HttpCookie</code></a> APIs.
Since cookies translate to HTTP headers, they can be added/replaces until the response is <em>committed</em>, as defined in <a href="#pg-server-http-handler-impl-response-content">this section</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-response-content"><a class="anchor" href="#pg-server-http-handler-impl-response-content"></a><a class="link" href="#pg-server-http-handler-impl-response-content">Writing the <code>Response</code> Content</a></h6>
<div class="paragraph">
<p>Since <code>Response</code> <em>is-a</em> <code>Content.Sink</code>, the <a href="#pg-arch-io-content-sink">section</a> about writing to <code>Content.Sink</code> applies to <code>Response</code> as well.
The <code>static Content.Sink</code> utility methods will allow you to write the response content as a string, or as an <code>OutputStream</code>, for example.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The first call to <code>Response.write(boolean, ByteBuffer, Callback)</code> <em>commits</em> the response.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Committing the response means that the response status code and response headers are sent to the other peer, and therefore cannot be modified anymore.
Trying to modify them may result in an <code>IllegalStateException</code> to be thrown, as it is an application mistake to commit the response and then try to modify the headers.</p>
</div>
<div class="paragraph">
<p>You can explicitly commit the response by performing an empty, non-last write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">FlushingHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Set the response status code.</span>
        response.setStatus(HttpStatus.OK_200);
        <span class="comment">// Set the response headers.</span>
        response.getHeaders().put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Commit the response with a &quot;flush&quot; write.</span>
        <span class="predefined-type">Callback</span>.Completable.with(flush -&gt; response.write(<span class="predefined-constant">false</span>, <span class="predefined-constant">null</span>, flush))
            <span class="comment">// When the flush is finished, send the content and complete the callback.</span>
            .whenComplete((ignored, failure) -&gt;
            {
                <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                    response.write(<span class="predefined-constant">true</span>, UTF_8.encode(<span class="string"><span class="delimiter">&quot;</span><span class="content">HELLO</span><span class="delimiter">&quot;</span></span>), callback);
                <span class="keyword">else</span>
                    callback.failed(failure);
            });

        <span class="comment">// Return true because the callback will eventually be completed.</span>
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when writing the response content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jetty can perform important optimizations for the HTTP/1.1 protocol if the response content length is known before the response is committed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ContentLengthHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Set the response status code.</span>
        response.setStatus(HttpStatus.OK_200);

        <span class="predefined-type">String</span> content = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="content">
            {
              </span><span class="delimiter">&quot;</span></span>result<span class="string"><span class="delimiter">&quot;</span><span class="content">: 0,
              </span><span class="delimiter">&quot;</span></span>advice<span class="string"><span class="delimiter">&quot;</span><span class="content">: {
                </span><span class="delimiter">&quot;</span></span>message<span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span>Jetty Rocks!<span class="string"><span class="delimiter">&quot;</span><span class="content">
              }
            }
            </span><span class="delimiter">&quot;</span></span><span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;
        <span class="comment">// Must count the bytes, not the characters!</span>
        <span class="type">byte</span><span class="type">[]</span> bytes = content.getBytes(UTF_8);
        <span class="type">long</span> contentLength = bytes.length;

        <span class="comment">// Set the response headers before the response is committed.</span>
        HttpFields.Mutable responseHeaders = response.getHeaders();
        <span class="comment">// Set the content type.</span>
        responseHeaders.put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">application/json; charset=UTF-8</span><span class="delimiter">&quot;</span></span>);
        <span class="comment">// Set the response content length.</span>
        responseHeaders.put(HttpHeader.CONTENT_LENGTH, contentLength);

        <span class="comment">// Commit the response.</span>
        response.write(<span class="predefined-constant">true</span>, <span class="predefined-type">ByteBuffer</span>.wrap(bytes), callback);

        <span class="comment">// Return true because the callback will eventually be completed.</span>
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting the response content length is an <em>optimization</em>; Jetty will work well even without it.
If you set the response content length, however, remember that it must specify the number of <em>bytes</em>, not the number of characters.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-handler-impl-response-interim"><a class="anchor" href="#pg-server-http-handler-impl-response-interim"></a><a class="link" href="#pg-server-http-handler-impl-response-interim">Sending Interim <code>Response</code>s</a></h6>
<div class="paragraph">
<p>The HTTP protocol (any version) allows applications to write <a href="https://www.rfc-editor.org/rfc/rfc9110#name-status-codes">interim responses</a>.</p>
</div>
<div class="paragraph">
<p>An interim response has a status code in the <code>1xx</code> range (but not <code>101</code>), and an application may write zero or more interim response before the final response.</p>
</div>
<div class="paragraph">
<p>This is an example of writing an interim <code>100 Continue</code> response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Continue100Handler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Wrapper
{
    <span class="directive">public</span> Continue100Handler(<span class="predefined-type">Handler</span> handler)
    {
        <span class="local-variable">super</span>(handler);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        HttpFields requestHeaders = request.getHeaders();
        <span class="keyword">if</span> (requestHeaders.contains(HttpHeader.EXPECT, HttpHeaderValue.CONTINUE.asString()))
        {
            <span class="comment">// Analyze the request and decide whether to receive the content.</span>
            <span class="type">long</span> contentLength = request.getLength();
            <span class="keyword">if</span> (contentLength &gt; <span class="integer">0</span> &amp;&amp; contentLength &lt; <span class="integer">1024</span>)
            {
                <span class="comment">// Small request content, ask to send it by</span>
                <span class="comment">// sending a 100 Continue interim response.</span>
                CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; processing = response.writeInterim(HttpStatus.CONTINUE_100, HttpFields.EMPTY) <i class="conum" data-value="1"></i><b>(1)</b>
                    <span class="comment">// Then read the request content into a ByteBuffer.</span>
                    .thenCompose(ignored -&gt; Promise.Completable.&lt;<span class="predefined-type">ByteBuffer</span>&gt;with(p -&gt; Content.Source.asByteBuffer(request, p)))
                    <span class="comment">// Then store the ByteBuffer somewhere.</span>
                    .thenCompose(byteBuffer -&gt; store(byteBuffer));

                <span class="comment">// At the end of the processing, complete</span>
                <span class="comment">// the callback with the CompletableFuture,</span>
                <span class="comment">// a simple 200 response in case of success,</span>
                <span class="comment">// or a 500 response in case of failure.</span>
                callback.completeWith(processing); <i class="conum" data-value="2"></i><b>(2)</b>
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// The request content is too large, send an error.</span>
                Response.writeError(request, response, callback, HttpStatus.PAYLOAD_TOO_LARGE_413);
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
        }
        <span class="keyword">else</span>
        {
            <span class="keyword">return</span> <span class="local-variable">super</span>.handle(request, response, callback);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>Response.writeInterim(...)</code> to send the interim response.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The completion of the callback must take into account both success and failure.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note how writing an interim response is as asynchronous operation.
As such you must perform subsequent operations using the <code>CompletableFuture</code> APIs, and remember to complete the <code>Handler</code> <code>callback</code> parameter both in case of success or in case of failure.</p>
</div>
<div class="paragraph">
<p>This is an example of writing an interim <code>103 Early Hints</code> response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EarlyHints103Handler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Wrapper
{
    <span class="directive">public</span> EarlyHints103Handler(<span class="predefined-type">Handler</span> handler)
    {
        <span class="local-variable">super</span>(handler);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="predefined-type">String</span> pathInContext = Request.getPathInContext(request);

        <span class="comment">// Simple logic that assumes that every HTML</span>
        <span class="comment">// file has associated the same CSS stylesheet.</span>
        <span class="keyword">if</span> (pathInContext.endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">.html</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="comment">// Tell the client that a Link is coming</span>
            <span class="comment">// sending a 103 Early Hints interim response.</span>
            HttpFields.Mutable interimHeaders = HttpFields.build()
                .put(HttpHeader.LINK, <span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;/style.css&gt;; rel=preload; as=style</span><span class="delimiter">&quot;</span></span>);

            response.writeInterim(HttpStatus.EARLY_HINTS_103, interimHeaders) <i class="conum" data-value="1"></i><b>(1)</b>
                .whenComplete((ignored, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
                {
                    <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
                    {
                        <span class="keyword">try</span>
                        {
                            <span class="comment">// Delegate the handling to the child Handler.</span>
                            <span class="type">boolean</span> handled = <span class="local-variable">super</span>.handle(request, response, callback);
                            <span class="keyword">if</span> (!handled)
                            {
                                <span class="comment">// The child Handler did not produce a final response, do it here.</span>
                                Response.writeError(request, response, callback, HttpStatus.NOT_FOUND_404);
                            }
                        }
                        <span class="keyword">catch</span> (<span class="predefined-type">Throwable</span> x)
                        {
                            callback.failed(x);
                        }
                    }
                    <span class="keyword">else</span>
                    {
                        callback.failed(failure);
                    }
                });

            <span class="comment">// This Handler sent an interim response, so this Handler</span>
            <span class="comment">// (or its descendants) must produce a final response, so return true.</span>
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Not a request for an HTML page, delegate</span>
            <span class="comment">// the handling to the child Handler.</span>
            <span class="keyword">return</span> <span class="local-variable">super</span>.handle(request, response, callback);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>Response.writeInterim(...)</code> to send the interim response.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The completion of the callback must take into account both success and failure.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An interim response may or may not have its own HTTP headers (this depends on the interim response status code), and they are typically different from the final response HTTP headers.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-session"><a class="anchor" href="#pg-server-http-session"></a><a class="link" href="#pg-server-http-session">HTTP Session Support</a></h5>
<div class="paragraph">
<p>Some web applications (but not all of them) have the concept of a <em>user</em>, that is a way to identify a specific client that is interacting with the web application.</p>
</div>
<div class="paragraph">
<p>The HTTP session is a feature offered by servers that allows web applications to maintain a temporary, per-user, storage for user-specific data.</p>
</div>
<div class="paragraph">
<p>The storage can be accessed by the web application across multiple request/response interactions with the client.
This makes the web application stateful, because a computation performed by a previous request may be stored in the HTTP session and used in subsequent requests without the need to perform again the computation.</p>
</div>
<div class="paragraph">
<p>Since not all web applications need support for the HTTP session, Jetty offers this feature optionally.</p>
</div>
<div class="paragraph">
<p>The Maven coordinates for the Jetty HTTP session support are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-session<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The HTTP session support is provided by the <code>org.eclipse.jetty.session.SessionHandler</code>, that must be set up in the <code>Handler</code> tree between a <code>ContextHandler</code> and your <code>Handler</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">MyAppHandler</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract.NonBlocking
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Your web application implemented here.</span>

        <span class="comment">// You can access the HTTP session.</span>
        Session session = request.getSession(<span class="predefined-constant">false</span>);

        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}

Server server = <span class="keyword">new</span> Server();
Connector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);

<span class="comment">// Create a ContextHandler with contextPath.</span>
ContextHandler contextHandler = <span class="keyword">new</span> ContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/myApp</span><span class="delimiter">&quot;</span></span>);
server.setHandler(contextHandler);

<span class="comment">// Create and link the SessionHandler.</span>
SessionHandler sessionHandler = <span class="keyword">new</span> SessionHandler();
contextHandler.setHandler(sessionHandler);

<span class="comment">// Link your web application Handler.</span>
sessionHandler.setHandler(<span class="keyword">new</span> MyAppHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Server
└── ContextHandler /myApp
    └── SessionHandler
        └── MyAppHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>Handler</code>s set up in this way, you can access the HTTP session from your <code>MyAppHandler</code> using <code>Request.getSession(boolean)</code>, and then use the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Session.html"><code>Session</code> APIs</a>.</p>
</div>
<div class="paragraph">
<p>The support provided by Jetty for HTTP sessions is advanced and completely pluggable, providing features such as first-level and second-level caching, eviction, etc.</p>
</div>
<div class="paragraph">
<p>You can configure the HTTP session support from a very simple local in-memory configuration, to a replicated (across nodes in a cluster), persistent (for example over file system, database or <a href="https://memcached.org/">memcached</a>) configuration for the most advanced use cases.
The advanced configuration of Jetty&#8217;s HTTP session support is discussed in more details in <a href="#pg-server-session">this section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-security"><a class="anchor" href="#pg-server-http-security"></a><a class="link" href="#pg-server-http-security">Securing HTTP Server Applications</a></h5>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-http-application"><a class="anchor" href="#pg-server-http-application"></a><a class="link" href="#pg-server-http-application">Writing HTTP Server Applications</a></h5>
<div class="paragraph">
<p>Writing HTTP applications is typically simple, especially when using blocking APIs.
However, there are subtle cases where it is worth clarifying what a server application should do to obtain the desired results when run by Jetty.</p>
</div>
<div class="sect5">
<h6 id="pg-server-http-application-1xx"><a class="anchor" href="#pg-server-http-application-1xx"></a><a class="link" href="#pg-server-http-application-1xx">Sending 1xx Responses</a></h6>
<div class="paragraph">
<p>The <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1">HTTP/1.1 RFC</a> allows for <code>1xx</code> informational responses to be sent before a real content response.
Unfortunately the servlet specification does not provide a way for these to be sent, so Jetty has had to provide non-standard handling of these headers.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-http-application-100"><a class="anchor" href="#pg-server-http-application-100"></a><a class="link" href="#pg-server-http-application-100">100 Continue</a></h6>
<div class="paragraph">
<p>The <code>100 Continue</code> response should be sent by the server when a client sends a request with an <code>Expect: 100-continue</code> header, as the client will not send the body of the request until the <code>100 Continue</code> response has been sent.</p>
</div>
<div class="paragraph">
<p>The intent of this feature is to allow a server to inspect the headers and to tell the client to not send a request body that might be too large or insufficiently private or otherwise unable to be handled.</p>
</div>
<div class="paragraph">
<p>Jetty achieves this by waiting until the input stream or reader is obtained by the filter/servlet, before sending the <code>100 Continue</code> response.
Thus a filter/servlet may inspect the headers of a request before getting the input stream and send an error response (or redirect etc.) rather than the 100 continues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Continue100HttpServlet</span> <span class="directive">extends</span> HttpServlet
{
    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> service(HttpServletRequest request, HttpServletResponse response) <span class="directive">throws</span> <span class="exception">IOException</span>
    {
        <span class="comment">// Inspect the method and headers.</span>
        <span class="type">boolean</span> isPost = HttpMethod.POST.is(request.getMethod());
        <span class="type">boolean</span> expects100 = HttpHeaderValue.CONTINUE.is(request.getHeader(<span class="string"><span class="delimiter">&quot;</span><span class="content">Expect</span><span class="delimiter">&quot;</span></span>));
        <span class="type">long</span> contentLength = request.getContentLengthLong();

        <span class="keyword">if</span> (isPost &amp;&amp; expects100)
        {
            <span class="keyword">if</span> (contentLength &gt; <span class="integer">1024</span> * <span class="integer">1024</span>)
            {
                <span class="comment">// Rejects uploads that are too large.</span>
                response.sendError(HttpStatus.PAYLOAD_TOO_LARGE_413);
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// Getting the request InputStream indicates that</span>
                <span class="comment">// the application wants to read the request content.</span>
                <span class="comment">// Jetty will send the 100 Continue response at this</span>
                <span class="comment">// point, and the client will send the request content.</span>
                ServletInputStream input = request.getInputStream();

                <span class="comment">// Read and process the request input.</span>
            }
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Process normal requests.</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="jetty-102-processing"><a class="anchor" href="#jetty-102-processing"></a><a class="link" href="#jetty-102-processing">102 Processing</a></h6>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc2518">RFC 2518</a> defined the <code>102 Processing</code> status code that can be sent:</p>
</div>
<div class="quoteblock">
<blockquote>
when the server has a reasonable expectation that the request will take significant time to complete.
As guidance, if a method is taking longer than 20 seconds (a reasonable, but arbitrary value) to process the server SHOULD return a <code>102 Processing</code> response.
</blockquote>
<div class="attribution">
&#8212; RFC 2518 section 10.1
</div>
</div>
<div class="paragraph">
<p>However, a later update of RFC 2518, <a href="https://tools.ietf.org/html/rfc4918">RFC 4918</a>, removed the <code>102 Processing</code> status code for <a href="https://tools.ietf.org/html/rfc4918#appendix-F.3">"lack of implementation"</a>.</p>
</div>
<div class="paragraph">
<p>Jetty supports the <code>102 Processing</code> status code.
If a request is received with the <code>Expect: 102-processing</code> header, then a filter/servlet may send a <code>102 Processing</code> response (without terminating further processing) by calling <code>response.sendError(102)</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-http2"><a class="anchor" href="#pg-server-http2"></a><a class="link" href="#pg-server-http2">HTTP/2 Server Library</a></h3>
<div class="paragraph">
<p>In the vast majority of cases, server applications should use the generic, high-level, <a href="#pg-server-http">HTTP server library</a> that also provides HTTP/2 support via the HTTP/2 <code>ConnectionFactory</code>s as described in details <a href="#pg-server-http-connector-protocol-http2">here</a>.</p>
</div>
<div class="paragraph">
<p>The low-level HTTP/2 server library has been designed for those applications that need low-level access to HTTP/2 features such as <em>sessions</em>, <em>streams</em> and <em>frames</em>, and this is quite a rare use case.</p>
</div>
<div class="paragraph">
<p>See also the correspondent <a href="#pg-client-http2">HTTP/2 client library</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-server-http2-intro"><a class="anchor" href="#pg-server-http2-intro"></a><a class="link" href="#pg-server-http2-intro">Introduction</a></h4>
<div class="paragraph">
<p>The Maven artifact coordinates for the HTTP/2 client library are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.http2<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-http2-server<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/2 is a multiplexed protocol: it allows multiple HTTP/2 requests to be sent on the same TCP connection, or <em>session</em>.
Each request/response cycle is represented by a <em>stream</em>.
Therefore, a single <em>session</em> manages multiple concurrent <em>streams</em>.
A <em>stream</em> has typically a very short life compared to the <em>session</em>: a <em>stream</em> only exists for the duration of the request/response cycle and then disappears.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-flow-control"><a class="anchor" href="#pg-server-http2-flow-control"></a><a class="link" href="#pg-server-http2-flow-control">HTTP/2 Flow Control</a></h4>
<div class="paragraph">
<p>The HTTP/2 protocol is <em>flow controlled</em> (see <a href="https://tools.ietf.org/html/rfc7540#section-5.2">the specification</a>).
This means that a sender and a receiver maintain a <em>flow control window</em> that tracks the number of data bytes sent and received, respectively.
When a sender sends data bytes, it reduces its flow control window.
When a receiver receives data bytes, it also reduces its flow control window, and then passes the received data bytes to the application.
The application consumes the data bytes and tells back the receiver that it has consumed the data bytes.
The receiver then enlarges the flow control window, and the implementation arranges to send a message to the sender with the number of bytes consumed, so that the sender can enlarge its flow control window.</p>
</div>
<div class="paragraph">
<p>A sender can send data bytes up to its whole flow control window, then it must stop sending.
The sender may resume sending data bytes when it receives a message from the receiver that the data bytes sent previously have been consumed.
This message enlarges the sender flow control window, which allows the sender to send more data bytes.</p>
</div>
<div class="paragraph">
<p>HTTP/2 defines <em>two</em> flow control windows: one for each <em>session</em>, and one for each <em>stream</em>.
Let&#8217;s see with an example how they interact, assuming that in this example the session flow control window is 120 bytes and the stream flow control window is 100 bytes.</p>
</div>
<div class="paragraph">
<p>The sender opens a session, and then opens <code>stream_1</code> on that session, and sends <code>80</code> data bytes.
At this point the session flow control window is <code>40</code> bytes (<code>120 - 80</code>), and <code>stream_1</code>'s flow control window is <code>20</code> bytes (<code>100 - 80</code>).
The sender now opens <code>stream_2</code> on the same session and sends <code>40</code> data bytes.
At this point, the session flow control window is <code>0</code> bytes (<code>40 - 40</code>), while <code>stream_2</code>'s flow control window is <code>60</code> (<code>100 - 40</code>).
Since now the session flow control window is <code>0</code>, the sender cannot send more data bytes, neither on <code>stream_1</code> nor on <code>stream_2</code>, nor on other streams, despite all the streams having their stream flow control windows greater than <code>0</code>.</p>
</div>
<div class="paragraph">
<p>The receiver consumes <code>stream_2</code>'s <code>40</code> data bytes and sends a message to the sender with this information.
At this point, the session flow control window is <code>40</code> (<code>0 + 40</code>), <code>stream_1</code>'s flow control window is still <code>20</code> and <code>stream_2</code>'s flow control window is <code>100</code> (<code>60 + 40</code>).
If the sender opens <code>stream_3</code> and would like to send <code>50</code> data bytes, it would only be able to send <code>40</code> because that is the maximum allowed by the session flow control window at this point.</p>
</div>
<div class="paragraph">
<p>It is therefore very important that applications notify the fact that they have consumed data bytes as soon as possible, so that the implementation (the receiver) can send a message to the sender (in the form of a <code>WINDOW_UPDATE</code> frame) with the information to enlarge the flow control window, therefore reducing the possibility that sender stalls due to the flow control windows being reduced to <code>0</code>.</p>
</div>
<div class="paragraph">
<p>How a server application should handle HTTP/2 flow control is discussed in details in <a href="#pg-server-http2-request">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-setup"><a class="anchor" href="#pg-server-http2-setup"></a><a class="link" href="#pg-server-http2-setup">Server Setup</a></h4>
<div class="paragraph">
<p>The low-level HTTP/2 support is provided by <code>org.eclipse.jetty.http2.server.RawHTTP2ServerConnectionFactory</code> and <code>org.eclipse.jetty.http2.api.server.ServerSessionListener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server instance.</span>
Server server = <span class="keyword">new</span> Server();

ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener() {};

<span class="comment">// Create a ServerConnector with RawHTTP2ServerConnectionFactory.</span>
RawHTTP2ServerConnectionFactory http2 = <span class="keyword">new</span> RawHTTP2ServerConnectionFactory(sessionListener);

<span class="comment">// Configure RawHTTP2ServerConnectionFactory, for example:</span>

<span class="comment">// Configure the max number of concurrent requests.</span>
http2.setMaxConcurrentStreams(<span class="integer">128</span>);
<span class="comment">// Enable support for CONNECT.</span>
http2.setConnectProtocolEnabled(<span class="predefined-constant">true</span>);

<span class="comment">// Create the ServerConnector.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, http2);

<span class="comment">// Add the Connector to the Server</span>
server.addConnector(connector);

<span class="comment">// Start the Server so it starts accepting connections from clients.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where server applications using the <a href="#pg-server-http">high-level server library</a> deal with HTTP requests and responses in <code>Handler</code>s, server applications using the low-level HTTP/2 server library deal directly with HTTP/2 <em>session</em>s, <em>stream</em>s and <em>frame</em>s in a <code>ServerSessionListener</code> implementation.</p>
</div>
<div class="paragraph">
<p>The <code>ServerSessionListener</code> interface defines a number of methods that are invoked by the implementation upon the occurrence of HTTP/2 events, and that server applications can override to react to those events.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>ServerSessionListener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http2/api/server/ServerSessionListener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>The first event is the <em>accept</em> event and happens when a client opens a new TCP connection to the server and the server accepts the connection.
This is the first occasion where server applications have access to the HTTP/2 <code>Session</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onAccept(Session session)
    {
        <span class="predefined-type">SocketAddress</span> remoteAddress = session.getRemoteSocketAddress();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http2</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Connection from {0}</span><span class="delimiter">&quot;</span></span>, remoteAddress);
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After connecting to the server, a compliant HTTP/2 client must send the <a href="https://tools.ietf.org/html/rfc7540#section-3.5">HTTP/2 client preface</a>, and when the server receives it, it generates the <em>preface</em> event on the server.
This is where server applications can customize the connection settings by returning a map of settings that the implementation will send to the client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt; onPreface(Session session)
    {
        <span class="comment">// Customize the settings, for example:</span>
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt; settings = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

        <span class="comment">// Tell the client that HTTP/2 push is disabled.</span>
        settings.put(SettingsFrame.ENABLE_PUSH, <span class="integer">0</span>);

        <span class="keyword">return</span> settings;
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-request"><a class="anchor" href="#pg-server-http2-request"></a><a class="link" href="#pg-server-http2-request">Receiving a Request</a></h4>
<div class="paragraph">
<p>Receiving an HTTP request from the client, and sending a response, creates a <em>stream</em> that encapsulates the exchange of HTTP/2 frames that compose the request and the response.</p>
</div>
<div class="paragraph">
<p>An HTTP request is made of a <code>HEADERS</code> frame, that carries the request method, the request URI and the request headers, and optional <code>DATA</code> frames that carry the request content.</p>
</div>
<div class="paragraph">
<p>Receiving the <code>HEADERS</code> frame opens the <code>Stream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onNewStream(Stream stream, HeadersFrame frame)
    {
        <span class="comment">// This is the &quot;new stream&quot; event, so it's guaranteed to be a request.</span>
        MetaData.Request request = (MetaData.Request)frame.getMetaData();

        <span class="comment">// Return a Stream.Listener to handle the request events,</span>
        <span class="comment">// for example request content events or a request reset.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
        {
            <span class="comment">// Override callback methods for events you are interested in.</span>
        };
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Server applications should return a <code>Stream.Listener</code> implementation from <code>onNewStream(...)</code> to be notified of events generated by the client, such as <code>DATA</code> frames carrying request content, or a <code>RST_STREAM</code> frame indicating that the client wants to <em>reset</em> the request, or an idle timeout event indicating that the client was supposed to send more frames but it did not.</p>
</div>
<div class="paragraph">
<p>The example below shows how to receive request content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onNewStream(Stream stream, HeadersFrame frame)
    {
        MetaData.Request request = (MetaData.Request)frame.getMetaData();

        <span class="comment">// Demand for request data content.</span>
        stream.demand();

        <span class="comment">// Return a Stream.Listener to handle the request events.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
            {
                Stream.Data data = stream.readData();

                <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
                {
                    stream.demand();
                    <span class="keyword">return</span>;
                }

                <span class="comment">// Get the content buffer.</span>
                <span class="predefined-type">ByteBuffer</span> buffer = data.frame().getByteBuffer();

                <span class="comment">// Consume the buffer, here - as an example - just log it.</span>
                <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http2</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Consuming buffer {0}</span><span class="delimiter">&quot;</span></span>, buffer);

                <span class="comment">// Tell the implementation that the buffer has been consumed.</span>
                data.release();

                <span class="keyword">if</span> (!data.frame().isEndStream())
                {
                    <span class="comment">// Demand more DATA frames when they are available.</span>
                    stream.demand();
                }
            }
        };
    }
};</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>onDataAvailable(Stream stream)</code> is invoked, the demand is implicitly cancelled.</p>
</div>
<div class="paragraph">
<p>Just returning from the <code>onDataAvailable(Stream stream)</code> method does <em>not</em> implicitly demand for more <code>DATA</code> frames.</p>
</div>
<div class="paragraph">
<p>Applications must call <code>Stream.demand()</code> to explicitly require that <code>onDataAvailable(Stream stream)</code> is invoked again when more <code>DATA</code> frames are available.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications that consume the content buffer within <code>onDataAvailable(Stream stream)</code> (for example, writing it to a file, or copying the bytes to another storage) should call <code>Data.release()</code> as soon as they have consumed the content buffer.
This allows the implementation to reuse the buffer, reducing the memory requirements needed to handle the content buffers.</p>
</div>
<div class="paragraph">
<p>Alternatively, an application may store away the <code>Data</code> object to consume the buffer bytes later, or pass the <code>Data</code> object to another asynchronous API (this is typical in proxy applications).</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The call to <code>Stream.readData()</code> tells the implementation to enlarge the stream and session flow control windows so that the sender will be able to send more <code>DATA</code> frames without stalling.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications can unwrap the <code>Data</code> object into some other object that may be used later, provided that the <em>release</em> semantic is maintained:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">record Chunk(<span class="predefined-type">ByteBuffer</span> byteBuffer, <span class="predefined-type">Callback</span> callback)
{
}

<span class="comment">// A queue that consumers poll to consume content asynchronously.</span>
<span class="predefined-type">Queue</span>&lt;Chunk&gt; dataQueue = <span class="keyword">new</span> <span class="predefined-type">ConcurrentLinkedQueue</span>&lt;&gt;();

<span class="comment">// Implementation of Stream.Listener.onDataAvailable(Stream stream)</span>
<span class="comment">// in case of unwrapping of the Data object for asynchronous content</span>
<span class="comment">// consumption and demand.</span>
Stream.Listener listener = <span class="keyword">new</span> Stream.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
    {
        Stream.Data data = stream.readData();

        <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
        {
            stream.demand();
            <span class="keyword">return</span>;
        }

        <span class="comment">// Get the content buffer.</span>
        <span class="predefined-type">ByteBuffer</span> byteBuffer = data.frame().getByteBuffer();

        <span class="comment">// Unwrap the Data object, converting it to a Chunk.</span>
        <span class="comment">// The Data.release() semantic is maintained in the completion of the Callback.</span>
        dataQueue.offer(<span class="keyword">new</span> Chunk(byteBuffer, <span class="predefined-type">Callback</span>.from(() -&gt;
        {
            <span class="comment">// When the buffer has been consumed, then:</span>
            <span class="comment">// A) release the Data object.</span>
            data.release();
            <span class="comment">// B) possibly demand more DATA frames.</span>
            <span class="keyword">if</span> (!data.frame().isEndStream())
                stream.demand();
        })));

        <span class="comment">// Do not demand more data here, to avoid to overflow the queue.</span>
    }
};</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Applications that implement <code>onDataAvailable(Stream stream)</code> must remember to call <code>Stream.demand()</code> eventually.</p>
</div>
<div class="paragraph">
<p>If they do not call <code>Stream.demand()</code>, the implementation will not invoke <code>onDataAvailable(Stream stream)</code> to deliver more <code>DATA</code> frames and the application will stall threadlessly until an idle timeout fires to close the stream or the session.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-response"><a class="anchor" href="#pg-server-http2-response"></a><a class="link" href="#pg-server-http2-response">Sending a Response</a></h4>
<div class="paragraph">
<p>After receiving an HTTP request, a server application must send an HTTP response.</p>
</div>
<div class="paragraph">
<p>An HTTP response is typically composed of a <code>HEADERS</code> frame containing the HTTP status code and the response headers, and optionally one or more <code>DATA</code> frames containing the response content bytes.</p>
</div>
<div class="paragraph">
<p>The HTTP/2 protocol also supports response trailers (that is, headers that are sent after the response content) that also are sent using a <code>HEADERS</code> frame.</p>
</div>
<div class="paragraph">
<p>A server application can send a response in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onNewStream(Stream stream, HeadersFrame frame)
    {
        <span class="comment">// Send a response after reading the request.</span>
        MetaData.Request request = (MetaData.Request)frame.getMetaData();
        <span class="keyword">if</span> (frame.isEndStream())
        {
            respond(stream, request);
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Demand for request data.</span>
            stream.demand();

            <span class="comment">// Return a listener to handle the request events.</span>
            <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
            {
                <span class="annotation">@Override</span>
                <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream stream)
                {
                    Stream.Data data = stream.readData();

                    <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
                    {
                        stream.demand();
                        <span class="keyword">return</span>;
                    }

                    <span class="comment">// Consume the request content.</span>
                    data.release();

                    <span class="keyword">if</span> (data.frame().isEndStream())
                        respond(stream, request);
                    <span class="keyword">else</span>
                        stream.demand();
                }
            };
        }
    }

    <span class="directive">private</span> <span class="type">void</span> respond(Stream stream, MetaData.Request request)
    {
        <span class="comment">// Prepare the response HEADERS frame.</span>

        <span class="comment">// The response HTTP status and HTTP headers.</span>
        MetaData.Response response = <span class="keyword">new</span> MetaData.Response(HttpStatus.OK_200, <span class="predefined-constant">null</span>, HttpVersion.HTTP_2, HttpFields.EMPTY);

        <span class="keyword">if</span> (HttpMethod.GET.is(request.getMethod()))
        {
            <span class="comment">// The response content.</span>
            <span class="predefined-type">ByteBuffer</span> resourceBytes = getResourceBytes(request);

            <span class="comment">// Send the HEADERS frame with the response status and headers,</span>
            <span class="comment">// and a DATA frame with the response content bytes.</span>
            stream.headers(<span class="keyword">new</span> HeadersFrame(stream.getId(), response, <span class="predefined-constant">null</span>, <span class="predefined-constant">false</span>))
                .thenCompose(s -&gt; s.data(<span class="keyword">new</span> DataFrame(s.getId(), resourceBytes, <span class="predefined-constant">true</span>)));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Send just the HEADERS frame with the response status and headers.</span>
            stream.headers(<span class="keyword">new</span> HeadersFrame(stream.getId(), response, <span class="predefined-constant">null</span>, <span class="predefined-constant">true</span>));
        }
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-reset"><a class="anchor" href="#pg-server-http2-reset"></a><a class="link" href="#pg-server-http2-reset">Resetting a Request</a></h4>
<div class="paragraph">
<p>A server application may decide that it does not want to accept the request.
For example, it may throttle the client because it sent too many requests in a time window, or the request is invalid (and does not deserve a proper HTTP response), etc.</p>
</div>
<div class="paragraph">
<p>A request can be reset in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onNewStream(Stream stream, HeadersFrame frame)
    {
        <span class="type">float</span> requestRate = calculateRequestRate();

        <span class="keyword">if</span> (requestRate &gt; maxRequestRate)
        {
            stream.reset(<span class="keyword">new</span> ResetFrame(stream.getId(), ErrorCode.REFUSED_STREAM_ERROR.code), <span class="predefined-type">Callback</span>.NOOP);
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// The request is accepted.</span>
            MetaData.Request request = (MetaData.Request)frame.getMetaData();
            <span class="comment">// Return a Stream.Listener to handle the request events.</span>
            <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
            {
                <span class="comment">// Override callback methods for events you are interested in.</span>
            };
        }
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http2-push"><a class="anchor" href="#pg-server-http2-push"></a><a class="link" href="#pg-server-http2-push">HTTP/2 Push of Resources</a></h4>
<div class="paragraph">
<p>A server application may <em>push</em> secondary resources related to a primary resource.</p>
</div>
<div class="paragraph">
<p>A client may inform the server that it does not accept pushed resources(see <a href="https://tools.ietf.org/html/rfc7540#section-8.2">this section</a> of the specification) via a <code>SETTINGS</code> frame.
Server applications must track <code>SETTINGS</code> frames and verify whether the client supports HTTP/2 push, and only push if the client supports it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// The favicon bytes.</span>
<span class="predefined-type">ByteBuffer</span> faviconBuffer = BufferUtil.toBuffer(ResourceFactory.root().newResource(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/favicon.ico</span><span class="delimiter">&quot;</span></span>), <span class="predefined-constant">true</span>);

ServerSessionListener sessionListener = <span class="keyword">new</span> ServerSessionListener()
{
    <span class="comment">// By default, push is enabled.</span>
    <span class="directive">private</span> <span class="type">boolean</span> pushEnabled = <span class="predefined-constant">true</span>;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onSettings(Session session, SettingsFrame frame)
    {
        <span class="comment">// Check whether the client sent an ENABLE_PUSH setting.</span>
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Integer</span>, <span class="predefined-type">Integer</span>&gt; settings = frame.getSettings();
        <span class="predefined-type">Integer</span> enablePush = settings.get(SettingsFrame.ENABLE_PUSH);
        <span class="keyword">if</span> (enablePush != <span class="predefined-constant">null</span>)
            pushEnabled = enablePush == <span class="integer">1</span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Listener onNewStream(Stream stream, HeadersFrame frame)
    {
        MetaData.Request request = (MetaData.Request)frame.getMetaData();
        <span class="keyword">if</span> (pushEnabled &amp;&amp; request.getHttpURI().toString().endsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/index.html</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="comment">// Push the favicon.</span>
            HttpURI pushedURI = HttpURI.build(request.getHttpURI()).path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/favicon.ico</span><span class="delimiter">&quot;</span></span>);
            MetaData.Request pushedRequest = <span class="keyword">new</span> MetaData.Request(<span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>, pushedURI, HttpVersion.HTTP_2, HttpFields.EMPTY);
            PushPromiseFrame promiseFrame = <span class="keyword">new</span> PushPromiseFrame(stream.getId(), <span class="integer">0</span>, pushedRequest);
            stream.push(promiseFrame, <span class="predefined-constant">null</span>)
                .thenCompose(pushedStream -&gt;
                {
                    <span class="comment">// Send the favicon &quot;response&quot;.</span>
                    MetaData.Response pushedResponse = <span class="keyword">new</span> MetaData.Response(HttpStatus.OK_200, <span class="predefined-constant">null</span>, HttpVersion.HTTP_2, HttpFields.EMPTY);
                    <span class="keyword">return</span> pushedStream.headers(<span class="keyword">new</span> HeadersFrame(pushedStream.getId(), pushedResponse, <span class="predefined-constant">null</span>, <span class="predefined-constant">false</span>))
                        .thenCompose(pushed -&gt; pushed.data(<span class="keyword">new</span> DataFrame(pushed.getId(), faviconBuffer.slice(), <span class="predefined-constant">true</span>)));
                });
        }
        <span class="comment">// Return a Stream.Listener to handle the request events.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Listener()
        {
            <span class="comment">// Override callback methods for events you are interested in.</span>
        };
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-http3"><a class="anchor" href="#pg-server-http3"></a><a class="link" href="#pg-server-http3">HTTP/3 Server Library</a></h3>
<div class="paragraph">
<p>In the vast majority of cases, server applications should use the generic, high-level, <a href="#pg-server-http">HTTP server library</a> that also provides HTTP/3 support via the HTTP/3 connector and <code>ConnectionFactory</code>s as described in details <a href="#pg-server-http-connector-protocol-http3">here</a>.</p>
</div>
<div class="paragraph">
<p>The low-level HTTP/3 server library has been designed for those applications that need low-level access to HTTP/3 features such as <em>sessions</em>, <em>streams</em> and <em>frames</em>, and this is quite a rare use case.</p>
</div>
<div class="paragraph">
<p>See also the correspondent <a href="#pg-client-http3">HTTP/3 client library</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-server-http3-intro"><a class="anchor" href="#pg-server-http3-intro"></a><a class="link" href="#pg-server-http3-intro">Introduction</a></h4>
<div class="paragraph">
<p>The Maven artifact coordinates for the HTTP/3 client library are the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.http3<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-http3-server<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>HTTP/3 is a multiplexed protocol because it relies on the multiplexing capabilities of QUIC, the protocol based on UDP that transports HTTP/3 frames.
Thanks to multiplexing, multiple HTTP/3 requests are sent on the same QUIC connection, or <em>session</em>.
Each request/response cycle is represented by a <em>stream</em>.
Therefore, a single <em>session</em> manages multiple concurrent <em>streams</em>.
A <em>stream</em> has typically a very short life compared to the <em>session</em>: a <em>stream</em> only exists for the duration of the request/response cycle and then disappears.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http3-setup"><a class="anchor" href="#pg-server-http3-setup"></a><a class="link" href="#pg-server-http3-setup">Server Setup</a></h4>
<div class="paragraph">
<p>The low-level HTTP/3 support is provided by <code>org.eclipse.jetty.http3.server.RawHTTP3ServerConnectionFactory</code> and <code>org.eclipse.jetty.http3.api.Session.Server.Listener</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server instance.</span>
Server server = <span class="keyword">new</span> Server();

<span class="comment">// HTTP/3 is always secure, so it always need a SslContextFactory.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// The listener for session events.</span>
Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener() {};

ServerQuicConfiguration quicConfiguration = <span class="keyword">new</span> ServerQuicConfiguration(sslContextFactory, Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/pem/dir</span><span class="delimiter">&quot;</span></span>));
<span class="comment">// Configure the max number of requests per QUIC connection.</span>
quicConfiguration.setMaxBidirectionalRemoteStreams(<span class="integer">1024</span>);

<span class="comment">// Create and configure the RawHTTP3ServerConnectionFactory.</span>
RawHTTP3ServerConnectionFactory http3 = <span class="keyword">new</span> RawHTTP3ServerConnectionFactory(quicConfiguration, sessionListener);
http3.getHTTP3Configuration().setStreamIdleTimeout(<span class="integer">15000</span>);

<span class="comment">// Create and configure the QuicServerConnector.</span>
QuicServerConnector connector = <span class="keyword">new</span> QuicServerConnector(server, quicConfiguration, http3);

<span class="comment">// Add the Connector to the Server.</span>
server.addConnector(connector);

<span class="comment">// Start the Server so it starts accepting connections from clients.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where server applications using the <a href="#pg-server-http">high-level server library</a> deal with HTTP requests and responses in <code>Handler</code>s, server applications using the low-level HTTP/3 server library deal directly with HTTP/3 <em>session</em>s, <em>stream</em>s and <em>frame</em>s in a <code>Session.Server.Listener</code> implementation.</p>
</div>
<div class="paragraph">
<p>The <code>Session.Server.Listener</code> interface defines a number of methods that are invoked by the implementation upon the occurrence of HTTP/3 events, and that server applications can override to react to those events.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>Session.Server.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http3/api/Session.Server.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>The first event is the <em>accept</em> event and happens when a client opens a new QUIC connection to the server and the server accepts the connection.
This is the first occasion where server applications have access to the HTTP/3 <code>Session</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onAccept(Session session)
    {
        <span class="predefined-type">SocketAddress</span> remoteAddress = session.getRemoteSocketAddress();
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http3</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Connection from {0}</span><span class="delimiter">&quot;</span></span>, remoteAddress);
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the QUIC connection has been established, both client and server send an HTTP/3 <code>SETTINGS</code> frame to exchange their HTTP/3 configuration.
This generates the <em>preface</em> event, where applications can customize the HTTP/3 settings by returning a map of settings that the implementation will send to the other peer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Long</span>&gt; onPreface(Session session)
    {
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">Long</span>, <span class="predefined-type">Long</span>&gt; settings = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

        <span class="comment">// Customize the settings</span>

        <span class="keyword">return</span> settings;
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http3-request"><a class="anchor" href="#pg-server-http3-request"></a><a class="link" href="#pg-server-http3-request">Receiving a Request</a></h4>
<div class="paragraph">
<p>Receiving an HTTP request from the client, and sending a response, creates a <em>stream</em> that encapsulates the exchange of HTTP/3 frames that compose the request and the response.</p>
</div>
<div class="paragraph">
<p>An HTTP request is made of a <code>HEADERS</code> frame, that carries the request method, the request URI and the request headers, and optional <code>DATA</code> frames that carry the request content.</p>
</div>
<div class="paragraph">
<p>Receiving the <code>HEADERS</code> frame opens the <code>Stream</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Server.Listener onRequest(Stream.Server stream, HeadersFrame frame)
    {
        MetaData.Request request = (MetaData.Request)frame.getMetaData();

        <span class="comment">// Return a Stream.Server.Listener to handle the request events,</span>
        <span class="comment">// for example request content events or a request reset.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Server.Listener() {};
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Server applications should return a <code>Stream.Server.Listener</code> implementation from <code>onRequest(&#8230;&#8203;)</code> to be notified of events generated by the client, such as <code>DATA</code> frames carrying request content, or a reset event indicating that the client wants to <em>reset</em> the request, or an idle timeout event indicating that the client was supposed to send more frames but it did not.</p>
</div>
<div class="paragraph">
<p>The example below shows how to receive request content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Server.Listener onRequest(Stream.Server stream, HeadersFrame frame)
    {
        MetaData.Request request = (MetaData.Request)frame.getMetaData();

        <span class="comment">// Demand to be called back when data is available.</span>
        stream.demand();

        <span class="comment">// Return a Stream.Server.Listener to handle the request content.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> Stream.Server.Listener()
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream.Server stream)
            {
                <span class="comment">// Read a chunk of the request content.</span>
                Stream.Data data = stream.readData();

                <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
                {
                    <span class="comment">// No data available now, demand to be called back.</span>
                    stream.demand();
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// Get the content buffer.</span>
                    <span class="predefined-type">ByteBuffer</span> buffer = data.getByteBuffer();

                    <span class="comment">// Consume the buffer, here - as an example - just log it.</span>
                    <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">http3</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Consuming buffer {0}</span><span class="delimiter">&quot;</span></span>, buffer);

                    <span class="comment">// Tell the implementation that the buffer has been consumed.</span>
                    data.release();

                    <span class="keyword">if</span> (!data.isLast())
                    {
                        <span class="comment">// Demand to be called back.</span>
                        stream.demand();
                    }
                }
            }
        };
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http3-response"><a class="anchor" href="#pg-server-http3-response"></a><a class="link" href="#pg-server-http3-response">Sending a Response</a></h4>
<div class="paragraph">
<p>After receiving an HTTP request, a server application must send an HTTP response.</p>
</div>
<div class="paragraph">
<p>An HTTP response is typically composed of a <code>HEADERS</code> frame containing the HTTP status code and the response headers, and optionally one or more <code>DATA</code> frames containing the response content bytes.</p>
</div>
<div class="paragraph">
<p>The HTTP/3 protocol also supports response trailers (that is, headers that are sent after the response content) that also are sent using a <code>HEADERS</code> frame.</p>
</div>
<div class="paragraph">
<p>A server application can send a response in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Server.Listener onRequest(Stream.Server stream, HeadersFrame frame)
    {
        <span class="comment">// Send a response after reading the request.</span>
        MetaData.Request request = (MetaData.Request)frame.getMetaData();
        <span class="keyword">if</span> (frame.isLast())
        {
            respond(stream, request);
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Demand to be called back when data is available.</span>
            stream.demand();
            <span class="keyword">return</span> <span class="keyword">new</span> Stream.Server.Listener()
            {
                <span class="annotation">@Override</span>
                <span class="directive">public</span> <span class="type">void</span> onDataAvailable(Stream.Server stream)
                {
                    Stream.Data data = stream.readData();
                    <span class="keyword">if</span> (data == <span class="predefined-constant">null</span>)
                    {
                        stream.demand();
                    }
                    <span class="keyword">else</span>
                    {
                        <span class="comment">// Consume the request content.</span>
                        data.release();

                        <span class="keyword">if</span> (data.isLast())
                            respond(stream, request);
                        <span class="keyword">else</span>
                            stream.demand();
                    }
                }
            };
        }
    }

    <span class="directive">private</span> <span class="type">void</span> respond(Stream.Server stream, MetaData.Request request)
    {
        <span class="comment">// Prepare the response HEADERS frame.</span>

        <span class="comment">// The response HTTP status and HTTP headers.</span>
        MetaData.Response response = <span class="keyword">new</span> MetaData.Response(HttpStatus.OK_200, <span class="predefined-constant">null</span>, HttpVersion.HTTP_3, HttpFields.EMPTY);

        <span class="keyword">if</span> (HttpMethod.GET.is(request.getMethod()))
        {
            <span class="comment">// The response content.</span>
            <span class="predefined-type">ByteBuffer</span> resourceBytes = getResourceBytes(request);

            <span class="comment">// Send the HEADERS frame with the response status and headers,</span>
            <span class="comment">// and a DATA frame with the response content bytes.</span>
            stream.respond(<span class="keyword">new</span> HeadersFrame(response, <span class="predefined-constant">false</span>))
                .thenCompose(s -&gt; s.data(<span class="keyword">new</span> DataFrame(resourceBytes, <span class="predefined-constant">true</span>)));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Send just the HEADERS frame with the response status and headers.</span>
            stream.respond(<span class="keyword">new</span> HeadersFrame(response, <span class="predefined-constant">true</span>));
        }
    }
};</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-http3-reset"><a class="anchor" href="#pg-server-http3-reset"></a><a class="link" href="#pg-server-http3-reset">Resetting a Request</a></h4>
<div class="paragraph">
<p>A server application may decide that it does not want to accept the request.
For example, it may throttle the client because it sent too many requests in a time window, or the request is invalid (and does not deserve a proper HTTP response), etc.</p>
</div>
<div class="paragraph">
<p>A request can be reset in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Session.Server.Listener sessionListener = <span class="keyword">new</span> Session.Server.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> Stream.Server.Listener onRequest(Stream.Server stream, HeadersFrame frame)
    {
        <span class="type">float</span> requestRate = calculateRequestRate();

        <span class="keyword">if</span> (requestRate &gt; maxRequestRate)
        {
            stream.reset(HTTP3ErrorCode.REQUEST_REJECTED_ERROR.code(), <span class="keyword">new</span> <span class="exception">RejectedExecutionException</span>());
            <span class="keyword">return</span> <span class="predefined-constant">null</span>;
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// The request is accepted.</span>
            MetaData.Request request = (MetaData.Request)frame.getMetaData();
            <span class="comment">// Return a Stream.Listener to handle the request events.</span>
            <span class="keyword">return</span> <span class="keyword">new</span> Stream.Server.Listener() {};
        }
    }
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-compliance"><a class="anchor" href="#pg-server-compliance"></a><a class="link" href="#pg-server-compliance">Server Compliance Modes</a></h3>
<div class="paragraph">
<p>The Jetty server strives to keep up with the latest <a href="https://en.wikipedia.org/wiki/Request_for_Comments">IETF RFC</a>s for compliance with internet specifications, which are periodically updated.</p>
</div>
<div class="paragraph">
<p>When possible, Jetty will support backwards compatibility by providing compliance modes that can be configured to allow violations of the current specifications that may have been allowed in obsoleted specifications.</p>
</div>
<div class="paragraph">
<p>There are compliance modes provided for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pg-server-compliance-http">HTTP Compliance</a></p>
</li>
<li>
<p><a href="#pg-server-compliance-uri">URI Compliance</a></p>
</li>
<li>
<p><a href="#pg-server-compliance-cookie">Cookie Compliance</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Compliance modes can be configured to allow violations from the RFC requirements, or in some cases to allow additional behaviors that Jetty has implemented in excess of the RFC (for example, to allow <a href="#pg-server-compliance-uri">ambiguous URIs</a>).</p>
</div>
<div class="paragraph">
<p>For example, the HTTP RFCs require that request HTTP methods are <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.1">case sensitive</a>, however Jetty can allow case-insensitive HTTP methods by including the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.Violation.html#CASE_INSENSITIVE_METHOD"><code>HttpCompliance.Violation.CASE_INSENSITIVE_METHOD</code></a> in the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.html"><code>HttpCompliance</code></a> set of allowed violations.</p>
</div>
<div class="sect3">
<h4 id="pg-server-compliance-http"><a class="anchor" href="#pg-server-compliance-http"></a><a class="link" href="#pg-server-compliance-http">HTTP Compliance Modes</a></h4>
<div class="paragraph">
<p>In 1995, when Jetty was first implemented, there were no RFC specification of HTTP, only a W3C specification for <a href="https://www.w3.org/Protocols/HTTP/AsImplemented.html">HTTP/0.9</a>, which has since been obsoleted or augmented by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc1945">RFC 1945</a> for HTTP/1.0 in 1996</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2068">RFC 2068</a> for HTTP/1.1  in 1997</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a> for HTTP/1.1 bis in 1999</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7231">RFC 7231</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7232">RFC 7232</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7233">RFC 7233</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7234">RFC 7234</a>, <a href="https://datatracker.ietf.org/doc/html/rfc7235">RFC 7235</a> again for HTTP/1.1 in 2014</p>
</li>
<li>
<p><a href="https://datatracker.ietf.org/doc/html/rfc7540">RFC 7540</a> for HTTP/2.0 in 2015</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to these evolving requirements, some earlier version of Jetty did not completely or strictly implement the RFC at the time (for example, case-insensitive HTTP methods).
Therefore, upgrading to a newer Jetty version may cause runtime behavior differences that may break your applications.</p>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.Violation.html"><code>HttpCompliance.Violation</code></a> enumeration defines the RFC requirements that may be optionally enforced by Jetty, to support legacy deployments. These possible violations are grouped into modes by the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.html"><code>HttpCompliance</code></a> class, which also defines several named modes that support common deployed sets of violations (with the default being <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.html#RFC7230"><code>HttpCompliance.RFC7230</code></a>).</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();
httpConfiguration.setHttpCompliance(HttpCompliance.RFC7230);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to customize the violations that you want to allow, you can create your own mode using the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCompliance.html#from(java.lang.String)"><code>HttpCompliance.from(String)</code></a> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// RFC7230 compliance, but allow Violation.MULTIPLE_CONTENT_LENGTHS.</span>
HttpCompliance customHttpCompliance = HttpCompliance.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">RFC7230,MULTIPLE_CONTENT_LENGTHS</span><span class="delimiter">&quot;</span></span>);

httpConfiguration.setHttpCompliance(customHttpCompliance);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-compliance-uri"><a class="anchor" href="#pg-server-compliance-uri"></a><a class="link" href="#pg-server-compliance-uri">URI Compliance Modes</a></h4>
<div class="paragraph">
<p>Universal Resource Locators (URLs) where initially formalized in 1994 in <a href="https://datatracker.ietf.org/doc/html/rfc1738">RFC 1738</a> and then refined in 1995 with relative URLs by <a href="https://datatracker.ietf.org/doc/html/rfc1808">RFC 1808</a>.</p>
</div>
<div class="paragraph">
<p>In 1998, URLs were generalized to Universal Resource Identifiers (URIs) by <a href="https://datatracker.ietf.org/doc/html/rfc2396">RFC 2396</a>, which also introduced features such a <a href="https://datatracker.ietf.org/doc/html/rfc2396#section-3.3">path parameter</a>s.</p>
</div>
<div class="paragraph">
<p>This was then obsoleted in 2005 by <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a> which removed the definition for path parameters.</p>
</div>
<div class="paragraph">
<p>Unfortunately by this stage the existence and use of such parameters had already been codified in the Servlet specification.
For example, the relative URI <code>/foo/bar;JSESSIONID=a8b38cd02b1c</code> would define the path parameter <code>JSESSIONID</code> for the path segment <code>bar</code>, but the most recent RFC does not specify a formal definition of what this relative URI actually means.</p>
</div>
<div class="paragraph">
<p>The current situation is that there may be URIs that are entirely valid for <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a>, but are ambiguous when handled by the Servlet APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A URI with <code>..</code> <em>and</em> path parameters such as <code>/some/..;/path</code> is not <a href="https://datatracker.ietf.org/doc/html/rfc3986#section-5.2"><em>resolved</em></a> by RFC 3986, since the resolution process only applies to the exact segment <code>..</code>, not to <code>..;</code>.
However, once the path parameters are removed by the Servlet APIs, the resulting <code>/some/../path</code> can easily be resolved to <code>/path</code>, rather than be treated as a path that has <code>..;</code> as a segment.</p>
</li>
<li>
<p>A URI such as <code>/some/%2e%2e/path</code> is not resolved by RFC 3986, yet when URL-decoded by the Servlet APIs will result in <code>/some/../path</code> which can easily be resolved to <code>/path</code>, rather than be treated as a path that has <code>..</code> as a segment.</p>
</li>
<li>
<p>A URI with empty segments like <code>/some//../path</code> may be correctly resolved to <code>/some/path</code> (the <code>..</code> removes the previous empty segment) by the Servlet APIs.
However, if the URI raw path is passed to some other APIs (for example, file system APIs) it can be interpreted as <code>/path</code> because the empty segment <code>//</code> is discarded and treated as <code>/</code>, and the <code>..</code> thus removes the <code>/some</code> segment.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to avoid ambiguous URIs, Jetty imposes additional URI requirements in excess of what is required by <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986</a> compliance.</p>
</div>
<div class="paragraph">
<p>These additional requirements may optionally be violated and are defined by the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/UriCompliance.Violation.html"><code>UriCompliance.Violation</code></a> enumeration.</p>
</div>
<div class="paragraph">
<p>These violations are then grouped into modes by the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/UriCompliance.html"><code>UriCompliance</code></a> class, which also defines several named modes that support common deployed sets of violations, with the default being <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/UriCompliance.html#DEFAULT"><code>UriCompliance.DEFAULT</code></a>.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();
httpConfiguration.setUriCompliance(UriCompliance.RFC3986);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to customize the violations that you want to allow, you can create your own mode using the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/UriCompliance.html#from(java.lang.String)"><code>UriCompliance.from(String)</code></a> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// RFC3986 compliance, but enforce Violation.AMBIGUOUS_PATH_SEPARATOR.</span>
UriCompliance customUriCompliance = UriCompliance.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">RFC3986,-AMBIGUOUS_PATH_SEPARATOR</span><span class="delimiter">&quot;</span></span>);

httpConfiguration.setUriCompliance(customUriCompliance);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-compliance-cookie"><a class="anchor" href="#pg-server-compliance-cookie"></a><a class="link" href="#pg-server-compliance-cookie">Cookie Compliance Modes</a></h4>
<div class="paragraph">
<p>The standards for Cookies have varied greatly over time from a non-specified but de-facto standard (implemented by the first browsers), through <a href="https://tools.ietf.org/html/rfc2965">RFC 2965</a> and currently to <a href="https://tools.ietf.org/html/rfc6265">RFC 6265</a>.</p>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/CookieCompliance.Violation.html">CookieCompliance.Violation</a> enumeration defines the RFC requirements that may be optionally enforced by Jetty when parsing the <code>Cookie</code> HTTP header in requests and when generating the <code>Set-Cookie</code> HTTP header in responses.</p>
</div>
<div class="paragraph">
<p>These violations are then grouped into modes by the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/CookieCompliance.html"><code>CookieCompliance</code></a> class, which also defines several named modes that support common deployed sets of violations, with the default being <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/CookieCompliance.html#RFC6265"><code>CookieCompliance.RFC6265</code></a>.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();
httpConfiguration.setRequestCookieCompliance(CookieCompliance.RFC6265);
httpConfiguration.setResponseCookieCompliance(CookieCompliance.RFC6265);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to customize the violations that you want to allow, you can create your own mode using the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/CookieCompliance.html#from(java.lang.String)"><code>CookieCompliance.from(String)</code></a> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();

<span class="comment">// RFC6265 compliance, but enforce Violation.RESERVED_NAMES_NOT_DOLLAR_PREFIXED.</span>
CookieCompliance customUriCompliance = CookieCompliance.from(<span class="string"><span class="delimiter">&quot;</span><span class="content">RFC6265,-RESERVED_NAMES_NOT_DOLLAR_PREFIXED</span><span class="delimiter">&quot;</span></span>);
httpConfiguration.setRequestCookieCompliance(customUriCompliance);

httpConfiguration.setResponseCookieCompliance(CookieCompliance.RFC6265);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-session"><a class="anchor" href="#pg-server-session"></a><a class="link" href="#pg-server-session">HTTP Session Management</a></h3>
<div class="paragraph">
<p>Sessions are a concept within the Servlet API which allow requests to store and retrieve information across the time a user spends in an application.</p>
</div>
<div class="sect3">
<h4 id="pg-server-session-architecture"><a class="anchor" href="#pg-server-session-architecture"></a><a class="link" href="#pg-server-session-architecture">Session Architecture</a></h4>
<div class="paragraph">
<p>Jetty session support has been architected to provide a core implementation that is independent of the Servlet specification.
This allows programmers who use core Jetty - without the Servlet API - to still have classic Servlet session-like support for their <code>Request</code>s and <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>These core classes are adapted to each of the various Servlet specification environments to deliver classic <code>HttpSession</code>s for <code>Servlet</code>s,`Filter``s, etc</p>
</div>
<div class="paragraph">
<p>Full support for the session lifecycle is supported, in addition to L1 and L2 caching, and a number of pluggable options for persisting session data.</p>
</div>
<div class="paragraph">
<p>Here are some of the most important concepts that will be referred to throughout the documentation:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">SessionIdManager</dt>
<dd>
<p>responsible for allocation of unique session ids.</p>
</dd>
<dt class="hdlist1">HouseKeeper</dt>
<dd>
<p>responsible for orchestrating the detection and removal of expired sessions.</p>
</dd>
<dt class="hdlist1">SessionManager</dt>
<dd>
<p>responsible for managing the lifecycle of sessions.</p>
</dd>
<dt class="hdlist1">SessionHandler</dt>
<dd>
<p>an implementation of <code>SessionManager</code> that adapts sessions to either the core or Servlet specification environment.</p>
</dd>
<dt class="hdlist1">SessionCache</dt>
<dd>
<p>an L1 cache of in-use <code>ManagedSession</code> objects</p>
</dd>
<dt class="hdlist1">Session</dt>
<dd>
<p>a session consisting of <code>SessionData</code> that can be associated with a <code>Request</code></p>
</dd>
<dt class="hdlist1">ManagedSession</dt>
<dd>
<p>a <code>Session</code> that supports caching and lifecycle management</p>
</dd>
<dt class="hdlist1">SessionData</dt>
<dd>
<p>encapsulates the attributes and metadata associated with a <code>Session</code></p>
</dd>
<dt class="hdlist1">SessionDataStore</dt>
<dd>
<p>responsible for creating, persisting and reading <code>SessionData</code></p>
</dd>
<dt class="hdlist1">CachingSessionDataStore</dt>
<dd>
<p>an L2 cache of <code>SessionData</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Diagrammatically, these concepts can be represented as:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-0b755eaa8b60b08e2a661025a11715e1.png" alt="Diagram" width="831" height="441">
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-session-idmgr"><a class="anchor" href="#pg-server-session-idmgr"></a><a class="link" href="#pg-server-session-idmgr">The SessionIdManager</a></h4>
<div class="paragraph">
<p>There is a maximum of one <code>SessionIdManager</code> per <code>Server</code> instance.
Its purpose is to generate fresh, unique session ids and to coordinate the re-use of session ids amongst co-operating contexts.</p>
</div>
<div class="paragraph">
<p>The <code>SessionIdManager</code> is agnostic with respect to the type of clustering technology chosen.</p>
</div>
<div class="paragraph">
<p>Jetty provides a default implementation - the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionIdManager.html">DefaultSessionIdManager</a>  - which should meet the needs of most users.</p>
</div>
<div class="sect4">
<h5 id="pg-server-session-defaultidmgr"><a class="anchor" href="#pg-server-session-defaultidmgr"></a><a class="link" href="#pg-server-session-defaultidmgr">The DefaultSessionIdManager</a></h5>
<div id="pg-server-session-workername" class="paragraph">
<p>A single instance of the <code>DefaultSessionIdManager</code> should be created and registered as a bean on the <code>Server</code> instance so that all <code>SessionHandler</code>'s share the same instance.
This is done by the Jetty <code>session</code> module, but can be done programmatically instead.
As a fallback, when an individual <code>SessionHandler</code> starts up, if it does not find the <code>SessionIdManager</code> already present for the <code>Server</code> it will create and register a bean for it.
That instance will be shared by the other <code>SessionHandler</code>s.</p>
</div>
<div class="paragraph">
<p>The most important configuration parameter for the <code>DefaultSessionIdManager</code> is the <code>workerName</code>, which uniquely identifies the server in a cluster.
If a <code>workerName</code> has not been explicitly set, then the value is derived as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>node[JETTY_WORKER_NAME]</pre>
</div>
</div>
<div class="paragraph">
<p>where <code>JETTY_WORKER_NAME</code> is an environment variable whose value can be an integer or string.
If the environment variable is not set, then it defaults to <code>0</code>, yielding the default <code>workerName</code> of <code>"node0"</code>.
It is <em>essential</em> to change this default if you have more than one <code>Server</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example of explicitly setting up a <code>DefaultSessionIdManager</code> with a <code>workerName</code> of <code>server3</code> in code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
DefaultSessionIdManager idMgr = <span class="keyword">new</span> DefaultSessionIdManager(server);
<span class="comment">//you must set the workerName unless you set the env viable JETTY_WORKER_NAME</span>
idMgr.setWorkerName(<span class="string"><span class="delimiter">&quot;</span><span class="content">server3</span><span class="delimiter">&quot;</span></span>);
server.addBean(idMgr, <span class="predefined-constant">true</span>);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-housekeeper"><a class="anchor" href="#pg-server-session-housekeeper"></a><a class="link" href="#pg-server-session-housekeeper">The HouseKeeper</a></h5>
<div class="paragraph">
<p>The <code>DefaultSessionIdManager</code> creates a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/HouseKeeper.html">HouseKeeper</a>, which periodically scans for, and eliminates, expired sessions (referred to as "scavenging").
The period of the scan is controlled by the <code>setIntervalSec(int)</code> method, defaulting to 600secs.
Setting a negative or 0 value prevents scavenging occurring.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>HouseKeeper</code> semi-randomly adds 10% to the configured <code>intervalSec</code>.
This is to help prevent sync-ing up of servers in a cluster that are all restarted at once, and slightly stagger their scavenge cycles to ensure any load on the persistent storage mechanism is spread out.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example of creating and configuring a <code>HouseKeeper</code> for the <code>DefaultSessionIdManager</code> in code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
DefaultSessionIdManager idMgr = <span class="keyword">new</span> DefaultSessionIdManager(server);
idMgr.setWorkerName(<span class="string"><span class="delimiter">&quot;</span><span class="content">server7</span><span class="delimiter">&quot;</span></span>);
server.addBean(idMgr, <span class="predefined-constant">true</span>);

HouseKeeper houseKeeper = <span class="keyword">new</span> HouseKeeper();
houseKeeper.setSessionIdManager(idMgr);
<span class="comment">//set the frequency of scavenge cycles</span>
houseKeeper.setIntervalSec(<span class="integer">600L</span>);
idMgr.setSessionHouseKeeper(houseKeeper);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-implementing-a-custom-sessionidmanager"><a class="anchor" href="#pg-implementing-a-custom-sessionidmanager"></a><a class="link" href="#pg-implementing-a-custom-sessionidmanager">Implementing a Custom SessionIdManager</a></h5>
<div class="paragraph">
<p>If the <code>DefaultSessionIdManager</code> does not meet your needs, you can extend it, or implement the <code>SessionIdManager</code> interface directly.</p>
</div>
<div class="paragraph">
<p>When implementing a <code>SessionIdManager</code> pay particular attention to the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <code>getWorkerName()</code> method <em>must</em> return a name that is unique to the <code>Server</code> instance.
The <code>workerName</code> becomes important in clustering scenarios because sessions can migrate from node to node:  the <code>workerName</code> identifies which node was last managing a <code>Session</code>.</p>
</li>
<li>
<p>the contract of the <code>isIdInUse(String id)</code> method is very specific: a session id may <em>only</em> be reused <em>iff</em> it is already in use by another context.
This restriction is important to support cross-context dispatch.</p>
</li>
<li>
<p>you should be <em>very</em> careful to ensure that the <code>newSessionId(HttpServletRequest request, long created)</code> method does not return duplicate or predictable session ids.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-session-handler"><a class="anchor" href="#pg-server-session-handler"></a><a class="link" href="#pg-server-session-handler">The SessionHandler</a></h4>
<div class="paragraph">
<p>A <code>SessionHandler</code> is a <code>Handler</code> that implements the <code>SessionManager</code>, and is thus responsible for the creation, maintenance and propagation of sessions.
There are <code>SessionHandlers</code> for both the core and the various Servlet environments.</p>
</div>
<div class="paragraph">
<p>Note that in the Servlet environments, each <code>ServletContextHandler</code> or <code>WebAppContext</code> has at most a single <code>SessionHandler</code>.</p>
</div>
<div class="paragraph">
<p>Both core and Servlet environment <code>SessionHandlers</code> can be configured programmatically.
Here are some of the most important methods that you may call to customize your session setup.
Note that in Servlet environments, some of these methods also have analogous Servlet API methods and/or analogous <code>web.xml</code> declarations and also equivalent  context init params.
These alternatives are noted below.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setCheckingRemoteSessionIdEncoding(boolean)  <em>[Default:false]</em> </dt>
<dd>
<p>This controls whether response urls will be encoded with the session id as a path parameter when the URL is destined for a remote node.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.jetty.session.CheckingRemoteSessionIdEncoding</code> context init parameter</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setMaxInactiveInterval(int) <em>[Default:-1]</em> </dt>
<dd>
<p>This is the amount of time in seconds after which an unused session may be scavenged.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>&lt;session-config&gt;&lt;session-timeout/&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code> (NOTE! this element is specified in <em>minutes</em> but this method uses <em>seconds</em>).</p>
</li>
<li>
<p><code>ServletContext.setSessionTimeout(int)</code> where the timeout is configured in <em>minutes</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setHttpOnly(boolean) <em>[Default:false]</em> </dt>
<dd>
<p>If <code>true</code>, the session cookie will not be exposed to client-side scripting code.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>SessionCookieConfig.setHttpOnly(boolean)</code></p>
</li>
<li>
<p><code>&lt;session-config&gt;&lt;cookie-config&gt;&lt;http-only/&gt;&lt;/cookie-config&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div id="pg-server-session-handler-refreshcookie" class="dlist">
<dl>
<dt class="hdlist1">setRefreshCookieAge(int) <em>[Default:-1]</em> </dt>
<dd>
<p>Value in seconds that controls resetting the session cookie when <code>SessionCookieConfig.setMaxAge(int)</code> is non-zero.
See also <a href="#pg-server-session-handler-maxAge">setting the max session cookie age with an init parameter</a>.
If the amount of time since the session cookie was last set exceeds this time, the session cookie is regenerated to keep the session cookie valid.</p>
</dd>
<dt class="hdlist1">setSameSite(HttpCookie.SameSite) <em>[Default:null]</em> </dt>
<dd>
<p>The values are <code>HttpCookie.SameSite.NONE</code>, <code>HttpCookie.SameSite.STRICT</code>, <code>HttpCookie.SameSite.LAX</code>.</p>
</dd>
<dt class="hdlist1">setSecureRequestOnly(boolean) <em>[Default:true]</em></dt>
<dd>
<p>If <code>true</code> and the request is HTTPS, the set session cookie will be marked as <code>secure</code>, meaning the client will only send the session cookie to the server on subsequent requests over HTTPS.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>SessionCookieConfig.setSecure(true)</code>, in which case the set session cookie will <em>always</em> be marked as <code>secure</code>, even if the request triggering the creation of the cookie was not over HTTPS.</p>
</li>
<li>
<p><code>&lt;session-config&gt;&lt;cookie-config&gt;&lt;secure/&gt;&lt;/cookie-config&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setSessionCookie(String) <em>[Default:"JSESSIONID"]</em></dt>
<dd>
<p>This is the name of the session cookie.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>SessionCookieConfig.setName(String)</code></p>
</li>
<li>
<p><code>&lt;session-config&gt;&lt;cookie-config&gt;&lt;name/&gt;&lt;/cookie-config&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code></p>
</li>
<li>
<p><code>org.eclipse.jetty.session.SessionCookie</code> context init parameter.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setSessionIdPathParameterName(String) <em>[Default:"jsessionid"]</em></dt>
<dd>
<p>This is the name of the path parameter used to transmit the session id on request URLs, and on encoded URLS in responses.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.jetty.session.SessionIdPathParameterName</code> context init parameter</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setSessionTrackingModes(Set&lt;SessionTrackingMode&gt;) <em>[Default:{<code>SessionTrackingMode.COOKIE</code>, <code>SessionTrackingMode.URL</code>}]</em></dt>
<dd>
<p><em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ServletContext.setSessionTrackingModes&lt;Set&lt;SessionTrackingMode&gt;)</code></p>
</li>
<li>
<p>defining up to three <code>&lt;tracking-mode&gt;</code>s for the <code>&lt;session-config&gt;</code> element in <code>web.xml</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setUsingCookies(boolean) <em>[Default:true]</em> </dt>
<dd>
<p>Determines whether the <code>SessionHandler</code> will look for session cookies on requests, and will set session cookies on responses.
If <code>false</code> session ids must be transmitted as path params on URLs.</p>
</dd>
</dl>
</div>
<div id="pg-server-session-handler-maxAge" class="dlist">
<dl>
<dt class="hdlist1">setMaxAge(int) <em>[Default:-1]</em></dt>
<dd>
<p>This is the maximum number of seconds that the session cookie will be considered to be valid.
By default, the cookie has no maximum validity time.
See also <a href="#pg-server-session-handler-refreshcookie">refreshing the session cookie</a>.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ServletContext.getSessionCookieConfig().setMaxAge(int)</code></p>
</li>
<li>
<p><code>org.eclipse.jetty.session.MaxAge</code> context init parameter</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setSessionDomain(String) <em>[Default:null]</em> </dt>
<dd>
<p>This is the domain of the session cookie.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ServletContext.getSessionCookieConfig().setDomain(String)</code></p>
</li>
<li>
<p><code>&lt;session-config&gt;&lt;cookie-config&gt;&lt;domain/&gt;&lt;/cookie-config&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code></p>
</li>
<li>
<p><code>org.eclipse.jetty.session.SessionDomain</code> context init parameter</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setSessionPath(String) <em>[Default:null]</em></dt>
<dd>
<p>This is used when creating a new session cookie.
If nothing is configured, the context path is used instead, defaulting to <code>/</code>.<br>
<em>Servlet environment alternatives:</em></p>
<div class="ulist">
<ul>
<li>
<p><code>ServletContext.getSessionCookieConfig().setPath(String)</code></p>
</li>
<li>
<p><code>&lt;session-config&gt;&lt;cookie-config&gt;&lt;path/&gt;&lt;/cookie-config&gt;&lt;/session-config&gt;</code> element in <code>web.xml</code></p>
</li>
<li>
<p><code>org.eclipse.jetty.session.SessionPath</code> context init parameter</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="pg-statistics"><a class="anchor" href="#pg-statistics"></a><a class="link" href="#pg-statistics">Statistics</a></h5>
<div class="paragraph">
<p>Some statistics about the sessions for a context can be obtained from the <code>SessionHandler</code>, either by calling the methods directly or via JMX:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">getSessionsCreated()</dt>
<dd>
<p>This is the total number of sessions that have been created for this context since Jetty started.</p>
</dd>
<dt class="hdlist1">getSessionTimeMax()</dt>
<dd>
<p>The longest period of time a session was valid in this context before being invalidated.</p>
</dd>
<dt class="hdlist1">getSessionTimeMean()</dt>
<dd>
<p>The average period of time a session in this context was valid.</p>
</dd>
<dt class="hdlist1">getSessionTimeStdDev()</dt>
<dd>
<p>The standard deviation of the session validity times for this context.</p>
</dd>
<dt class="hdlist1">getSessionTimeTotal()</dt>
<dd>
<p>The total time that all sessions in this context have remained valid.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-session-cache"><a class="anchor" href="#pg-server-session-cache"></a><a class="link" href="#pg-server-session-cache">The SessionCache</a></h4>
<div class="paragraph">
<p>There is one <code>SessionCache</code> per <code>SessionManager</code>, and thus one per context.
Its purpose is to provide an L1 cache of <code>ManagedSession</code> objects.
Having a working set of <code>ManagedSession</code> objects in memory allows multiple simultaneous requests for the same session (ie the <em>same</em> session id in the <em>same</em> context) to share the same <code>ManagedSession</code> object.
A <code>SessionCache</code> uses a <code>SessionDataStore</code> to create, read, store, and delete the <code>SessionData</code> associated with the <code>ManagedSession</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to create a <code>SessionCache</code> for a <code>SessionManager</code>:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>allow the <code>SessionManager</code> to create one lazily at startup.
The <code>SessionManager</code> looks for a <code>SessionCacheFactory</code> bean on the <code>Server</code> to produce the <code>SessionCache</code> instance.
It then looks for a <code>SessionDataStoreFactory</code> bean on the <code>Server</code> to produce a <code>SessionDataStore</code> instance to use with the <code>SessionCache</code>.
If no <code>SessionCacheFactory</code>  is present, it defaults to creating a <code>DefaultSessionCache</code>.
If no <code>SessionDataStoreFactory</code> is present, it defaults to creating a <code>NullSessionDataStore</code>.</p>
</li>
<li>
<p>pass a fully configured <code>SessionCache</code> instance to the <code>SessionManager</code>.
You are responsible for configuring both the <code>SessionCache</code> instance and its <code>SessionDataStore</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>More on <code>SessionDataStore</code>s <a href="#pg-server-session-datastore">later</a>, this section concentrates on the <code>SessionCache</code> and <code>SessionCacheFactory</code>.</p>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/AbstractSessionCache.html">AbstractSessionCache</a> provides most of the behaviour of <code>SessionCache</code>s.
If you are implementing a custom <code>SessionCache</code> it is strongly recommended that you extend this class because it implements the numerous subtleties  of the Servlet specification.</p>
</div>
<div class="paragraph">
<p>Some of the important behaviours of <code>SessionCache</code>s are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">eviction</dt>
<dd>
<p>By default, <code>ManagedSession</code>s remain in a cache until they are expired or invalidated.
If you have many or large sessions that are infrequently referenced you can use eviction to reduce the memory consumed by the cache.
When a session is evicted, it is removed from the cache but it is <em>not</em> invalidated.
If you have configured a <code>SessionDataStore</code> that persists or distributes the session in some way, it will continue to exist, and can be read back in when it needs to be referenced again.
The eviction strategies are:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">NEVER_EVICT</dt>
<dd>
<p>This is the default, sessions remain in the cache until expired or invalidated.</p>
</dd>
<dt class="hdlist1">EVICT_ON_SESSION_EXIT</dt>
<dd>
<p>When the last simultaneous request for a session finishes, the session will be evicted from the cache.</p>
</dd>
<dt class="hdlist1">EVICT_ON_INACTIVITY</dt>
<dd>
<p>If a session has not been referenced for a configurable number of seconds, then it will be evicted from the cache.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">saveOnInactiveEviction</dt>
<dd>
<p>This controls whether a session will be persisted to the <code>SessionDataStore</code> if it is being evicted due to the EVICT_ON_INACTIVITY policy.
Usually sessions are written to the <code>SessionDataStore</code> whenever the last simultaneous request exits the session.
However, as <code>SessionDataStore</code>s` can be configured to <a href="#pg-server-session-datastore-skip">skip some writes</a>, this option ensures that the session will be written out.</p>
</dd>
<dt class="hdlist1">saveOnCreate</dt>
<dd>
<p>Usually a session will be written through to the configured <code>SessionDataStore</code> when the last request for it finishes.
In the case of a freshly created session, this means that it will not be persisted until the request is fully finished.
If your application uses context forwarding or including, the newly created session id will not be available in the subsequent contexts.
You can enable this feature to ensure that a freshly created session is immediately persisted after creation: in this way the session id will be available for use in other contexts accessed during the same request.</p>
</dd>
<dt class="hdlist1">removeUnloadableSessions</dt>
<dd>
<p>If a session becomes corrupted in the persistent store, it cannot be re-loaded into the <code>SessionCache</code>.
This can cause noisy log output during scavenge cycles, when the same corrupted session fails to load over and over again.
To prevent his, enable this feature and the <code>SessionCache</code> will ensure that if a session fails to be loaded, it will be deleted.</p>
</dd>
<dt class="hdlist1">invalidateOnShutdown</dt>
<dd>
<p>Some applications want to ensure that all cached sessions are removed when the server shuts down.
This option will ensure that all cached sessions are invalidated.
The <code>AbstractSessionCache</code> does not implement this behaviour, a subclass must implement the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/SessionCache.html#shutdown()">SessionCache.shutdown()</a> method.</p>
</dd>
<dt class="hdlist1">flushOnResponseCommit</dt>
<dd>
<p>This forces a "dirty" session to be written to the <code>SessionDataStore</code> just before a response is returned to the client, rather than waiting until the request is finished.
A "dirty" session is one whose attributes have changed, or it has been freshly created.
Using this option ensures that all subsequent requests - either to the same or a different node - will see the latest changes to the session.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Jetty provides two <code>SessionCache</code> implementations: the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCache.html">DefaultSessionCache</a> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/NullSessionCache.html">NullSessionCache</a>.</p>
</div>
<div class="sect4">
<h5 id="pg-server-session-hash"><a class="anchor" href="#pg-server-session-hash"></a><a class="link" href="#pg-server-session-hash">The DefaultSessionCache</a></h5>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCache.html">DefaultSessionCache</a> retains <code>ManagedSession</code> objects in memory in a <code>ConcurrentHashMap</code>.
It is suitable for non-clustered and clustered deployments.
For clustered deployments, a sticky load balancer is <strong>strongly</strong> recommended, otherwise you risk indeterminate session state as the session bounces around multiple nodes.</p>
</div>
<div class="paragraph">
<p>It implements the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/SessionCache.html#shutdown()">SessionCache.shutdown()</a> method.</p>
</div>
<div class="paragraph">
<p>It also provides some statistics on sessions, which are convenient to access either directly in code or remotely via JMX:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">current sessions</dt>
<dd>
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCache.html#getSessionsCurrent()">DefaultSessionCache.getSessionsCurrent()</a> method reports the number of sessions in the cache at the time of the method call.</p>
</dd>
<dt class="hdlist1">max sessions</dt>
<dd>
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCache.html#getSessionsCurrent()">DefaultSessionCache.getSessionsMax()</a> method reports the highest number of sessions in the cache at the time of the method call.</p>
</dd>
<dt class="hdlist1">total sessions</dt>
<dd>
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCache.html#getSessionsTotal()">DefaultSessionCache.getSessionsTotal()</a> method reports the cumulative total of the number of sessions in the cache at the time of the method call.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If you create a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/DefaultSessionCacheFactory.html">DefaultSessionFactory</a> and register it as a <code>Server</code> bean, a <code>SessionManger</code> will be able to lazily create a <code>DefaultSessionCache</code>.
The <code>DefaultSessionCacheFactory</code> has all of the same configuration setters as a <code>DefaultSessionCache</code>.
Alternatively, if you only have a single <code>SessionManager</code>, or you need to configure a <code>DefaultSessionCache</code> differently for every <code>SessionManager</code>, then you could dispense with the <code>DefaultSessionCacheFactory</code> and simply instantiate, configure, and pass in the <code>DefaultSessionCache</code> yourself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

DefaultSessionCacheFactory cacheFactory = <span class="keyword">new</span> DefaultSessionCacheFactory();
<span class="comment">//EVICT_ON_INACTIVE: evict a session after 60sec inactivity</span>
cacheFactory.setEvictionPolicy(<span class="integer">60</span>);
<span class="comment">//Only useful with the EVICT_ON_INACTIVE policy</span>
cacheFactory.setSaveOnInactiveEviction(<span class="predefined-constant">true</span>);
cacheFactory.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
cacheFactory.setInvalidateOnShutdown(<span class="predefined-constant">false</span>);
cacheFactory.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
cacheFactory.setSaveOnCreate(<span class="predefined-constant">true</span>);

<span class="comment">//Add the factory as a bean to the server, now whenever a</span>
<span class="comment">//SessionManager starts it will consult the bean to create a new DefaultSessionCache</span>
server.addBean(cacheFactory);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you don&#8217;t configure any <code>SessionCache</code> or <code>SessionCacheFactory</code>, a <code>SessionManager</code> will automatically create its own <code>DefaultSessionCache</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-null"><a class="anchor" href="#pg-server-session-null"></a><a class="link" href="#pg-server-session-null">The NullSessionCache</a></h5>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/NullSessionCache.html">NullSessionCache</a> does not actually cache any objects: each request uses a fresh <code>ManagedSession</code> object.
It is suitable for clustered deployments without a sticky load balancer and non-clustered deployments when purely minimal support for sessions is needed.</p>
</div>
<div class="paragraph">
<p>As no sessions are actually cached, of course functions like <code>invalidateOnShutdown</code> and all of the eviction strategies have no meaning for the <code>NullSessionCache</code>.</p>
</div>
<div class="paragraph">
<p>There is a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/NullSessionCacheFactory.html">NullSessionCacheFactory</a> which you can instantiate, configure and set as a <code>Server</code> bean to enable a <code>SessionManager</code> to automatically create new <code>NullSessionCache</code>s as needed.
All of the same configuration options are available on the <code>NullSessionCacheFactory</code> as the <code>NullSessionCache</code> itself.
Alternatively, if you only have a single <code>SessionManager</code>, or you need to configure a <code>NullSessionCache</code> differently for every <code>SessionManager</code>, then you could dispense with the <code>NullSessionCacheFactory</code> and simply instantiate, configure, and pass in the <code>NullSessionCache</code> yourself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();
NullSessionCacheFactory cacheFactory = <span class="keyword">new</span> NullSessionCacheFactory();
cacheFactory.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
cacheFactory.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
cacheFactory.setSaveOnCreate(<span class="predefined-constant">true</span>);

<span class="comment">//Add the factory as a bean to the server, now whenever a</span>
<span class="comment">//SessionManager starts it will consult the bean to create a new NullSessionCache</span>
server.addBean(cacheFactory);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-customcache"><a class="anchor" href="#pg-server-session-customcache"></a><a class="link" href="#pg-server-session-customcache">Implementing a custom SessionCache</a></h5>
<div class="paragraph">
<p>As previously mentioned, it is strongly recommended that you extend the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/AbstractSessionCache.html">AbstractSessionCache</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-heterogeneous-caching"><a class="anchor" href="#pg-heterogeneous-caching"></a><a class="link" href="#pg-heterogeneous-caching">Heterogeneous caching</a></h5>
<div class="paragraph">
<p>Using one of the <code>SessionCacheFactory</code>s will ensure that every time a <code>SessionManager</code> starts it will create a new instance of the corresponding type of <code>SessionCache</code>.</p>
</div>
<div class="paragraph">
<p>But, what if you deploy multiple webapps, and for one of them, you don&#8217;t want to use sessions?
Or alternatively, you don&#8217;t want to use sessions, but you have one webapp that now needs them?
In that case, you can configure the <code>SessionCacheFactory</code> appropriate to the majority, and then specifically create the right type of <code>SessionCache</code> for the others.
Here&#8217;s an example where we configure the <code>DefaultSessionCacheFactory</code> to handle most webapps, but then specifically use a <code>NullSessionCache</code> for another:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

DefaultSessionCacheFactory cacheFactory = <span class="keyword">new</span> DefaultSessionCacheFactory();
<span class="comment">//NEVER_EVICT</span>
cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);
cacheFactory.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
cacheFactory.setInvalidateOnShutdown(<span class="predefined-constant">false</span>);
cacheFactory.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
cacheFactory.setSaveOnCreate(<span class="predefined-constant">true</span>);

<span class="comment">//Add the factory as a bean to the server, now whenever a</span>
<span class="comment">//SessionManager starts it will consult the bean to create a new DefaultSessionCache</span>
server.addBean(cacheFactory);

ContextHandlerCollection contexts = <span class="keyword">new</span> ContextHandlerCollection();
server.setHandler(contexts);

<span class="comment">//Add a webapp that will use a DefaultSessionCache via the DefaultSessionCacheFactory</span>
WebAppContext app1 = <span class="keyword">new</span> WebAppContext();
app1.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app1</span><span class="delimiter">&quot;</span></span>);
contexts.addHandler(app1);

<span class="comment">//Add a webapp that uses an explicit NullSessionCache instead</span>
WebAppContext app2 = <span class="keyword">new</span> WebAppContext();
app2.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app2</span><span class="delimiter">&quot;</span></span>);
NullSessionCache nullSessionCache = <span class="keyword">new</span> NullSessionCache(app2.getSessionHandler());
nullSessionCache.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
nullSessionCache.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
nullSessionCache.setSaveOnCreate(<span class="predefined-constant">true</span>);
<span class="comment">//If we pass an existing SessionCache instance to the SessionHandler, it must be</span>
<span class="comment">//fully configured: this means we must also provide SessionDataStore</span>
nullSessionCache.setSessionDataStore(<span class="keyword">new</span> NullSessionDataStore());
app2.getSessionHandler().setSessionCache(nullSessionCache);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-session-datastore"><a class="anchor" href="#pg-server-session-datastore"></a><a class="link" href="#pg-server-session-datastore">The SessionDataStore</a></h4>
<div class="paragraph">
<p>A <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/SessionDataStore.html">SessionDataStore</a> mediates the storage, retrieval and deletion of <code>SessionData</code>.
There is one <code>SessionDataStore</code> per <code>SessionCache</code> and thus one per context.
Jetty provides a number of alternative <code>SessionDataStore</code> implementations:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-36ebfa7e56c0c8222dcb2e860f97a06f.png" alt="Diagram" width="1628" height="314">
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">NullSessionDataStore</dt>
<dd>
<p>Does not store <code>SessionData</code>, meaning that sessions will exist in-memory only.
See <a href="#pg-server-session-datastore-null">NullSessionDataStore</a></p>
</dd>
<dt class="hdlist1">FileSessionDataStore</dt>
<dd>
<p>Uses the file system to persist <code>SessionData</code>.
See <a href="#pg-server-session-datastore-file">FileSessionDataStore</a> for more information.</p>
</dd>
<dt class="hdlist1">GCloudSessionDataStore</dt>
<dd>
<p>Uses GCloud Datastore for persisting <code>SessionData</code>.
See <a href="#pg-server-session-datastore-gcloud">GCloudSessionDataStore</a> for more information.</p>
</dd>
<dt class="hdlist1">HazelcastSessionDataStore</dt>
<dd>
<p>Uses Hazelcast for persisting <code>SessionData</code>.</p>
</dd>
<dt class="hdlist1">InfinispanSessionDataStore</dt>
<dd>
<p>Uses <a href="http://infinispan.org">Infinispan</a> for persisting <code>SessionData</code>.
See <a href="#pg-server-session-datastore-infinispan">InfinispanSessionDataStore</a> for more information.</p>
</dd>
<dt class="hdlist1">JDBCSessionDataStore</dt>
<dd>
<p>Uses a relational database via JDBC API to persist <code>SessionData</code>.
See <a href="#pg-server-session-datastore-jdbc">JDBCSessionDataStore</a> for more information.</p>
</dd>
<dt class="hdlist1">MongoSessionDataStore</dt>
<dd>
<p>Uses <a href="http://www.mongodb.com">MongoDB</a> document database to persist <code>SessionData</code>.
See <a href="#pg-server-session-datastore-mongo">MongoSessionDataStore</a> for more information.</p>
</dd>
<dt class="hdlist1">CachingSessionDataStore</dt>
<dd>
<p>Uses <a href="http://memcached.org">memcached</a> to provide an L2 cache of <code>SessionData</code> while delegating to another <code>SessionDataStore</code> for persistence of <code>SessionData</code>.
See <a href="#pg-server-session-cachingsessiondatastore">CachingSessionDataStore</a> for more information.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Most of the behaviour common to <code>SessionDataStore</code>s is provided by the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/AbstractSessionDataStore.html">AbstractSessionDataStore</a> class.
You are strongly encouraged to use this as the base class for implementing your custom <code>SessionDataStore</code>.</p>
</div>
<div class="paragraph">
<p>Some important methods are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">isPassivating()</dt>
<dd>
<p>Boolean. "True" means that session data is <em>serialized</em>.
Some persistence mechanisms serialize, such as JDBC, GCloud Datastore etc.
Others can store an object in shared memory, e.g. Infinispan and thus don&#8217;t serialize session data.
In Servlet environments, whether a <code>SessionDataStore</code> reports that it is capable of passivating controls whether <code>HttpSessionActivationListener</code>s will be called.
When implementing a custom <code>SessionDataStore</code> you need to decide whether you will support passivation or not.</p>
</dd>
</dl>
</div>
<div id="pg-server-session-datastore-skip" class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="pg-custom-sessiondatastores"><a class="anchor" href="#pg-custom-sessiondatastores"></a><a class="link" href="#pg-custom-sessiondatastores">Custom SessionDataStores</a></h5>
<div class="paragraph">
<p>When implementing a <code>SessionDataStore</code> for a particular persistence technology, you should base it off the <code>AbstractSessionDataStore</code> class.</p>
</div>
<div class="paragraph">
<p>Firstly, it is important to understand the components of a unique key for a session suitable for storing in a persistence mechanism.
Consider that although multiple contexts may share the <em>same</em> session id (ie cross-context dispatch), the data in those sessions must be distinct.
Therefore, when storing session data in a persistence mechanism that is shared by many nodes in a cluster, the session must be identified by a combination of the id <em>and</em> the context.</p>
</div>
<div class="paragraph">
<p>The <code>SessionDataStore</code>s use the following information to synthesize a unique key for session data that is suitable to the particular persistence mechanism :</p>
</div>
<div id="pg-server-session-key" class="dlist">
<dl>
<dt class="hdlist1">id</dt>
<dd>
<p>This is the id as generated by the <code>SessionIdManager</code></p>
</dd>
<dt class="hdlist1">context</dt>
<dd>
<p>The path of the context associated with the session.</p>
</dd>
<dt class="hdlist1">virtual host</dt>
<dd>
<p>The first virtual host - if any - associated with the context.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/SessionContext.html">SessionContext</a> class, of which every <code>AbstractSessionDataStore</code> has an instance, will provide these components to you in a canonicalized form.</p>
</div>
<div class="paragraph">
<p>Then you will need to implement the following methods:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">public boolean doExists(String id)</dt>
<dd>
<p>Check if data for the given session exists in your persistence mechanism.
The id is always relative to the context, see <a href="#pg-server-session-key">above</a>.</p>
</dd>
<dt class="hdlist1">public void doStore(String id, SessionData data, long lastSaveTime)</dt>
<dd>
<p>Store the session data into your persistence mechanism.
The id is always relative to the context, see <a href="#pg-server-session-key">above</a>.</p>
</dd>
<dt class="hdlist1">public SessionData doLoad(String id)</dt>
<dd>
<p>Load the session from your persistent mechanism.
The id is always relative to the context, see <a href="#pg-server-session-key">above</a>.</p>
</dd>
<dt class="hdlist1">public Set&lt;String&gt; doCheckExpired(Set&lt;String&gt; candidates, long time)</dt>
<dd>
<p>Verify which of the suggested session ids have expired since the time given, according to the data stored in your persistence mechanism.
This is used during scavenging to ensure that a session that is a candidate for expiry according to <em>this</em> node is not in-use on <em>another</em> node.
The sessions matching these ids will be loaded as <code>ManagedSession</code>s and have their normal expiration lifecycle events invoked.
The id is always relative to the context, see <a href="#pg-server-session-key">above</a>.</p>
</dd>
<dt class="hdlist1">public Set&lt;String&gt; doGetExpired(long before)</dt>
<dd>
<p>Find the ids of sessions that expired at or before the time given.
The sessions matching these ids will be loaded as <code>ManagedSession</code>s and have their normal expiration lifecycle events invoked.
The id is always relative to the context, see <a href="#pg-server-session-key">above</a>.</p>
</dd>
<dt class="hdlist1">public void doCleanOrphans(long time)</dt>
<dd>
<p>Find the ids of sessions that expired at or before the given time, <em>independent of the context they are in</em>.
The purpose is to find sessions that are no longer being managed by any node.
These sessions may even belong to contexts that no longer exist.
Thus, any such sessions must be summarily deleted from the persistence mechanism and cannot have their normal expiration lifecycle events invoked.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="pg-the-sessiondatastorefactory"><a class="anchor" href="#pg-the-sessiondatastorefactory"></a><a class="link" href="#pg-the-sessiondatastorefactory">The SessionDataStoreFactory</a></h5>
<div class="paragraph">
<p>Every <code>SessionDataStore</code> has a factory class that creates instances based on common configuration.</p>
</div>
<div class="paragraph">
<p>All <code>SessionDataStoreFactory</code> implementations support configuring:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int)</dt>
<dt class="hdlist1">setGracePeriodSec(int)</dt>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-null"><a class="anchor" href="#pg-server-session-datastore-null"></a><a class="link" href="#pg-server-session-datastore-null">The NullSessionDataStore</a></h5>
<div class="paragraph">
<p>The <code>NullSessionDataStore</code> is a trivial implementation of <code>SessionDataStore</code> that does not persist <code>SessionData</code>.
Use it when you want your sessions to remain in memory <em>only</em>.
Be careful of your <code>SessionCache</code> when using the <code>NullSessionDataStore</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if using a <code>NullSessionCache</code> then your sessions are neither shared nor saved</p>
</li>
<li>
<p>if using a <code>DefaultSessionCache</code> with eviction settings, your session will cease to exist when it is evicted from the cache</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you have not configured any other <a href="#pg-server-session-datastore">SessionDataStore</a>, when a <code>SessionHandler</code> aka <code>AbstractSessionManager</code> starts up, it will instantiate a <code>NullSessionDataStore</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-file"><a class="anchor" href="#pg-server-session-datastore-file"></a><a class="link" href="#pg-server-session-datastore-file">The FileSessionDataStore</a></h5>
<div class="paragraph">
<p>The <code>FileSessionDataStore</code> supports persistent storage of session data in a filesystem.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Persisting sessions to the local file system should <strong>never</strong> be used in a clustered environment.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>One file represents one session in one context.</p>
</div>
<div class="paragraph">
<p>File names follow this pattern:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[expiry]_[contextpath]_[virtualhost]_[id]</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">expiry</dt>
<dd>
<p>This is the expiry time in milliseconds since the epoch.</p>
</dd>
<dt class="hdlist1">contextpath</dt>
<dd>
<p>This is the context path with any special characters, including <code>/</code>, replaced by the <code><em></code> underscore character.
For example, a context path of <code>/catalog</code> would become <code>_catalog</code>.
A context path of simply <code>/</code> becomes just <code>_</em></code>.</p>
</dd>
<dt class="hdlist1">virtualhost</dt>
<dd>
<p>This is the first virtual host associated with the context and has the form of 4 digits separated by <code>.</code> characters.
If there are no virtual hosts associated with a context, then <code>0.0.0.0</code> is used:</p>
<div class="literalblock">
<div class="content">
<pre>[digit].[digit].[digit].[digit]</pre>
</div>
</div>
</dd>
<dt class="hdlist1">id</dt>
<dd>
<p>This is the unique id of the session.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Putting all of the above together as an example, a session with an id of <code>node0ek3vx7x2y1e7pmi3z00uqj1k0</code> for the context with path <code>/test</code> with no virtual hosts and an expiry of <code>1599558193150</code> would have a file name of:</p>
</div>
<div class="paragraph">
<p><code>1599558193150__test_0.0.0.0_node0ek3vx7x2y1e7pmi3z00uqj1k0</code></p>
</div>
<div class="paragraph">
<p>You can configure either a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/FileSessionDataStore.html">FileSessionDataStore</a> individually, or a <code>FileSessionDataStoreFactory</code> if you want multiple <code>SessionHandler</code>s to use <code>FileSessionDataStore</code>s that are identically configured.
The configuration methods are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setStoreDir(File) <em>[Default:null]</em> </dt>
<dd>
<p>This is the location for storage of session files.
If the directory does not exist at startup, it will be created.
If you use the same <code>storeDir</code> for multiple <code>SessionHandlers</code>, then the sessions for all of those contexts are stored in the same directory.
This is not a problem, as the name of the file is unique because it contains the context information.
You <em>must</em> supply a value for this, otherwise startup of the <code>FileSessionDataStore</code> will fail.</p>
</dd>
<dt class="hdlist1">deleteUnrestorableFiles(boolean) <em>[Default:false]</em> </dt>
<dd>
<p>If set to <code>true</code>, unreadable files will be deleted.
This is useful to prevent repeated logging of the same error when the <a href="#pg-server-session-housekeeper">scavenger</a> periodically (re-)attempts to load the corrupted information for a session in order to expire it.</p>
</dd>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of configuring a <code>FileSessionDataStoreFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">//First lets configure a DefaultSessionCacheFactory</span>
DefaultSessionCacheFactory cacheFactory = <span class="keyword">new</span> DefaultSessionCacheFactory();
<span class="comment">//NEVER_EVICT</span>
cacheFactory.setEvictionPolicy(SessionCache.NEVER_EVICT);
cacheFactory.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
cacheFactory.setInvalidateOnShutdown(<span class="predefined-constant">false</span>);
cacheFactory.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
cacheFactory.setSaveOnCreate(<span class="predefined-constant">true</span>);

<span class="comment">//Add the factory as a bean to the server, now whenever a</span>
<span class="comment">//SessionManager starts it will consult the bean to create a new DefaultSessionCache</span>
server.addBean(cacheFactory);

<span class="comment">//Now, lets configure a FileSessionDataStoreFactory</span>
FileSessionDataStoreFactory storeFactory = <span class="keyword">new</span> FileSessionDataStoreFactory();
storeFactory.setStoreDir(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/sessions</span><span class="delimiter">&quot;</span></span>));
storeFactory.setGracePeriodSec(<span class="integer">3600</span>);
storeFactory.setSavePeriodSec(<span class="integer">0</span>);

<span class="comment">//Add the factory as a bean on the server, now whenever a</span>
<span class="comment">//SessionManager starts, it will consult the bean to create a new FileSessionDataStore</span>
<span class="comment">//for use by the DefaultSessionCache</span>
server.addBean(storeFactory);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s an alternate example, configuring a <code>FileSessionDataStore</code> directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//create a context</span>
WebAppContext app1 = <span class="keyword">new</span> WebAppContext();
app1.setContextPath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/app1</span><span class="delimiter">&quot;</span></span>);

<span class="comment">//First, we create a DefaultSessionCache</span>
DefaultSessionCache cache = <span class="keyword">new</span> DefaultSessionCache(app1.getSessionHandler());
cache.setEvictionPolicy(SessionCache.NEVER_EVICT);
cache.setFlushOnResponseCommit(<span class="predefined-constant">true</span>);
cache.setInvalidateOnShutdown(<span class="predefined-constant">false</span>);
cache.setRemoveUnloadableSessions(<span class="predefined-constant">true</span>);
cache.setSaveOnCreate(<span class="predefined-constant">true</span>);

<span class="comment">//Now, we configure a FileSessionDataStore</span>
FileSessionDataStore store = <span class="keyword">new</span> FileSessionDataStore();
store.setStoreDir(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/sessions</span><span class="delimiter">&quot;</span></span>));
store.setGracePeriodSec(<span class="integer">3600</span>);
store.setSavePeriodSec(<span class="integer">0</span>);

<span class="comment">//Tell the cache to use the store</span>
cache.setSessionDataStore(store);

<span class="comment">//Tell the context to use the cache/store combination</span>
app1.getSessionHandler().setSessionCache(cache);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-jdbc"><a class="anchor" href="#pg-server-session-datastore-jdbc"></a><a class="link" href="#pg-server-session-datastore-jdbc">The JDBCSessionDataStore</a></h5>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/JDBCSessionDataStore.html">JDBCSessionDataStore</a> supports persistent storage of session data in a relational database.
To do that, it requires a <code>DatabaseAdaptor</code> that handles the differences between databases (eg Oracle, Postgres etc), and a <code>SessionTableSchema</code> that allows for the customization of table and column names.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-8bbf1fa0b84011383e811eaf9e630100.png" alt="Diagram" width="381" height="169">
</div>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/JDBCSessionDataStore.html">JDBCSessionDataStore</a> and corresponding <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/JDBCSessionDataStoreFactory.html">JDBCSessionDataStoreFactory</a> support the following configuration:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setDatabaseAdaptor(DatabaseAdaptor)</dt>
<dd>
<p>A <code>JDBCSessionDataStore</code> requires a <code>DatabaseAdapter</code>, otherwise an <code>Exception</code>  is thrown  at start time.</p>
</dd>
<dt class="hdlist1">setSessionTableSchema(SessionTableSchema)</dt>
<dd>
<p>If a <code>SessionTableSchema</code> has not been explicitly set, one with all values defaulted is created at start time.</p>
</dd>
</dl>
</div>
<div class="sect5">
<h6 id="pg-the-databaseadaptor"><a class="anchor" href="#pg-the-databaseadaptor"></a><a class="link" href="#pg-the-databaseadaptor">The DatabaseAdaptor</a></h6>
<div class="paragraph">
<p>Many databases use different keywords for types such as <code>long</code>, <code>blob</code> and <code>varchar</code>.
Jetty will detect the type of the database at runtime by interrogating the metadata associated with a database connection.
Based on that metadata Jetty will try to select that database&#8217;s preferred keywords.
However, you may need to instead explicitly configure these as described below.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setDatasource(String)</dt>
<dt class="hdlist1">setDatasource(Datasource)</dt>
<dd>
<p>Either the JNDI name of a <code>Datasource</code> to look up, or the <code>Datasource</code> itself.
Alternatively you can set the <strong>driverInfo</strong>, see  below.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DatabaseAdaptor datasourceAdaptor = <span class="keyword">new</span> DatabaseAdaptor();
datasourceAdaptor.setDatasourceName(<span class="string"><span class="delimiter">&quot;</span><span class="content">/jdbc/myDS</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setDriverInfo(String, String)</dt>
<dt class="hdlist1">setDriverInfo(Driver, String)</dt>
<dd>
<p>This is the name or instance of a <code>Driver</code> class and a connection URL.
Alternatively you can set the <strong>datasource</strong>, see above.</p>
</dd>
</dl>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">DatabaseAdaptor driverAdaptor = <span class="keyword">new</span> DatabaseAdaptor();
driverAdaptor.setDriverInfo(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.mysql.jdbc.Driver</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">jdbc:mysql://127.0.0.1:3306/sessions?user=sessionsadmin</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setBlobType(String) <em>[Default: "blob" or "bytea" for Postgres]</em> </dt>
<dd>
<p>The type name used to represent "blobs" by the database.</p>
</dd>
<dt class="hdlist1">setLongType(String) <em>[Default: "bigint" or "number(20)" for Oracle]</em> </dt>
<dd>
<p>The type name  used to represent large integers by the database.</p>
</dd>
<dt class="hdlist1">setStringType(String) <em>[Default: "varchar"]</em></dt>
<dd>
<p>The type name used to represent character data by the database.</p>
</dd>
</dl>
</div>
</div>
<div class="sect5">
<h6 id="pg-the-sessiontableschema"><a class="anchor" href="#pg-the-sessiontableschema"></a><a class="link" href="#pg-the-sessiontableschema">The SessionTableSchema</a></h6>
<div class="paragraph">
<p><code>SessionData</code> is stored in a table with one row per session.
This is the definition of the table with the table name, column names, and type keywords all at their default settings:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table:JettySessions</caption>
<colgroup>
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3333%;">
<col style="width: 8.3337%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">sessionId</th>
<th class="tableblock halign-left valign-top">contextPath</th>
<th class="tableblock halign-left valign-top">virtualHost</th>
<th class="tableblock halign-left valign-top">lastNode</th>
<th class="tableblock halign-left valign-top">accessTime</th>
<th class="tableblock halign-left valign-top">lastAccessTime</th>
<th class="tableblock halign-left valign-top">createTime</th>
<th class="tableblock halign-left valign-top">cookieTime</th>
<th class="tableblock halign-left valign-top">lastSavedTime</th>
<th class="tableblock halign-left valign-top">expiryTime</th>
<th class="tableblock halign-left valign-top">maxInterval</th>
<th class="tableblock halign-left valign-top">map</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">120 varchar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 varchar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 varchar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 varchar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">blob</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Use the <code>SessionTableSchema</code> class to customize these names.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSchemaName(String), setCatalogName(String) <em>[Default: null]</em> </dt>
<dd>
<p>The exact meaning of these two are dependent on your database vendor, but can broadly be described as further scoping for the session table name.
See <a href="https://en.wikipedia.org/wiki/Database_schema" class="bare">https://en.wikipedia.org/wiki/Database_schema</a> and <a href="https://en.wikipedia.org/wiki/Database_catalog" class="bare">https://en.wikipedia.org/wiki/Database_catalog</a>.
These extra scoping names come into play at startup time when Jetty determines if the session table already exists, or creates it on-the-fly.
If your database is not using schema or catalog name scoping, leave these unset.
If your database is configured with a schema or catalog name, use the special value "INFERRED" and Jetty will extract them from the database metadata.
Alternatively, set them explicitly using these methods.</p>
</dd>
<dt class="hdlist1">setTableName(String) <em>[Default:"JettySessions"]</em> </dt>
<dd>
<p>This is the name of the table in which session data is stored.</p>
</dd>
<dt class="hdlist1">setAccessTimeColumn(String) <em>[Default: "accessTime"]</em> </dt>
<dd>
<p>This is the name of the column that stores the time - in ms since the epoch - at which a session was last accessed</p>
</dd>
<dt class="hdlist1">setContextPathColumn(String) <em>[Default: "contextPath"]</em> </dt>
<dd>
<p>This is the name of the column that stores the <code>contextPath</code> of a session.</p>
</dd>
<dt class="hdlist1">setCookieTimeColumn(String) <em>[Default: "cookieTime"]</em></dt>
<dd>
<p>This is the name of the column that stores the time - in ms since the epoch - that the cookie was last set for a session.</p>
</dd>
<dt class="hdlist1">setCreateTimeColumn(String) <em>[Default: "createTime"]</em> </dt>
<dd>
<p>This is the name of the column that stores the time - in ms since the epoch - at which a session was created.</p>
</dd>
<dt class="hdlist1">setExpiryTimeColumn(String) <em>[Default: "expiryTime"]</em> </dt>
<dd>
<p>This is name of the column that stores - in ms since the epoch - the time at which a session will expire.</p>
</dd>
<dt class="hdlist1">setLastAccessTimeColumn(String) <em>[Default: "lastAccessTime"]</em> </dt>
<dd>
<p>This is the name of the column that stores the time - in ms since the epoch - that a session was previously accessed.</p>
</dd>
<dt class="hdlist1">setLastSavedTimeColumn(String) <em>[Default: "lastSavedTime"]</em> </dt>
<dd>
<p>This is the name of the column that stores the time - in ms since the epoch - at which a session was last written.</p>
</dd>
<dt class="hdlist1">setIdColumn(String) <em>[Default: "sessionId"]</em> </dt>
<dd>
<p>This is the name of the column that stores the id of a session.</p>
</dd>
<dt class="hdlist1">setLastNodeColumn(String) <em>[Default: "lastNode"]</em> </dt>
<dd>
<p>This is the name of the column that stores the <code>workerName</code> of the last node to write a session.</p>
</dd>
<dt class="hdlist1">setVirtualHostColumn(String) <em>[Default: "virtualHost"]</em> </dt>
<dd>
<p>This is the name of the column that stores the first virtual host of the context of a session.</p>
</dd>
<dt class="hdlist1">setMaxIntervalColumn(String) <em>[Default: "maxInterval"]</em> </dt>
<dd>
<p>This is the name of the column that stores the interval - in ms - during which a session can be idle before being considered expired.</p>
</dd>
<dt class="hdlist1">setMapColumn(String) <em>[Default: "map"]</em> </dt>
<dd>
<p>This is the name of the column that stores the serialized attributes of a session.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-mongo"><a class="anchor" href="#pg-server-session-datastore-mongo"></a><a class="link" href="#pg-server-session-datastore-mongo">The MongoSessionDataStore</a></h5>
<div class="paragraph">
<p>The <code>MongoSessionDataStore</code> supports persistence of <code>SessionData</code> in a nosql database.</p>
</div>
<div class="paragraph">
<p>The best description for the document model for session information is found in the javadoc for the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/nosql/mongodb/MongoSessionDataStore.html">MongoSessionDataStore</a>.
In overview, it can be represented thus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-ae4b86cecdafb2b8e1afb35b06f359a1.png" alt="Diagram" width="284" height="325">
</div>
</div>
<div class="paragraph">
<p>The database contains a document collection for the sessions.
Each document represents a session id, and contains one nested document per context in which that session id is used.
For example, the session id <code>abcd12345</code> might be used by two contexts, one with path <code>/contextA</code> and one with path <code>/contextB</code>.
In that case, the outermost document would refer to <code>abcd12345</code> and it would have a nested document for <code>/contextA</code> containing the session attributes for that context, and another nested document for <code>/contextB</code> containing the session attributes for that context.
Remember, according to the Servlet Specification, a session id can be shared by many contexts, but the attributes must be unique per context.</p>
</div>
<div class="paragraph">
<p>The outermost document contains these fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">id</dt>
<dd>
<p>The session id.</p>
</dd>
<dt class="hdlist1">created</dt>
<dd>
<p>The time (in ms since the epoch) at which the session was first created in any context.</p>
</dd>
<dt class="hdlist1">maxIdle</dt>
<dd>
<p>The time (in ms) for which an idle session is regarded as valid.
As maxIdle times can be different for <code>Session</code>s from different contexts, this is the <em>shortest</em> maxIdle time.</p>
</dd>
<dt class="hdlist1">expiry</dt>
<dd>
<p>The time (in ms since the epoch) at which the session will expire.
As the expiry time can be different for <code>Session</code>s from different contexts, this is the <em>shortest</em> expiry time.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Each nested context-specific document contains:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">attributes</dt>
<dd>
<p>The session attributes as a serialized map.</p>
</dd>
<dt class="hdlist1">lastSaved</dt>
<dd>
<p>The time (in ms since the epoch) at which the session in this context was saved.</p>
</dd>
<dt class="hdlist1">lastAccessed</dt>
<dd>
<p>The time (in ms since the epoch) at which the session in this context was previously accessed.</p>
</dd>
<dt class="hdlist1">accessed</dt>
<dd>
<p>The time (in ms since the epoch) at which this session was most recently accessed.</p>
</dd>
<dt class="hdlist1">lastNode</dt>
<dd>
<p>The <a href="#pg-server-session-workername">workerName</a> of the last server that saved the session data.</p>
</dd>
<dt class="hdlist1">version</dt>
<dd>
<p>An object that is updated every time a session is written for a context.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can configure either a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/nosql/mongodb/MongoSessionDataStore.html">MongoSessionDataStore</a> individually, or a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/nosql/mongodb/MongoSessionDataStoreFactory.html">MongoSessionDataStoreFactory</a> if you want multiple <code>SessionHandler</code>s to use <code>MongoSessionDataStore</code>s that are identically configured.
The configuration methods for the <code>MongoSessionDataStoreFactory</code> are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setDbName(String)</dt>
<dd>
<p>This is the name of the database.</p>
</dd>
<dt class="hdlist1">setCollectionName(String)</dt>
<dd>
<p>The name of the document collection.</p>
</dd>
<dt class="hdlist1">setConnectionString(String)</dt>
<dd>
<p>a mongodb url, eg "mongodb://localhost".
Alternatively, you can specify the <strong>host,port</strong> combination instead, see below.</p>
</dd>
<dt class="hdlist1">setHost(String)</dt>
<dt class="hdlist1">setPort(int)</dt>
<dd>
<p>the hostname and port number of the mongodb instance to contact.
Alternatively, you can specify the <strong>connectionString</strong> instead, see above.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>This is an example of configuring a <code>MongoSessionDataStoreFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

MongoSessionDataStoreFactory mongoSessionDataStoreFactory = <span class="keyword">new</span> MongoSessionDataStoreFactory();
mongoSessionDataStoreFactory.setGracePeriodSec(<span class="integer">3600</span>);
mongoSessionDataStoreFactory.setSavePeriodSec(<span class="integer">0</span>);
mongoSessionDataStoreFactory.setDbName(<span class="string"><span class="delimiter">&quot;</span><span class="content">HttpSessions</span><span class="delimiter">&quot;</span></span>);
mongoSessionDataStoreFactory.setCollectionName(<span class="string"><span class="delimiter">&quot;</span><span class="content">JettySessions</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Either set the connectionString</span>
mongoSessionDataStoreFactory.setConnectionString(<span class="string"><span class="delimiter">&quot;</span><span class="content">mongodb:://localhost:27017</span><span class="delimiter">&quot;</span></span>);
<span class="comment">// or alternatively set the host and port.</span>
mongoSessionDataStoreFactory.setHost(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>);
mongoSessionDataStoreFactory.setPort(<span class="integer">27017</span>);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-infinispan"><a class="anchor" href="#pg-server-session-datastore-infinispan"></a><a class="link" href="#pg-server-session-datastore-infinispan">The InfinispanSessionDataStore</a></h5>
<div class="paragraph">
<p>The <code>InfinispanSessionDataStore</code> supports persistent storage of session data via the <a href="https://infinispan.org/">Infinispan</a> data grid.</p>
</div>
<div class="paragraph">
<p>You may use Infinispan in either <em>embedded mode</em>, where it runs in the same process as Jetty, or in <em>remote mode</em> mode, where your Infinispan instance is on another node.</p>
</div>
<div class="paragraph">
<p>For more information on Infinispan, including some code examples, consult the <a href="https://infinispan.org/">Infinispan documentation</a>.
See below for some code examples of configuring the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/infinispan/InfinispanSessionDataStore.html">InfinispanSessionDataStore</a> in Jetty.
Note that the configuration options are the same for both the <code>InfinispanSessionDataStore</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/infinispan/InfinispanSessionDataStoreFactory.html">InfinispanSessionDataStoreFactory</a>.
Use the latter to apply the same configuration to multiple <code>InfinispanSessionDataStore</code>s.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setCache(BasicCache&lt;String, InfinispanSessionData&gt; cache)</dt>
<dd>
<p>Infinispan uses a cache API as the interface to the data grid and this method configures Jetty with the cache instance.
This cache can be either an <em>embedded</em> cache - also called a "local" cache in Infinispan parlance - or a <em>remote</em> cache.</p>
</dd>
<dt class="hdlist1">setSerialization(boolean) <em>[Default: false]</em> </dt>
<dd>
<p>When the <code>InfinispanSessionDataStore</code> starts, if it detects the Infinispan classes for remote caches on the classpath, it will automatically assume <code>serialization</code> is true, and thus that <code>SessionData</code> will be serialized over-the-wire to a remote cache.
You can use this parameter to override this.
If this parameter is <code>true</code>, the <code>InfinispanSessionDataStore</code> returns true for the <code>isPassivating()</code> method, but false otherwise.</p>
</dd>
<dt class="hdlist1">setInfinispanIdleTimeoutSec(int) <em>[Default: 0]</em> </dt>
<dd>
<p>This controls the Infinispan option whereby it can detect and delete entries that have not been referenced for a configurable amount of time.
A value of 0 disables it.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you use this option, expired sessions will be summarily deleted from Infinispan <em>without</em> the normal session invalidation handling (eg calling of lifecycle listeners).
Only use this option if you do not have session lifecycle listeners that must be called when a session is invalidated.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setQueryManager(QueryManager)</dt>
<dd>
<p>If this parameter is not set, the <code>InfinispanSessionDataStore</code> will be unable to scavenge for unused sessions.
In that case, you can use the <code>infinispanIdleTimeoutSec</code> option instead to prevent the accumulation of expired sessions.
When using Infinispan in <em>embedded</em> mode, configure the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/infinispan/EmbeddedQueryManager.html">EmbeddedQueryManager</a> to enable Jetty to query for expired sessions so that they may be property invalidated and lifecycle listeners called.
When using Infinispan in <em>remote</em> mode, configure the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/infinispan/RemoteQueryManager.html">RemoteQueryManager</a> instead.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Here is an example of configuring an <code>InfinispanSessionDataStore</code> in code using an <em>embedded</em> cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* Create a core SessionHandler
 * Alternatively in a Servlet Environment do:
 * WebAppContext webapp = new WebAppContext();
 * SessionHandler sessionHandler = webapp.getSessionHandler();
 */</span>
SessionHandler sessionHandler = <span class="keyword">new</span> SessionHandler();

<span class="comment">//Use an Infinispan local cache configured via an infinispan xml file</span>
DefaultCacheManager defaultCacheManager = <span class="keyword">new</span> DefaultCacheManager(<span class="string"><span class="delimiter">&quot;</span><span class="content">path/to/infinispan.xml</span><span class="delimiter">&quot;</span></span>);
Cache&lt;<span class="predefined-type">String</span>, InfinispanSessionData&gt; localCache = defaultCacheManager.getCache();

<span class="comment">//Configure the Jetty session datastore with Infinispan</span>
InfinispanSessionDataStore infinispanSessionDataStore = <span class="keyword">new</span> InfinispanSessionDataStore();
infinispanSessionDataStore.setCache(localCache);
infinispanSessionDataStore.setSerialization(<span class="predefined-constant">false</span>); <span class="comment">//local cache does not serialize session data</span>
infinispanSessionDataStore.setInfinispanIdleTimeoutSec(<span class="integer">0</span>); <span class="comment">//do not use infinispan auto delete of unused sessions</span>
infinispanSessionDataStore.setQueryManager(<span class="keyword">new</span> org.eclipse.jetty.session.infinispan.EmbeddedQueryManager(localCache)); <span class="comment">//enable Jetty session scavenging</span>
infinispanSessionDataStore.setGracePeriodSec(<span class="integer">3600</span>);
infinispanSessionDataStore.setSavePeriodSec(<span class="integer">0</span>);

<span class="comment">//Configure a SessionHandler to use the local Infinispan cache as a store of SessionData</span>
DefaultSessionCache sessionCache = <span class="keyword">new</span> DefaultSessionCache(sessionHandler);
sessionCache.setSessionDataStore(infinispanSessionDataStore);
sessionHandler.setSessionCache(sessionCache);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of configuring an <code>InfinispanSessionDataStore</code> in code using a <em>remote</em> cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">/* Create a core SessionHandler
 * Alternatively in a Servlet Environment do:
 * WebAppContext webapp = new WebAppContext();
 * SessionHandler sessionHandler = webapp.getSessionHandler();
 */</span>
SessionHandler sessionHandler = <span class="keyword">new</span> SessionHandler();

<span class="comment">//Configure Infinispan to provide a remote cache called &quot;JettySessions&quot;</span>
<span class="predefined-type">Properties</span> hotrodProperties = <span class="keyword">new</span> <span class="predefined-type">Properties</span>();
hotrodProperties.load(<span class="keyword">new</span> <span class="predefined-type">FileInputStream</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/hotrod-client.properties</span><span class="delimiter">&quot;</span></span>));
org.infinispan.client.hotrod.configuration.ConfigurationBuilder configurationBuilder = <span class="keyword">new</span> ConfigurationBuilder();
configurationBuilder.withProperties(hotrodProperties);
configurationBuilder.marshaller(<span class="keyword">new</span> ProtoStreamMarshaller());
configurationBuilder.addContextInitializer(<span class="keyword">new</span> org.eclipse.jetty.session.infinispan.InfinispanSerializationContextInitializer());
org.infinispan.client.hotrod.RemoteCacheManager remoteCacheManager = <span class="keyword">new</span> RemoteCacheManager(configurationBuilder.build());
RemoteCache&lt;<span class="predefined-type">String</span>, InfinispanSessionData&gt; remoteCache = remoteCacheManager.getCache(<span class="string"><span class="delimiter">&quot;</span><span class="content">JettySessions</span><span class="delimiter">&quot;</span></span>);

<span class="comment">//Configure the Jetty session datastore with Infinispan</span>
InfinispanSessionDataStore infinispanSessionDataStore = <span class="keyword">new</span> InfinispanSessionDataStore();
infinispanSessionDataStore.setCache(remoteCache);
infinispanSessionDataStore.setSerialization(<span class="predefined-constant">true</span>); <span class="comment">//remote cache serializes session data</span>
infinispanSessionDataStore.setInfinispanIdleTimeoutSec(<span class="integer">0</span>); <span class="comment">//do not use infinispan auto delete of unused sessions</span>
infinispanSessionDataStore.setQueryManager(<span class="keyword">new</span> org.eclipse.jetty.session.infinispan.RemoteQueryManager(remoteCache)); <span class="comment">//enable Jetty session scavenging</span>
infinispanSessionDataStore.setGracePeriodSec(<span class="integer">3600</span>);
infinispanSessionDataStore.setSavePeriodSec(<span class="integer">0</span>);

<span class="comment">//Configure a SessionHandler to use a remote Infinispan cache as a store of SessionData</span>
DefaultSessionCache sessionCache = <span class="keyword">new</span> DefaultSessionCache(sessionHandler);
sessionCache.setSessionDataStore(infinispanSessionDataStore);
sessionHandler.setSessionCache(sessionCache);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-datastore-gcloud"><a class="anchor" href="#pg-server-session-datastore-gcloud"></a><a class="link" href="#pg-server-session-datastore-gcloud">The GCloudSessionDataStore</a></h5>
<div class="paragraph">
<p>The <code>GCloudSessionDataStore</code> supports persistent storage of session data into <a href="https://cloud.google.com/datastore">Google Cloud DataStore</a>.</p>
</div>
<div class="sect5">
<h6 id="pg-server-session-datastore-gcloud-prep"><a class="anchor" href="#pg-server-session-datastore-gcloud-prep"></a><a class="link" href="#pg-server-session-datastore-gcloud-prep">Preparation</a></h6>
<div class="paragraph">
<p>You will first need to create a project and enable the Google Cloud API: <a href="https://cloud.google.com/docs/authentication#preparation" class="bare">https://cloud.google.com/docs/authentication#preparation</a>.
Take note of the <code>project id</code> that you create in this step as you need to supply it in later steps.</p>
</div>
<div class="paragraph">
<p>You can choose to use Jetty either inside or outside of Google infrastructure.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Outside of Google infrastructure</p>
<div class="paragraph">
<p>Before running Jetty, you will need to choose one of the following methods to set up the local environment to enable remote GCloud DataStore communications:</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>Using the GCloud SDK</p>
<div class="ulist">
<ul>
<li>
<p>Ensure you have the GCloud SDK installed: <a href="https://cloud.google.com/sdk/?hl=en" class="bare">https://cloud.google.com/sdk/?hl=en</a></p>
</li>
<li>
<p>Use the GCloud tool to set up the project you created in the preparation step: <code>gcloud config set project PROJECT_ID</code></p>
</li>
<li>
<p>Use the GCloud tool to authenticate a Google account associated with the project created in the preparation step: <code>gcloud auth login ACCOUNT</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>Using environment variables</p>
<div class="ulist">
<ul>
<li>
<p>Define the environment variable <code>GCLOUD_PROJECT</code> with the project id you created in the preparation step.</p>
</li>
<li>
<p>Generate a JSON <a href="https://cloud.google.com/storage/docs/authentication?hl=en#service_accounts">service account key</a> and then define the environment variable <code>GOOGLE_APPLICATION_CREDENTIALS=/path/to/my/key.json</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>Inside of Google infrastructure</p>
<div class="paragraph">
<p>The Google deployment tools will automatically configure the project and authentication information for you.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Jetty GCloud session support provides some indexes as optimizations that can speed up session searches.
This will particularly benefit session scavenging, although it may make write operations slower.
By default, indexes will <em>not</em> be used.
You will see a log <code>WARNING</code> message informing you about the absence of indexes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>WARN: Session indexes not uploaded, falling back to less efficient queries</pre>
</div>
</div>
<div class="paragraph">
<p>In order to use them, you will need to manually upload the file to GCloud that defines the indexes.
This file is named <code>index.yaml</code> and you can find it in your distribution in <code>$JETTY_BASE/etc/sessions/gcloud/index.yaml</code>.</p>
</div>
<div class="paragraph">
<p>Follow the instructions <a href="https://cloud.google.com/datastore/docs/tools/#the_development_workflow_using_gcloud">here</a> to upload the pre-generated <code>index.yaml</code> file.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-configuration"><a class="anchor" href="#pg-configuration"></a><a class="link" href="#pg-configuration">Configuration</a></h6>
<div class="paragraph">
<p>The following configuration options apply to both the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/GCloudSessionDataStore.html">GCloudSessionDataStore</a> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/GCloudSessionDataStoreFactory.html">GCloudSessionDataStoreFactory</a>.
Use the latter if you want multiple <code>SessionHandler</code>s to use <code>GCloudSessionDataStore</code>s that are identically configured.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">setSavePeriodSec(int) <em>[Default:0]</em> </dt>
<dd>
<p>This is an interval defined in seconds.
It is used to reduce the frequency with which <code>SessionData</code> is written.
Normally, whenever the last concurrent request leaves a <code>Session</code>, the <code>SessionData</code> for that <code>Session</code> is always persisted, even if the only thing that changed is the <code>lastAccessTime</code>.
If the <code>savePeriodSec</code> is non-zero, the <code>SessionData</code> will not be persisted if no session attributes changed, <em>unless</em> the time since the last save exceeds the <code>savePeriod</code>.
Setting a non-zero value can reduce the load on the persistence mechanism, but in a clustered environment runs the risk that other nodes will see the session as expired because it has not been persisted sufficiently recently.</p>
</dd>
<dt class="hdlist1">setGracePeriodSec(int) <em>[Default:3600]</em> </dt>
<dd>
<p>The <code>gracePeriod</code> is an interval defined in seconds.
It is an attempt to deal with the non-transactional nature of sessions with regard to finding sessions that have expired.
In a clustered configuration - even with a sticky load balancer - it is always possible that a session is "live" on a node but not yet updated in the persistent store.
This means that it can be hard to determine at any given moment whether a clustered session has truly expired.
Thus, we use the <code>gracePeriod</code> to provide a bit of leeway around the moment of expiry during <a href="#pg-server-session-housekeeper">scavenging</a>:</p>
<div class="ulist">
<ul>
<li>
<p>on every <a href="#pg-server-session-housekeeper">scavenge</a> cycle an <code>AbstractSessionDataStore</code> searches for sessions that belong to the context that expired at least one <code>gracePeriod</code> ago</p>
</li>
<li>
<p>infrequently the <code>AbstractSessionDataStore</code> searches for and summarily deletes sessions - from any context - that expired at least 10 <code>gracePeriod</code>s ago</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">setProjectId(String) <em>[Default: null]</em> </dt>
<dd>
<p>Optional.
The <code>project id</code> of your project.
You don&#8217;t need to set this if you carried out the instructions in the <a href="#pg-server-session-datastore-gcloud-prep">Preparation</a> section, but you might want to set this - along with the <code>host</code> and/or <code>namespace</code> parameters - if you want more explicit control over connecting to GCloud.</p>
</dd>
<dt class="hdlist1">setHost(String) <em>[Default: null]</em> </dt>
<dd>
<p>Optional.
This is the name of the host for the GCloud DataStore.
If you leave it unset, then the GCloud DataStore library will work out the host to contact.
You might want to use this - along with <code>projectId</code> and/or <code>namespace</code> parameters - if you want more explicit control over connecting to GCloud.</p>
</dd>
<dt class="hdlist1">setNamespace(String) <em>[Default: null]</em> </dt>
<dd>
<p>Optional.
If set, partitions the visibility of session data in multi-tenant deployments.
More information can be found <a href="https://cloud.google.com/datastore/docs/concepts/multitenancy">here.</a></p>
</dd>
<dt class="hdlist1">setMaxRetries(int) <em>[Default: 5]</em> </dt>
<dd>
<p>This is the maximum number of retries to connect to GCloud DataStore in order to write a session.
This is used in conjunction with the <code>backoffMs</code> parameter to control the frequency with which Jetty will retry to contact GCloud to write out a session.</p>
</dd>
<dt class="hdlist1">setBackoffMs(int) <em>[Default: 1000]</em> </dt>
<dd>
<p>This is the interval that Jetty will wait in between retrying failed writes.
Each time a write fails, Jetty doubles the previous backoff.
Used in conjunction with the <code>maxRetries</code> parameter.</p>
</dd>
<dt class="hdlist1">setEntityDataModel(EntityDataModel)</dt>
<dd>
<p>The <code>EntityDataModel</code> encapsulates the type (called "kind" in GCloud DataStore) of stored session objects and the names of its fields.
If you do not set this parameter, <code>GCloudSessionDataStore</code> uses all default values, which should be sufficient for most needs.
Should you need to customize this, the methods and their defaults are:</p>
<div class="ulist">
<ul>
<li>
<p><strong>setKind(String)</strong> <em>[Default: "GCloudSession"]</em> this is the type of the session object.</p>
</li>
<li>
<p><strong>setId(String)</strong> <em>[Default: "id"]</em>  this is the name of the field storing the session id.</p>
</li>
<li>
<p><strong>setContextPath(String)</strong> <em>[Default: "contextPath"]</em> this is name of the field storing the canonicalized context path of the context to which the session belongs.</p>
</li>
<li>
<p><strong>setVhost(String)</strong> <em>[Default: "vhost"]</em>  this the name of the field storing the canonicalized virtual host of the context to which the session belongs.</p>
</li>
<li>
<p><strong>setAccessed(String)</strong> <em>[Default: "accessed"]</em>  this is the name of the field storing the current access time of the session.</p>
</li>
<li>
<p><strong>setLastAccessed(String)</strong> <em>[Default: "lastAccessed"]</em> this is the name of the field storing the last access time of the session.</p>
</li>
<li>
<p><strong>setCreateTime(String)</strong> <em>[Default: "createTime"]</em> this is the name of the field storing the time in ms since the epoch, at which the session was created.</p>
</li>
<li>
<p><strong>setCookieSetTime(String)</strong> <em>[Default: "cookieSetTime"]</em> this is the name of the field storing time at which the session cookie was last set.</p>
</li>
<li>
<p><strong>setLastNode(String)</strong> <em>[Default: "lastNode"]</em> this is the name of the field storing the <code>workerName</code> of the last node to manage the session.</p>
</li>
<li>
<p><strong>setExpiry(String)</strong> <em>[Default: "expiry"]</em> this is the name of the field storing the time, in ms since the epoch, at which the session will expire.</p>
</li>
<li>
<p><strong>setMaxInactive(String)</strong> <em>[Default: "maxInactive"]</em> this is the name of the field storing the session timeout in ms.</p>
</li>
<li>
<p><strong>setAttributes(String)</strong> <em>[Default: "attributes"]</em> this is the name of the field storing the session attribute map.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of configuring a <code>GCloudSessionDataStoreFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">//Ensure there is a SessionCacheFactory</span>
DefaultSessionCacheFactory cacheFactory = <span class="keyword">new</span> DefaultSessionCacheFactory();

<span class="comment">//Add the factory as a bean to the server, now whenever a</span>
<span class="comment">//SessionManager starts it will consult the bean to create a new DefaultSessionCache</span>
server.addBean(cacheFactory);

<span class="comment">//Configure the GCloudSessionDataStoreFactory</span>
GCloudSessionDataStoreFactory storeFactory = <span class="keyword">new</span> GCloudSessionDataStoreFactory();
storeFactory.setGracePeriodSec(<span class="integer">3600</span>);
storeFactory.setSavePeriodSec(<span class="integer">0</span>);
storeFactory.setBackoffMs(<span class="integer">2000</span>); <span class="comment">//increase the time between retries of failed writes</span>
storeFactory.setMaxRetries(<span class="integer">10</span>); <span class="comment">//increase the number of retries of failed writes</span>

<span class="comment">//Add the factory as a bean on the server, now whenever a</span>
<span class="comment">//SessionManager starts, it will consult the bean to create a new GCloudSessionDataStore</span>
<span class="comment">//for use by the DefaultSessionCache</span>
server.addBean(storeFactory);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-session-cachingsessiondatastore"><a class="anchor" href="#pg-server-session-cachingsessiondatastore"></a><a class="link" href="#pg-server-session-cachingsessiondatastore">The CachingSessionDataStore</a></h5>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-3e23a5cd9673dbe358271d004cc0d714.png" alt="Diagram" width="394" height="277">
</div>
</div>
<div class="paragraph">
<p>The <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/CachingSessionDataStore.html">CachingSessionDataStore</a> is a special type of <code>SessionDataStore</code> that checks an L2 cache for <code>SessionData</code> before checking a delegate <code>SessionDataStore</code>.
This can improve the performance of slow stores.</p>
</div>
<div class="paragraph">
<p>The L2 cache is an instance of a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/session/SessionDataMap.html">SessionDataMap</a>.
Jetty provides one implementation of this L2 cache based on <code>memcached</code>, <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/memcached/session/MemcachedSessionDataMap.html">MemcachedSessionDataMap</a>.</p>
</div>
<div class="paragraph">
<p>This is an example of how to programmatically configure <code>CachingSessionDataStore</code>s, using a <a href="#pg-server-session-datastore-file">FileSessionDataStore</a> as a delegate, and <code>memcached</code> as the L2 cache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">//Make a factory for memcached L2 caches for SessionData</span>
MemcachedSessionDataMapFactory mapFactory = <span class="keyword">new</span> MemcachedSessionDataMapFactory();
mapFactory.setExpirySec(<span class="integer">0</span>); <span class="comment">//items in memcached don't expire</span>
mapFactory.setHeartbeats(<span class="predefined-constant">true</span>); <span class="comment">//tell memcached to use heartbeats</span>
mapFactory.setAddresses(<span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">localhost</span><span class="delimiter">&quot;</span></span>, <span class="integer">11211</span>)); <span class="comment">//use a local memcached instance</span>
mapFactory.setWeights(<span class="keyword">new</span> <span class="type">int</span><span class="type">[]</span>{<span class="integer">100</span>}); <span class="comment">//set the weighting</span>

<span class="comment">//Make a FileSessionDataStoreFactory for creating FileSessionDataStores</span>
<span class="comment">//to persist the session data</span>
FileSessionDataStoreFactory storeFactory = <span class="keyword">new</span> FileSessionDataStoreFactory();
storeFactory.setStoreDir(<span class="keyword">new</span> <span class="predefined-type">File</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/sessions</span><span class="delimiter">&quot;</span></span>));
storeFactory.setGracePeriodSec(<span class="integer">3600</span>);
storeFactory.setSavePeriodSec(<span class="integer">0</span>);

<span class="comment">//Make a factory that plugs the L2 cache into the SessionDataStore</span>
CachingSessionDataStoreFactory cachingSessionDataStoreFactory = <span class="keyword">new</span> CachingSessionDataStoreFactory();
cachingSessionDataStoreFactory.setSessionDataMapFactory(mapFactory);
cachingSessionDataStoreFactory.setSessionStoreFactory(storeFactory);

<span class="comment">//Register it as a bean so that all SessionManagers will use it</span>
<span class="comment">//to make FileSessionDataStores that use memcached as an L2 SessionData cache.</span>
server.addBean(cachingSessionDataStoreFactory);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-websocket"><a class="anchor" href="#pg-server-websocket"></a><a class="link" href="#pg-server-websocket">WebSocket Server</a></h3>
<div class="paragraph">
<p>Jetty provides different implementations of the WebSocket protocol:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Jakarta EE 8 (<code>javax.websocket</code>) implementation, based on the <a href="https://jakarta.ee/specifications/websocket/1.1/">Jakarta WebSocket 1.1 Specification</a>.</p>
</li>
<li>
<p>A Jakarta EE 9 (<code>jakarta.websocket</code>) implementation, based on the <a href="https://jakarta.ee/specifications/websocket/2.0/">Jakarta WebSocket 2.0 Specification</a>.</p>
</li>
<li>
<p>A Jakarta EE 10 (<code>jakarta.websocket</code>) implementation, based on the <a href="https://jakarta.ee/specifications/websocket/2.1/">Jakarta WebSocket 2.1 Specification</a>.</p>
</li>
<li>
<p>A Jetty specific implementation, based on the Jetty WebSocket APIs, that does not depend on any Jakarta EE APIs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Jakarta EE implementations and APIs are described in <a href="#pg-server-websocket-standard">this section</a>.</p>
</div>
<div class="paragraph">
<p>Using the standard Jakarta EE WebSocket APIs allows your applications to depend only on standard APIs, and your applications may be deployed in any compliant WebSocket Container that supports Jakarta WebSocket.
The standard Jakarta EE WebSocket APIs provide these features that are not present in the Jetty WebSocket APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Encoders and Decoders for automatic conversion of text or binary messages to objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Jetty specific WebSocket implementation and APIs are described in <a href="#pg-server-websocket-jetty">this section</a>.</p>
</div>
<div class="paragraph">
<p>Using the Jetty WebSocket APIs allows your applications to be more efficient and offer greater and more fine-grained control, and provide these features that are not present in the Jakarta EE WebSocket APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A demand mechanism to control backpressure.</p>
</li>
<li>
<p>Remote socket address (IP address and port) information.</p>
</li>
<li>
<p>Advanced request URI matching with regular expressions, in addition to Servlet patterns and URI template patterns.</p>
</li>
<li>
<p>More configuration options, for example the network buffer capacity.</p>
</li>
<li>
<p>Programmatic WebSocket upgrade, in addition to WebSocket upgrade based on URI matching, for maximum flexibility.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If your application needs specific features that are not provided by the standard APIs, the Jetty WebSocket APIs may provide such features.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If the feature you are looking for is not present, you may ask for these features by <a href="https://github.com/eclipse/jetty.project/issues">submitting an issue</a> to the Jetty Project without waiting for the standard Jakarta EE process to approve them and release a new version of the Jakarta EE WebSocket specification.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="pg-server-websocket-standard"><a class="anchor" href="#pg-server-websocket-standard"></a><a class="link" href="#pg-server-websocket-standard">Standard APIs Implementation</a></h4>
<div class="paragraph">
<p>When you write a WebSocket application using the standard <code>jakarta.websocket</code> APIs, your code typically need to depend on just the APIs to compile your application.
However, at runtime you need to have an implementation of the standard APIs in your class-path (or module-path).</p>
</div>
<div class="paragraph">
<p>The standard <code>jakarta.websocket</code> APIs, for example for Jakarta EE 10, are provided by the following Maven artifact:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>jakarta.websocket<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jakarta.websocket-api<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>2.1.0<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At runtime, you also need an implementation of the standard Jakarta EE 10 WebSocket APIs, that Jetty provides with the following Maven artifact (and its transitive dependencies):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10.websocket<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-websocket-jakarta-server<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>jakarta.websocket-api</code> artifact and the <code>jetty-ee10-websocket-jakarta-server</code> artifact (and their transitive dependencies) should be present in the server class-path (or module-path), and never in the web application&#8217;s <code>/WEB-INF/lib</code> directory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To configure correctly your WebSocket application based on the standard Jakarta EE 10 WebSocket APIs, you need two steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that Jetty sets up an instance of <code>jakarta.websocket.server.ServerContainer</code>, described in <a href="#pg-server-websocket-standard-container">this section</a>.</p>
</li>
<li>
<p>Configure the WebSocket endpoints that implement your application logic, either by annotating their classes with the standard <code>jakarta.websocket</code> annotations, or by using the <code>ServerContainer</code> APIs to register them in your code, described in <a href="#pg-server-websocket-standard-endpoints">this section</a>.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="pg-server-websocket-standard-container"><a class="anchor" href="#pg-server-websocket-standard-container"></a><a class="link" href="#pg-server-websocket-standard-container">Setting Up <code>ServerContainer</code></a></h5>
<div class="paragraph">
<p>Jetty sets up a <code>ServerContainer</code> instance using <code>JakartaWebSocketServletContainerInitializer</code>.</p>
</div>
<div class="paragraph">
<p>When you deploy web applications using <a href="#pg-server-http-handler-use-webapp-context"><code>WebAppContext</code></a>, then  <code>JakartaWebSocketServletContainerInitializer</code> is automatically discovered and initialized by Jetty when the web application starts, so that it sets up the <code>ServerContainer</code>.
In this way, you do not need to write any additional code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a WebAppContext with the given context path.</span>
WebAppContext handler = <span class="keyword">new</span> WebAppContext(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/webapp</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(handler);

<span class="comment">// Starting the Server will start the WebAppContext.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, when you deploy web applications using <a href="#pg-server-http-handler-use-servlet-context"><code>ServletContextHandler</code></a>, you have to write the code to ensure that the <code>JakartaWebSocketServletContainerInitializer</code> is initialized, so that it sets up the <code>ServerContainer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a ServletContextHandler with the given context path.</span>
ServletContextHandler handler = <span class="keyword">new</span> ServletContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(handler);

<span class="comment">// Ensure that JavaxWebSocketServletContainerInitializer is initialized,</span>
<span class="comment">// to setup the ServerContainer for this web application context.</span>
JakartaWebSocketServletContainerInitializer.configure(handler, <span class="predefined-constant">null</span>);

<span class="comment">// Starting the Server will start the ServletContextHandler.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Calling <code>JakartaWebSocketServletContainerInitializer.configure(...)</code> must be done <em>before</em> the <code>ServletContextHandler</code> is started, and configures the Jakarta EE 10 WebSocket implementation for that web application context, making <code>ServerContainer</code> available to web applications.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-websocket-standard-endpoints"><a class="anchor" href="#pg-server-websocket-standard-endpoints"></a><a class="link" href="#pg-server-websocket-standard-endpoints">Configuring Endpoints</a></h5>
<div class="paragraph">
<p>Once you have <a href="#pg-server-websocket-standard-container">setup</a> the <code>ServerContainer</code>, you can configure your WebSocket endpoints.</p>
</div>
<div class="paragraph">
<p>The WebSocket endpoints classes may be either annotated with the standard <code>jakarta.websocket</code> annotations, extend the <code>jakarta.websocket.Endpoint</code> abstract class, or implement the <code>jakarta.websocket.server.ServerApplicationConfig</code> interface.</p>
</div>
<div class="paragraph">
<p>When you deploy web applications using <a href="#pg-server-http-handler-use-webapp-context"><code>WebAppContext</code></a>, then annotated WebSocket endpoint classes are automatically discovered and registered.
In this way, you do not need to write any additional code; you just need to ensure that your WebSocket endpoint classes are present in the web application&#8217;s <code>/WEB-INF/classes</code> directory, or in a <code>*.jar</code> file in <code>/WEB-INF/lib</code>.</p>
</div>
<div class="paragraph">
<p>On the other hand, when you deploy web applications using <a href="#pg-server-http-handler-use-webapp-context"><code>WebAppContext</code></a> but you need to perform more advanced configuration of the <code>ServerContainer</code> or of the WebSocket endpoints, or when you deploy web applications using <a href="#pg-server-http-handler-use-servlet-context"><code>ServletContextHandler</code></a>, you need to access the <code>ServerContainer</code> APIs.</p>
</div>
<div class="paragraph">
<p>The <code>ServerContainer</code> instance is stored as a <code>ServletContext</code> attribute, so it can be retrieved when the <code>ServletContext</code> is initialized, either from a <code>ServletContextListener</code>, or from a Servlet <code>Filter</code>, or from an <code>HttpServlet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a ServletContextHandler with the given context path.</span>
ServletContextHandler handler = <span class="keyword">new</span> ServletContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(handler);

<span class="comment">// Ensure that JavaxWebSocketServletContainerInitializer is initialized,</span>
<span class="comment">// to setup the ServerContainer for this web application context.</span>
JakartaWebSocketServletContainerInitializer.configure(handler, <span class="predefined-constant">null</span>);

<span class="comment">// Add a WebSocket-initializer Servlet to register WebSocket endpoints.</span>
handler.addServlet(MyJavaxWebSocketInitializerServlet.class, <span class="string"><span class="delimiter">&quot;</span><span class="content">/*</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Starting the Server will start the ServletContextHandler.</span>
server.start();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">MyJavaxWebSocketInitializerServlet</span> <span class="directive">extends</span> HttpServlet
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> init() <span class="directive">throws</span> ServletException
    {
        <span class="keyword">try</span>
        {
            <span class="comment">// Retrieve the ServerContainer from the ServletContext attributes.</span>
            ServerContainer container = (ServerContainer)getServletContext().getAttribute(ServerContainer.class.getName());

            <span class="comment">// Configure the ServerContainer.</span>
            container.setDefaultMaxTextMessageBufferSize(<span class="integer">128</span> * <span class="integer">1024</span>);

            <span class="comment">// Simple registration of your WebSocket endpoints.</span>
            container.addEndpoint(MyJavaxWebSocketEndPoint.class);

            <span class="comment">// Advanced registration of your WebSocket endpoints.</span>
            container.addEndpoint(
                ServerEndpointConfig.Builder.create(MyJavaxWebSocketEndPoint.class, <span class="string"><span class="delimiter">&quot;</span><span class="content">/ws</span><span class="delimiter">&quot;</span></span>)
                    .subprotocols(<span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-ws-protocol</span><span class="delimiter">&quot;</span></span>))
                    .build()
            );
        }
        <span class="keyword">catch</span> (DeploymentException x)
        {
            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(x);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you deploy web applications using <a href="#pg-server-http-handler-use-servlet-context"><code>ServletContextHandler</code></a>, you can alternatively use the code below to set up the <code>ServerContainer</code> and configure the WebSocket endpoints in one step:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a ServletContextHandler with the given context path.</span>
ServletContextHandler handler = <span class="keyword">new</span> ServletContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(handler);

<span class="comment">// Setup the ServerContainer and the WebSocket endpoints for this web application context.</span>
JakartaWebSocketServletContainerInitializer.configure(handler, (servletContext, container) -&gt;
{
    <span class="comment">// Configure the ServerContainer.</span>
    container.setDefaultMaxTextMessageBufferSize(<span class="integer">128</span> * <span class="integer">1024</span>);

    <span class="comment">// Simple registration of your WebSocket endpoints.</span>
    container.addEndpoint(MyJavaxWebSocketEndPoint.class);

    <span class="comment">// Advanced registration of your WebSocket endpoints.</span>
    container.addEndpoint(
        ServerEndpointConfig.Builder.create(MyJavaxWebSocketEndPoint.class, <span class="string"><span class="delimiter">&quot;</span><span class="content">/ws</span><span class="delimiter">&quot;</span></span>)
            .subprotocols(<span class="predefined-type">List</span>.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-ws-protocol</span><span class="delimiter">&quot;</span></span>))
            .build()
    );
});

<span class="comment">// Starting the Server will start the ServletContextHandler.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>ServletContextHandler</code> is started, the <code>Configurator</code> lambda (the second parameter passed to <code>JakartaWebSocketServletContainerInitializer.configure(...)</code>) is invoked and allows you to explicitly configure the WebSocket endpoints using the standard APIs provided by <code>ServerContainer</code>.</p>
</div>
<div class="sect5">
<h6 id="pg-server-websocket-standard-upgrade"><a class="anchor" href="#pg-server-websocket-standard-upgrade"></a><a class="link" href="#pg-server-websocket-standard-upgrade">Upgrade to WebSocket</a></h6>
<div class="paragraph">
<p>Under the hood, <code>JakartaWebSocketServletContainerInitializer</code> installs the <code>org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter</code>, which is the component that intercepts HTTP requests to upgrade to WebSocket, and performs the upgrade from the HTTP protocol to the WebSocket protocol.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>WebSocketUpgradeFilter</code> is installed under the filter name corresponding to its class name (that is, the string <code>"org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter"</code>) and with a filter mapping of <code>/*</code>.</p>
</div>
<div class="paragraph">
<p>Refer to the <a href="#pg-server-websocket-configure-filter">advanced <code>WebSocketUpgradeFilter</code> configuration section</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With the default configuration, every HTTP request flows first through the <code>WebSocketUpgradeFilter</code>.</p>
</div>
<div class="paragraph">
<p>If the HTTP request is a valid upgrade to WebSocket, then <code>WebSocketUpgradeFilter</code> tries to find a matching WebSocket endpoint for the request URI path; if the match is found, <code>WebSocketUpgradeFilter</code> performs the upgrade and does not invoke any other Filter or Servlet.
From this point on, the communication happens with the WebSocket protocol, and HTTP components such as Filters and Servlets are not relevant anymore.</p>
</div>
<div class="paragraph">
<p>If the HTTP request is not an upgrade to WebSocket, or <code>WebSocketUpgradeFilter</code> did not find a matching WebSocket endpoint for the request URI path, then the request is passed to the Filter chain of your web application, and eventually the request arrives to a Servlet to be processed (otherwise a <code>404 Not Found</code> response is returned to client).</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-websocket-configure-filter"><a class="anchor" href="#pg-server-websocket-configure-filter"></a><a class="link" href="#pg-server-websocket-configure-filter">Advanced <code>WebSocketUpgradeFilter</code> Configuration</a></h4>
<div class="paragraph">
<p>The <code>WebSocketUpgradeFilter</code> that handles the HTTP requests that upgrade to WebSocket is installed by the <code>JakartaWebSocketServletContainerInitializer</code>, as described in <a href="#pg-server-websocket-standard">this section</a>.</p>
</div>
<div class="paragraph">
<p>Typically, the <code>WebSocketUpgradeFilter</code> is not present in the <code>web.xml</code> configuration, and therefore the mechanisms above create a new <code>WebSocketUpgradeFilter</code> and install it <em>before</em> any other Filter declared in <code>web.xml</code>, under the default name of <code>"org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter"</code> and with path mapping <code>/*</code>.</p>
</div>
<div class="paragraph">
<p>However, if the <code>WebSocketUpgradeFilter</code> is already present in <code>web.xml</code> under the default name, then the <code>ServletContainerInitializer</code>s will use that declared in <code>web.xml</code> instead of creating a new one.</p>
</div>
<div class="paragraph">
<p>This allows you to customize:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The filter order; for example, by configuring filters for increased security or authentication <em>before</em> the <code>WebSocketUpgradeFilter</code>.</p>
</li>
<li>
<p>The <code>WebSocketUpgradeFilter</code> configuration via <code>init-param</code>s, that affects all <code>Session</code> instances created by this filter.</p>
</li>
<li>
<p>The <code>WebSocketUpgradeFilter</code> path mapping. Rather than the default mapping of <code>/*</code>, you can map the <code>WebSocketUpgradeFilter</code> to a more specific path such as <code>/ws/*</code>.</p>
</li>
<li>
<p>The possibility to have multiple <code>WebSocketUpgradeFilter</code>s, mapped to different paths, each with its own configuration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;web-app</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">5.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;display-name&gt;</span>My WebSocket WebApp<span class="tag">&lt;/display-name&gt;</span>

  <span class="comment">&lt;!-- The SecurityFilter *must* be the first --&gt;</span> <i class="conum" data-value="1"></i><b>(1)</b>
  <span class="tag">&lt;filter&gt;</span>
    <span class="tag">&lt;filter-name&gt;</span>security<span class="tag">&lt;/filter-name&gt;</span>
    <span class="tag">&lt;filter-class&gt;</span>com.acme.SecurityFilter<span class="tag">&lt;/filter-class&gt;</span>
    <span class="tag">&lt;async-supported&gt;</span>true<span class="tag">&lt;/async-supported&gt;</span>
  <span class="tag">&lt;/filter&gt;</span>
  <span class="tag">&lt;filter-mapping&gt;</span>
    <span class="tag">&lt;filter-name&gt;</span>security<span class="tag">&lt;/filter-name&gt;</span>
    <span class="tag">&lt;url-pattern&gt;</span>/*<span class="tag">&lt;/url-pattern&gt;</span>
  <span class="tag">&lt;/filter-mapping&gt;</span>

  <span class="comment">&lt;!-- Configure the default WebSocketUpgradeFilter --&gt;</span> <i class="conum" data-value="2"></i><b>(2)</b>
  <span class="tag">&lt;filter&gt;</span>
    <span class="comment">&lt;!-- The filter name must be the default WebSocketUpgradeFilter name --&gt;</span>
    <span class="tag">&lt;filter-name&gt;</span>org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter<span class="tag">&lt;/filter-name&gt;</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="tag">&lt;filter-class&gt;</span>org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter<span class="tag">&lt;/filter-class&gt;</span>
    <span class="comment">&lt;!-- Configure at most 1 MiB text messages --&gt;</span>
    <span class="tag">&lt;init-param&gt;</span> <i class="conum" data-value="4"></i><b>(4)</b>
      <span class="tag">&lt;param-name&gt;</span>maxTextMessageSize<span class="tag">&lt;/param-name&gt;</span>
      <span class="tag">&lt;param-value&gt;</span>1048576<span class="tag">&lt;/param-value&gt;</span>
    <span class="tag">&lt;/init-param&gt;</span>
    <span class="tag">&lt;async-supported&gt;</span>true<span class="tag">&lt;/async-supported&gt;</span>
  <span class="tag">&lt;/filter&gt;</span>
  <span class="tag">&lt;filter-mapping&gt;</span>
    <span class="tag">&lt;filter-name&gt;</span>org.eclipse.jetty.ee10.websocket.servlet.WebSocketUpgradeFilter<span class="tag">&lt;/filter-name&gt;</span>
    <span class="comment">&lt;!-- Use a more specific path mapping for WebSocket requests --&gt;</span>
    <span class="tag">&lt;url-pattern&gt;</span>/ws/*<span class="tag">&lt;/url-pattern&gt;</span> <i class="conum" data-value="5"></i><b>(5)</b>
  <span class="tag">&lt;/filter-mapping&gt;</span>

<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The custom <code>SecurityFilter</code> is the first, to apply custom security.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The configuration for the <em>default</em> <code>WebSocketUpgradeFilter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Note the use of the <em>default</em> <code>WebSocketUpgradeFilter</code> name.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Specific configuration for <code>WebSocketUpgradeFilter</code> parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Use a more specific path mapping for <code>WebSocketUpgradeFilter</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that using a more specific path mapping for WebSocket requests is also beneficial to the performance of normal HTTP requests: they do not go through the <code>WebSocketUpgradeFilter</code> (as they will not match its path mapping), saving the cost of analyzing them to see whether they are WebSocket upgrade requests or not.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-websocket-jetty"><a class="anchor" href="#pg-server-websocket-jetty"></a><a class="link" href="#pg-server-websocket-jetty">Jetty APIs Implementation</a></h4>
<div class="paragraph">
<p>When you write a WebSocket application using the Jetty WebSocket APIs, your code typically needs to depend on just the Jetty WebSocket APIs to compile your application.
However, at runtime you need to have the <em>implementation</em> of the Jetty WebSocket APIs in your class-path (or module-path).</p>
</div>
<div class="paragraph">
<p>Jetty&#8217;s WebSocket APIs are provided by the following Maven artifact:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-websocket-jetty-api<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetty&#8217;s implementation of the Jetty WebSocket APIs is provided by the following Maven artifact (and its transitive dependencies):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.websocket<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-websocket-jetty-server<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>jetty-websocket-jetty-api</code> artifact and the <code>jetty-websocket-jetty-server</code> artifact (and its transitive dependencies) should be present in the server class-path (or module-path), and never in a web application&#8217;s <code>/WEB-INF/lib</code> directory.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To configure correctly your WebSocket application based on the Jetty WebSocket APIs, you need two steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure to <a href="#pg-server-websocket-jetty-container">set up</a> an instance of <code>org.eclipse.jetty.websocket.server.ServerWebSocketContainer</code>.</p>
</li>
<li>
<p>Use the <code>ServerWebSocketContainer</code> APIs in your applications to <a href="#pg-server-websocket-jetty-container-websocket-handler">register the WebSocket endpoints</a> that implement your application logic.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can read more about the <a href="#pg-websocket-architecture">Jetty WebSocket architecture</a>, which is common to both client-side and server-side, to get familiar with the terminology used in the following sections.</p>
</div>
<div class="sect4">
<h5 id="pg-server-websocket-jetty-container"><a class="anchor" href="#pg-server-websocket-jetty-container"></a><a class="link" href="#pg-server-websocket-jetty-container">Setting up <code>ServerWebSocketContainer</code></a></h5>
<div class="paragraph">
<p>You need Jetty to set up a <code>ServerWebSocketContainer</code> instance to make your WebSocket applications based on the Jetty WebSocket APIs work.</p>
</div>
<div class="paragraph">
<p>Your WebSocket web application is represented by a <code>ContextHandler</code>.
The WebSocket upgrade is performed in a descendant (typically the only child) of the <code>ContextHandler</code>, either by the <code>org.eclipse.jetty.websocket.server.WebSocketUpgradeHandler</code>, or by a custom <code>Handler</code> that you write and is part of your web application.</p>
</div>
<div class="paragraph">
<p>In both cases, you need to set up a <code>ServerWebSocketContainer</code>, and this can be done <a href="#pg-server-websocket-jetty-container-websocket-handler">implicitly</a> by using <code>WebSocketUpgradeHandler</code>, or <a href="#pg-server-websocket-jetty-container-websocket-container">explicitly</a> by creating the <code>ServerWebSocketContainer</code> instance.</p>
</div>
<div class="sect5">
<h6 id="pg-server-websocket-jetty-container-websocket-handler"><a class="anchor" href="#pg-server-websocket-jetty-container-websocket-handler"></a><a class="link" href="#pg-server-websocket-jetty-container-websocket-handler">Implicit setup using <code>WebSocketUpgradeHandler</code></a></h6>
<div class="paragraph">
<p>Using <code>WebSocketUpgradeHandler</code> is the most common way to set up your WebSocket applications.</p>
</div>
<div class="paragraph">
<p>You can use the <code>WebSocketUpgradeHandler</code> and the <code>ServerWebSocketContainer</code> APIs to map HTTP request URIs to WebSocket endpoints.</p>
</div>
<div class="paragraph">
<p>When an HTTP request arrives, <code>WebSocketUpgradeHandler</code> tests whether it is a WebSocket upgrade request, whether it matches a mapped URI, and if so upgrades the protocol to WebSocket.</p>
</div>
<div class="paragraph">
<p>From this point on, the communication on the upgraded connection happens with the WebSocket protocol.
This is very similar to what <a href="#pg-server-websocket-standard-upgrade"><code>WebSocketUpgradeFilter</code></a> does when using the Jakarta EE WebSocket APIs.</p>
</div>
<div class="paragraph">
<p>Once you have set up the <code>WebSocketUpgradeHandler</code>, you can use the <code>ServerWebSocketContainer</code> APIs to configure the WebSocket endpoints.
The example below shows how to set up the <code>WebSocketUpgradeHandler</code> and use the <code>ServerWebSocketContainer</code> APIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a ContextHandler with the given context path.</span>
ContextHandler contextHandler = <span class="keyword">new</span> ContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(contextHandler);

<span class="comment">// Create a WebSocketUpgradeHandler that implicitly creates a ServerWebSocketContainer.</span>
WebSocketUpgradeHandler webSocketHandler = WebSocketUpgradeHandler.from(server, contextHandler, container -&gt;
{
    <span class="comment">// Configure the ServerWebSocketContainer.</span>
    container.setMaxTextMessageSize(<span class="integer">128</span> * <span class="integer">1024</span>);

    <span class="comment">// Map a request URI to a WebSocket endpoint, for example using a regexp.</span>
    container.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">regex|/ws/v</span><span class="char">\\</span><span class="content">d+/echo</span><span class="delimiter">&quot;</span></span>, (rq, rs, cb) -&gt; <span class="keyword">new</span> EchoEndPoint());

    <span class="comment">// Advanced registration of a WebSocket endpoint.</span>
    container.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ws/adv</span><span class="delimiter">&quot;</span></span>, (rq, rs, cb) -&gt;
    {
        <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; subProtocols = rq.getSubProtocols();
        <span class="keyword">if</span> (subProtocols.contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">my-ws-protocol</span><span class="delimiter">&quot;</span></span>))
            <span class="keyword">return</span> <span class="keyword">new</span> MyJettyWebSocketEndPoint();
        <span class="keyword">return</span> <span class="predefined-constant">null</span>;
    });
});
contextHandler.setHandler(webSocketHandler);

<span class="comment">// Starting the Server will start the ContextHandler and the WebSocketUpgradeHandler,</span>
<span class="comment">// which would run the configuration of the ServerWebSocketContainer.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The mapping of request URIs to WebSocket endpoints is further explained in <a href="#pg-server-websocket-jetty-pathspec">this section</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="pg-server-websocket-jetty-container-websocket-container"><a class="anchor" href="#pg-server-websocket-jetty-container-websocket-container"></a><a class="link" href="#pg-server-websocket-jetty-container-websocket-container">Explicit setup using <code>ServerWebSocketContainer</code></a></h6>
<div class="paragraph">
<p>A more advanced way to set up your WebSocket applications is to explicitly create the <code>ServerWebSocketContainer</code> instance programmatically.</p>
</div>
<div class="paragraph">
<p>This gives you more flexibility when deciding whether an HTTP request should be upgraded to WebSocket, because you do not need to match request URIs (although you can), nor you need to use <code>WebSocketUpgradeHandler</code> (although you can).</p>
</div>
<div class="paragraph">
<p>Once you have created the <code>ServerWebSocketContainer</code>, you can use its APIs to configure the WebSocket endpoints as shown in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create a Server with a ServerConnector listening on port 8080.</span>
Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

<span class="comment">// Create a ContextHandler with the given context path.</span>
ContextHandler contextHandler = <span class="keyword">new</span> ContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(contextHandler);

<span class="comment">// Create a ServerWebSocketContainer, which is also stored as an attribute in the context.</span>
ServerWebSocketContainer container = ServerWebSocketContainer.ensure(server, contextHandler);

<span class="comment">// You can use WebSocketUpgradeHandler if you want, but it is not necessary.</span>
<span class="comment">// You can ignore the line below, it is shown only for reference.</span>
WebSocketUpgradeHandler webSocketHandler = <span class="keyword">new</span> WebSocketUpgradeHandler(container);

<span class="comment">// You can directly use ServerWebSocketContainer from any Handler.</span>
contextHandler.setHandler(<span class="keyword">new</span> <span class="predefined-type">Handler</span>.Abstract()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback)
    {
        <span class="comment">// Retrieve the ServerWebSocketContainer.</span>
        ServerWebSocketContainer container = ServerWebSocketContainer.get(request.getContext());

        <span class="comment">// Verify special conditions for which a request should be upgraded to WebSocket.</span>
        <span class="predefined-type">String</span> pathInContext = Request.getPathInContext(request);
        <span class="keyword">if</span> (pathInContext.startsWith(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ws/echo</span><span class="delimiter">&quot;</span></span>) &amp;&amp; request.getHeaders().contains(<span class="string"><span class="delimiter">&quot;</span><span class="content">X-WS</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">true</span><span class="delimiter">&quot;</span></span>))
        {
            <span class="keyword">try</span>
            {
                <span class="comment">// This is a WebSocket upgrade request, perform a direct upgrade.</span>
                <span class="type">boolean</span> upgraded = container.upgrade((rq, rs, cb) -&gt; <span class="keyword">new</span> EchoEndPoint(), request, response, callback);
                <span class="keyword">if</span> (upgraded)
                    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
                <span class="comment">// This was supposed to be a WebSocket upgrade request, but something went wrong.</span>
                Response.writeError(request, response, callback, HttpStatus.UPGRADE_REQUIRED_426);
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
            <span class="keyword">catch</span> (<span class="exception">Exception</span> x)
            {
                Response.writeError(request, response, callback, HttpStatus.UPGRADE_REQUIRED_426, <span class="string"><span class="delimiter">&quot;</span><span class="content">failed to upgrade</span><span class="delimiter">&quot;</span></span>, x);
                <span class="keyword">return</span> <span class="predefined-constant">true</span>;
            }
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Handle a normal HTTP request.</span>
            response.setStatus(HttpStatus.OK_200);
            callback.succeeded();
            <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        }
    }
});

<span class="comment">// Starting the Server will start the ContextHandler.</span>
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the call to <code>ServerWebSocketContainer.upgrade(...)</code> allows you to perform a direct WebSocket upgrade programmatically.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-server-websocket-jetty-endpoints"><a class="anchor" href="#pg-server-websocket-jetty-endpoints"></a><a class="link" href="#pg-server-websocket-jetty-endpoints">WebSocket Endpoints</a></h5>
<div class="paragraph">
<p>When using the Jetty WebSocket APIs, the WebSocket endpoint classes must be either annotated with the Jetty WebSocket annotations from the <code>org.eclipse.jetty.websocket.api.annotations</code> package, or implement the <code>org.eclipse.jetty.websocket.api.Session.Listener</code> interface.</p>
</div>
<div class="paragraph">
<p>In the case you want to implement the <code>Session.Listener</code> interface, remember that you have to explicitly demand to receive the next WebSocket event.
Use <code>Session.Listener.AutoDemanding</code> to automate the demand for simple use cases.</p>
</div>
<div class="paragraph">
<p>Refer to the Jetty WebSocket architecture <a href="#pg-websocket-endpoints">section</a> for more information about Jetty WebSocket endpoints and how to correctly deal with the demand for WebSocket events.</p>
</div>
<div class="paragraph">
<p>There is no automatic discovery of WebSocket endpoints; all the WebSocket endpoints of your application must be returned by a <code>org.eclipse.jetty.websocket.server.WebSocketCreator</code> that is either mapped to a request URI via <code>ServerWebSocketContainer.addMapping(...)</code>, or directly upgraded via <code>ServerWebSocketContainer.upgrade(...)</code>.</p>
</div>
<div class="paragraph">
<p>In the call to <code>ServerWebSocketContainer.addMapping(...)</code>, you can specify a <em>path spec</em> (the first parameter) that can specified as discussed in <a href="#pg-server-websocket-jetty-pathspec">this section</a>.</p>
</div>
<div class="paragraph">
<p>When the <code>Server</code> is started, the lambda passed to <code>ServerWebSocketContainer.configure(...)</code>) is invoked and allows you to explicitly configure the WebSocket endpoints using the Jetty WebSocket APIs provided by <code>ServerWebSocketContainer</code>.</p>
</div>
<div class="sect5">
<h6 id="pg-server-websocket-jetty-pathspec"><a class="anchor" href="#pg-server-websocket-jetty-pathspec"></a><a class="link" href="#pg-server-websocket-jetty-pathspec">Custom PathSpec Mappings</a></h6>
<div class="paragraph">
<p>The <code>ServerWebSocketContainer.addMapping(...)</code> API maps a <em>path spec</em> to a <code>WebSocketCreator</code> instance (typically a lambda expression).
The path spec is matched against the WebSocket upgrade request URI to select the correspondent <code>WebSocketCreator</code> to invoke.</p>
</div>
<div class="paragraph">
<p>The path spec can have these forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Servlet syntax, specified with <code>servlet|&lt;path spec&gt;</code>, where the <code>servlet|</code> prefix can be omitted if the path spec begins with <code>/</code> or <code>*.</code> (for example, <code>/ws</code>, <code>/ws/chat</code> or <code>*.ws</code>).</p>
</li>
<li>
<p>Regex syntax, specified with <code>regex|&lt;path spec&gt;</code>, where the <code>regex|</code> prefix can be omitted if the path spec begins with <code>^</code> (for example, <code>^/ws/[0-9]+</code>).</p>
</li>
<li>
<p>URI template syntax, specified with <code>uri-template|&lt;path spec&gt;</code> (for example <code>uri-template|/ws/chat/{room}</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Within the <code>WebSocketCreator</code>, it is possible to access the path spec and, for example in case of URI templates, extract additional information in the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);

ContextHandler contextHandler = <span class="keyword">new</span> ContextHandler(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ctx</span><span class="delimiter">&quot;</span></span>);
server.setHandler(contextHandler);

<span class="comment">// Create a WebSocketUpgradeHandler.</span>
WebSocketUpgradeHandler webSocketHandler = WebSocketUpgradeHandler.from(server, contextHandler, container -&gt;
{
    container.addMapping(<span class="string"><span class="delimiter">&quot;</span><span class="content">/ws/chat/{room}</span><span class="delimiter">&quot;</span></span>, (upgradeRequest, upgradeResponse, callback) -&gt;
    {
        <span class="comment">// Retrieve the URI template.</span>
        UriTemplatePathSpec pathSpec = (UriTemplatePathSpec)upgradeRequest.getAttribute(PathSpec.class.getName());

        <span class="comment">// Match the URI template.</span>
        <span class="predefined-type">String</span> pathInContext = Request.getPathInContext(upgradeRequest);
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">String</span>&gt; params = pathSpec.getPathParams(pathInContext);
        <span class="predefined-type">String</span> room = params.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">room</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Create the new WebSocket endpoint with the URI template information.</span>
        <span class="keyword">return</span> <span class="keyword">new</span> MyWebSocketRoomEndPoint(room);
    });
});
contextHandler.setHandler(webSocketHandler);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-fastcgi"><a class="anchor" href="#pg-server-fastcgi"></a><a class="link" href="#pg-server-fastcgi">FastCGI Server Libraries</a></h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="pg-server-io-arch"><a class="anchor" href="#pg-server-io-arch"></a><a class="link" href="#pg-server-io-arch">Server I/O Architecture</a></h3>
<div class="paragraph">
<p>The Jetty server libraries provide the basic components and APIs to implement a network server.</p>
</div>
<div class="paragraph">
<p>They build on the common <a href="#pg-arch-io">Jetty I/O Architecture</a> and provide server specific concepts.</p>
</div>
<div class="paragraph">
<p>The Jetty server libraries provide I/O support for TCP/IP sockets (for both IPv4 and IPv6) and, when using Java 16 or later, for Unix-Domain sockets.</p>
</div>
<div class="paragraph">
<p>Support for Unix-Domain sockets is interesting when Jetty is deployed behind a proxy or a load-balancer: it is possible to configure the proxy or load balancer to communicate with Jetty via Unix-Domain sockets, rather than via the loopback network interface.</p>
</div>
<div class="paragraph">
<p>The central I/O server-side component are <code>org.eclipse.jetty.server.ServerConnector</code>, that handles the TCP/IP socket traffic, and <code>org.eclipse.jetty.unixdomain.server.UnixDomainServerConnector</code>, that handles the Unix-Domain socket traffic.</p>
</div>
<div class="paragraph">
<p><code>ServerConnector</code> and <code>UnixDomainServerConnector</code> are very similar, and while in the following sections <code>ServerConnector</code> is used, the same concepts apply to <code>UnixDomainServerConnector</code>, unless otherwise noted.</p>
</div>
<div class="paragraph">
<p>A <code>ServerConnector</code> manages a list of <code>ConnectionFactory</code>s, that indicate what protocols the connector is able to speak.</p>
</div>
<div class="sect3">
<h4 id="pg-server-io-arch-connection-factory"><a class="anchor" href="#pg-server-io-arch-connection-factory"></a><a class="link" href="#pg-server-io-arch-connection-factory">Creating Connections with <code>ConnectionFactory</code></a></h4>
<div class="paragraph">
<p>Recall from the <a href="#pg-arch-io-connection"><code>Connection</code> section</a> of the Jetty I/O architecture that <code>Connection</code> instances are responsible for parsing bytes read from a socket and generating bytes to write to that socket.</p>
</div>
<div class="paragraph">
<p>On the server-side, a <code>ConnectionFactory</code> creates <code>Connection</code> instances that know how to parse and generate bytes for the specific protocol they support&#8201;&#8212;&#8201;it can be either HTTP/1.1, or TLS, or FastCGI, or the <a href="https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt">PROXY protocol</a>.</p>
</div>
<div class="paragraph">
<p>For example, this is how clear-text HTTP/1.1 is configured for TCP/IP sockets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create the HTTP/1.1 ConnectionFactory.</span>
HttpConnectionFactory http = <span class="keyword">new</span> HttpConnectionFactory();

Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create the connector with the ConnectionFactory.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, http);
connector.setPort(<span class="integer">8080</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this configuration, the <code>ServerConnector</code> will listen on port <code>8080</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, this is how clear-text HTTP/1.1 is configured for Unix-Domain sockets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create the HTTP/1.1 ConnectionFactory.</span>
HttpConnectionFactory http = <span class="keyword">new</span> HttpConnectionFactory();

Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create the connector with the ConnectionFactory.</span>
UnixDomainServerConnector connector = <span class="keyword">new</span> UnixDomainServerConnector(server, http);
connector.setUnixDomainPath(Path.of(<span class="string"><span class="delimiter">&quot;</span><span class="content">/tmp/jetty.sock</span><span class="delimiter">&quot;</span></span>));

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this configuration, the <code>UnixDomainServerConnector</code> will listen on file <code>/tmp/jetty.sock</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ServerConnector</code> and <code>UnixDomainServerConnector</code> only differ by how they are configured&#8201;&#8212;&#8201;for <code>ServerConnector</code> you specify the IP port it listens to, for <code>UnixDomainServerConnector</code> you specify the Unix-Domain path it listens to.</p>
</div>
<div class="paragraph">
<p>Both configure <code>ConnectionFactory</code>s in exactly the same way.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a new socket connection is established, <code>ServerConnector</code> delegates to the <code>ConnectionFactory</code> the creation of the <code>Connection</code> instance for that socket connection, that is linked to the corresponding <code>EndPoint</code>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-d8ecf025f2e851a45b4d2132df024ecb.png" alt="Diagram" width="763" height="101">
</div>
</div>
<div class="paragraph">
<p>For every socket connection there will be an <code>EndPoint</code> + <code>Connection</code> pair.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-io-arch-connection-factory-wrapping"><a class="anchor" href="#pg-server-io-arch-connection-factory-wrapping"></a><a class="link" href="#pg-server-io-arch-connection-factory-wrapping">Wrapping a <code>ConnectionFactory</code></a></h4>
<div class="paragraph">
<p>A <code>ConnectionFactory</code> may wrap another <code>ConnectionFactory</code>; for example, the TLS protocol provides encryption for any other protocol.
Therefore, to support encrypted HTTP/1.1 (also known as <code>https</code>), you need to configure the <code>ServerConnector</code> with two <code>ConnectionFactory</code>s&#8201;&#8212;&#8201;one for the TLS protocol and one for the HTTP/1.1 protocol, like in the example below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create the HTTP/1.1 ConnectionFactory.</span>
HttpConnectionFactory http = <span class="keyword">new</span> HttpConnectionFactory();

<span class="comment">// Create and configure the TLS context factory.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore.p12</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create the TLS ConnectionFactory,</span>
<span class="comment">// setting HTTP/1.1 as the wrapped protocol.</span>
SslConnectionFactory tls = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, http.getProtocol());

Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create the connector with both ConnectionFactories.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, tls, http);
connector.setPort(<span class="integer">8443</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this configuration, the <code>ServerConnector</code> will listen on port <code>8443</code>.
When a new socket connection is established, the first <code>ConnectionFactory</code> configured in <code>ServerConnector</code> is invoked to create a <code>Connection</code>.
In the example above, <code>SslConnectionFactory</code> creates a <code>SslConnection</code> and then asks to its wrapped <code>ConnectionFactory</code> (in the example, <code>HttpConnectionFactory</code>) to create the wrapped <code>Connection</code> (an <code>HttpConnection</code>) and will then link the two <code>Connection</code>s together, in this way:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-a895f6364296eee265530e1d9fa7bed2.png" alt="Diagram" width="978" height="245">
</div>
</div>
<div class="paragraph">
<p>Bytes read by the <code>SocketChannelEndPoint</code> will be interpreted as TLS bytes by the <code>SslConnection</code>, then decrypted and made available to the <code>SslEndPoint</code> (a component part of <code>SslConnection</code>), which will then provide them to <code>HttpConnection</code>.</p>
</div>
<div class="paragraph">
<p>The application writes bytes through the <code>HttpConnection</code> to the <code>SslEndPoint</code>, which will encrypt them through the <code>SslConnection</code> and write the encrypted bytes to the <code>SocketChannelEndPoint</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-io-arch-connection-factory-detecting"><a class="anchor" href="#pg-server-io-arch-connection-factory-detecting"></a><a class="link" href="#pg-server-io-arch-connection-factory-detecting">Choosing <code>ConnectionFactory</code> via Bytes Detection</a></h4>
<div class="paragraph">
<p>Typically, a network port is associated with a specific protocol.
For example, port <code>80</code> is associated with clear-text HTTP, while port <code>443</code> is associated with encrypted HTTP (that is, the TLS protocol wrapping the HTTP protocol, also known as <code>https</code>).</p>
</div>
<div class="paragraph">
<p>In certain cases, applications need to listen to the same port for two or more protocols, or for different but incompatible versions of the same protocol, which can only be distinguished by reading the initial bytes and figuring out to what protocol they belong to.</p>
</div>
<div class="paragraph">
<p>The Jetty server libraries support this case by placing a <code>DetectorConnectionFactory</code> in front of other <code>ConnectionFactory</code>s.
<code>DetectorConnectionFactory</code> accepts a list of <code>ConnectionFactory</code>s that implement <code>ConnectionFactory.Detecting</code>, which will be called to see if one of them recognizes the initial bytes.</p>
</div>
<div class="paragraph">
<p>In the example below you can see how to support both clear-text and encrypted HTTP/1.1 (i.e. both <code>http</code> and <code>https</code>) <em>on the same network port</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Create the HTTP/1.1 ConnectionFactory.</span>
HttpConnectionFactory http = <span class="keyword">new</span> HttpConnectionFactory();

<span class="comment">// Create and configure the TLS context factory.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore.p12</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Create the TLS ConnectionFactory,</span>
<span class="comment">// setting HTTP/1.1 as the wrapped protocol.</span>
SslConnectionFactory tls = <span class="keyword">new</span> SslConnectionFactory(sslContextFactory, http.getProtocol());

Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create the detector ConnectionFactory to</span>
<span class="comment">// detect whether the initial bytes are TLS.</span>
DetectorConnectionFactory tlsDetector = <span class="keyword">new</span> DetectorConnectionFactory(tls); <i class="conum" data-value="1"></i><b>(1)</b>

<span class="comment">// Create the connector with both ConnectionFactories.</span>
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, tlsDetector, http); <i class="conum" data-value="2"></i><b>(2)</b>
connector.setPort(<span class="integer">8181</span>);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Creates the <code>DetectorConnectionFactory</code> with the <code>SslConnectionFactory</code> as the only detecting <code>ConnectionFactory</code>.
With this configuration, the detector will delegate to <code>SslConnectionFactory</code> to recognize the initial bytes, which will detect whether the bytes are TLS protocol bytes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Creates the <code>ServerConnector</code> with <code>DetectorConnectionFactory</code> as the first <code>ConnectionFactory</code>, and <code>HttpConnectionFactory</code> as the next <code>ConnectionFactory</code> to invoke if the detection fails.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the example above <code>ServerConnector</code> will listen on port 8181.
When a new socket connection is established, <code>DetectorConnectionFactory</code> is invoked to create a <code>Connection</code>, because it is the first <code>ConnectionFactory</code> specified in the <code>ServerConnector</code> list.
<code>DetectorConnectionFactory</code> reads the initial bytes and asks to its detecting <code>ConnectionFactory</code>s if they recognize the bytes.
In the example above, the detecting <code>ConnectionFactory</code> is <code>SslConnectionFactory</code> which will therefore detect whether the initial bytes are TLS bytes.
If one of the detecting <code>ConnectionFactory</code>s recognizes the bytes, it creates a <code>Connection</code>; otherwise <code>DetectorConnectionFactory</code> will try the next <code>ConnectionFactory</code> after itself in the <code>ServerConnector</code> list.
In the example above, the next <code>ConnectionFactory</code> after <code>DetectorConnectionFactory</code> is <code>HttpConnectionFactory</code>.</p>
</div>
<div class="paragraph">
<p>The final result is that when new socket connection is established, the initial bytes are examined: if they are TLS bytes, a <code>SslConnectionFactory</code> will create a <code>SslConnection</code> that wraps an <code>HttpConnection</code> as explained <a href="#pg-server-io-arch-connection-factory-wrapping">here</a>, therefore supporting <code>https</code>; otherwise they are not TLS bytes and an <code>HttpConnection</code> is created, therefore supporting <code>http</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-server-io-arch-connection-factory-custom"><a class="anchor" href="#pg-server-io-arch-connection-factory-custom"></a><a class="link" href="#pg-server-io-arch-connection-factory-custom">Writing a Custom <code>ConnectionFactory</code></a></h4>
<div class="paragraph">
<p>This section explains how to use the Jetty server-side libraries to write a generic network server able to parse and generate any protocol..</p>
</div>
<div class="paragraph">
<p>Let&#8217;s suppose that we want to write a custom protocol that is based on JSON but has the same semantic as HTTP; let&#8217;s call this custom protocol <code>JSONHTTP</code>, so that a request would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="json">{
  <span class="key"><span class="delimiter">&quot;</span><span class="content">type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">request</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">method</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">GET</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">version</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">HTTP/1.1</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">uri</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">http://localhost/path</span><span class="delimiter">&quot;</span></span>,
  <span class="key"><span class="delimiter">&quot;</span><span class="content">fields</span><span class="delimiter">&quot;</span></span>: {
    <span class="key"><span class="delimiter">&quot;</span><span class="content">content-type</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain;charset=ASCII</span><span class="delimiter">&quot;</span></span>
  },
  <span class="key"><span class="delimiter">&quot;</span><span class="content">content</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">HELLO</span><span class="delimiter">&quot;</span></span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In order to implement this custom protocol, we need to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>implement a <code>JSONHTTPConnectionFactory</code></p>
</li>
<li>
<p>implement a <code>JSONHTTPConnection</code></p>
</li>
<li>
<p>parse bytes and generate bytes in the <code>JSONHTTP</code> format</p>
</li>
<li>
<p>design an easy to use API that applications use to process requests and respond</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>First, the <code>JSONHTTPConnectionFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">JSONHTTPConnectionFactory</span> <span class="directive">extends</span> AbstractConnectionFactory
{
    <span class="directive">public</span> JSONHTTPConnectionFactory()
    {
        <span class="local-variable">super</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">JSONHTTP</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Connection</span> newConnection(Connector connector, EndPoint endPoint)
    {
        JSONHTTPConnection connection = <span class="keyword">new</span> JSONHTTPConnection(endPoint, connector.getExecutor());
        <span class="comment">// Call configure() to apply configurations common to all connections.</span>
        <span class="keyword">return</span> configure(connection, connector, endPoint);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how <code>JSONHTTPConnectionFactory</code> extends <code>AbstractConnectionFactory</code> to inherit facilities common to all <code>ConnectionFactory</code> implementations.</p>
</div>
<div class="paragraph">
<p>Second, the <code>JSONHTTPConnection</code>.
Recall from the <a href="#pg-arch-io-echo">echo <code>Connection</code> example</a> that you need to override <code>onOpen()</code> to call <code>fillInterested()</code> so that the Jetty I/O system will notify your <code>Connection</code> implementation when there are bytes to read by calling <code>onFillable()</code>.
Furthermore, because the Jetty libraries are non-blocking and asynchronous, you need to use <code>IteratingCallback</code> to implement <code>onFillable()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">JSONHTTPConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="comment">// The asynchronous JSON parser.</span>
    <span class="directive">private</span> <span class="directive">final</span> AsyncJSON parser = <span class="keyword">new</span> AsyncJSON.Factory().newAsyncJSON();
    <span class="directive">private</span> <span class="directive">final</span> IteratingCallback callback = <span class="keyword">new</span> JSONHTTPIteratingCallback();

    <span class="directive">public</span> JSONHTTPConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest in being called back when</span>
        <span class="comment">// there are bytes to read from the network.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        callback.iterate();
    }

    <span class="directive">private</span> <span class="type">class</span> <span class="class">JSONHTTPIteratingCallback</span> <span class="directive">extends</span> IteratingCallback
    {
        <span class="directive">private</span> <span class="predefined-type">ByteBuffer</span> buffer;

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="predefined-type">Action</span> process() <span class="directive">throws</span> <span class="predefined-type">Throwable</span>
        {
            <span class="keyword">if</span> (buffer == <span class="predefined-constant">null</span>)
                buffer = BufferUtil.allocate(getInputBufferSize(), <span class="predefined-constant">true</span>);

            <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
            {
                <span class="type">int</span> filled = getEndPoint().fill(buffer);
                <span class="keyword">if</span> (filled &gt; <span class="integer">0</span>)
                {
                    <span class="type">boolean</span> parsed = parser.parse(buffer);
                    <span class="keyword">if</span> (parsed)
                    {
                        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; request = parser.complete();

                        <span class="comment">// Allow applications to process the request.</span>
                        invokeApplication(request, <span class="local-variable">this</span>);

                        <span class="comment">// Signal that the iteration should resume when</span>
                        <span class="comment">// the application completed the request processing.</span>
                        <span class="keyword">return</span> <span class="predefined-type">Action</span>.SCHEDULED;
                    }
                    <span class="keyword">else</span>
                    {
                        <span class="comment">// Did not receive enough JSON bytes,</span>
                        <span class="comment">// loop around to try to read more.</span>
                    }
                }
                <span class="keyword">else</span> <span class="keyword">if</span> (filled == <span class="integer">0</span>)
                {
                    <span class="comment">// We don't need the buffer anymore, so</span>
                    <span class="comment">// don't keep it around while we are idle.</span>
                    buffer = <span class="predefined-constant">null</span>;

                    <span class="comment">// No more bytes to read, declare</span>
                    <span class="comment">// again interest for fill events.</span>
                    fillInterested();

                    <span class="comment">// Signal that the iteration is now IDLE.</span>
                    <span class="keyword">return</span> <span class="predefined-type">Action</span>.IDLE;
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">// The other peer closed the connection,</span>
                    <span class="comment">// the iteration completed successfully.</span>
                    <span class="keyword">return</span> <span class="predefined-type">Action</span>.SUCCEEDED;
                }
            }
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteSuccess()
        {
            getEndPoint().close();
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteFailure(<span class="predefined-type">Throwable</span> cause)
        {
            getEndPoint().close(cause);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, note how <code>JSONHTTPConnection</code> extends <code>AbstractConnection</code> to inherit facilities that you would otherwise need to re-implement from scratch.</p>
</div>
<div class="paragraph">
<p>When <code>JSONHTTPConnection</code> receives a full JSON object it calls <code>invokeApplication(&#8230;&#8203;)</code> to allow the application to process the incoming request and produce a response.</p>
</div>
<div class="paragraph">
<p>At this point you need to design a non-blocking asynchronous API that takes a <code>Callback</code> parameter so that applications can signal to the implementation when the request processing is complete (either successfully or with a failure).</p>
</div>
<div class="paragraph">
<p>A simple example of this API design could be the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wrap the JSON <code>Map</code> into a <code>JSONHTTPRequest</code> parameter so that applications may use more specific HTTP APIs such as <code>JSONHTTPRequest.getMethod()</code> rather than a generic <code>Map.get("method")</code></p>
</li>
<li>
<p>Provide an equivalent <code>JSONHTTPResponse</code> parameter so that applications may use more specific APIs such as <code>JSONHTTPResponse.setStatus(int)</code> rather than a generic <code>Map.put("status", 200)</code></p>
</li>
<li>
<p>Provide a <code>Callback</code> (or a <code>CompletableFuture</code>) parameter so that applications may indicate when the request processing is complete</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This results in the following API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">JSONHTTPRequest</span>
{
    <span class="comment">// Request APIs</span>
}

<span class="type">class</span> <span class="class">JSONHTTPResponse</span>
{
    <span class="comment">// Response APIs</span>
}

<span class="type">interface</span> <span class="class">JSONHTTPService</span>
{
    <span class="type">void</span> service(JSONHTTPRequest request, JSONHTTPResponse response, <span class="predefined-type">Callback</span> callback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The important part of this simple API example is the <code>Callback</code> parameter that makes the API non-blocking and asynchronous.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="maven-and-jetty"><a class="anchor" href="#maven-and-jetty"></a><a class="link" href="#maven-and-jetty">Maven and Jetty</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jetty-maven-helloworld"><a class="anchor" href="#jetty-maven-helloworld"></a><a class="link" href="#jetty-maven-helloworld">Using Maven</a></h3>
<div class="paragraph">
<p><a href="http://maven.apache.org/">Apache Maven</a> is a software project management and comprehension tool.
Based on the concept of a project object model (POM), Maven can manage a project&#8217;s build, reporting and documentation from a central piece of information.</p>
</div>
<div class="paragraph">
<p>It is an ideal tool to build a web application project, and such projects can use the <a href="#jetty-maven-plugin">jetty-maven-plugin</a> to easily run the web application and save time in development.
You can also use Maven to build, test and run a project which embeds Jetty.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Use of Maven and the jetty-maven-plugin is <strong>not</strong> required.
Using Maven for Jetty implementations is a popular choice, but users encouraged to manage their projects in whatever way suits their needs.
Other popular tools include Ant and Gradle.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="configuring-embedded-jetty-with-maven"><a class="anchor" href="#configuring-embedded-jetty-with-maven"></a><a class="link" href="#configuring-embedded-jetty-with-maven">Using Embedded Jetty with Maven</a></h4>
<div class="paragraph">
<p>Maven uses convention over configuration, so it is best to use the project structure Maven recommends.
You can use <em><a href="#archetypes"><a href="http://maven.apache.org/guides/introduction/introduction-to-archetypes.html">archetypes</a></a></em> to quickly setup Maven projects, but we will set up the structure manually for this simple tutorial example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mkdir JettyMavenHelloWorld
&gt; cd JettyMavenHelloWorld
&gt; mkdir -p src/main/java/org/example</pre>
</div>
</div>
<div class="sect4">
<h5 id="creating-helloworld-class"><a class="anchor" href="#creating-helloworld-class"></a><a class="link" href="#creating-helloworld-class">Creating the HelloWorld Class</a></h5>
<div class="paragraph">
<p>Use an editor to create the file <code>src/main/java/org/example/HelloWorld.java</code> with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.example</span>;

<span class="keyword">import</span> <span class="include">jakarta.servlet.http.HttpServletRequest</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.http.HttpServletResponse</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.ServletException</span>;
<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">org.eclipse.jetty.server.Server</span>;
<span class="keyword">import</span> <span class="include">org.eclipse.jetty.server.Request</span>;
<span class="keyword">import</span> <span class="include">org.eclipse.jetty.server.handler.AbstractHandler</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">HelloWorld</span> <span class="directive">extends</span> AbstractHandler
{
    <span class="directive">public</span> <span class="type">void</span> handle(<span class="predefined-type">String</span> target,
                       Request baseRequest,
                       HttpServletRequest request,
                       HttpServletResponse response)
        <span class="directive">throws</span> <span class="exception">IOException</span>, ServletException
    {
        response.setContentType(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/html;charset=utf-8</span><span class="delimiter">&quot;</span></span>);
        response.setStatus(HttpServletResponse.SC_OK);
        baseRequest.setHandled(<span class="predefined-constant">true</span>);
        response.getWriter().println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;h1&gt;Hello World&lt;/h1&gt;</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">void</span> main(<span class="predefined-type">String</span><span class="type">[]</span> args) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        Server server = <span class="keyword">new</span> Server(<span class="integer">8080</span>);
        server.setHandler(<span class="keyword">new</span> HelloWorld());

        server.start();
        server.join();
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="creating-embedded-pom-descriptor"><a class="anchor" href="#creating-embedded-pom-descriptor"></a><a class="link" href="#creating-embedded-pom-descriptor">Creating the POM Descriptor</a></h5>
<div class="paragraph">
<p>The <code>pom.xml</code> file declares the project name and its dependencies.
Use an editor to create the file <code>pom.xml</code> in the <code>JettyMavenHelloWorld</code> directory with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;modelVersion&gt;</span>4.0.0<span class="tag">&lt;/modelVersion&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.example<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>hello-world<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;packaging&gt;</span>jar<span class="tag">&lt;/packaging&gt;</span>
  <span class="tag">&lt;name&gt;</span>Jetty HelloWorld<span class="tag">&lt;/name&gt;</span>

  <span class="tag">&lt;properties&gt;</span>
      <span class="tag">&lt;jettyVersion&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/jettyVersion&gt;</span>
  <span class="tag">&lt;/properties&gt;</span>

  <span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
      <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
      <span class="tag">&lt;artifactId&gt;</span>jetty-server<span class="tag">&lt;/artifactId&gt;</span>
      <span class="tag">&lt;version&gt;</span>${jettyVersion}<span class="tag">&lt;/version&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
  <span class="tag">&lt;/dependencies&gt;</span>

  <span class="tag">&lt;build&gt;</span>
    <span class="tag">&lt;plugins&gt;</span>
      <span class="tag">&lt;plugin&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.codehaus.mojo<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>exec-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>1.1<span class="tag">&lt;/version&gt;</span>
        <span class="tag">&lt;executions&gt;</span>
          <span class="tag">&lt;execution&gt;</span><span class="tag">&lt;goals&gt;</span><span class="tag">&lt;goal&gt;</span>java<span class="tag">&lt;/goal&gt;</span><span class="tag">&lt;/goals&gt;</span><span class="tag">&lt;/execution&gt;</span>
        <span class="tag">&lt;/executions&gt;</span>
        <span class="tag">&lt;configuration&gt;</span>
          <span class="tag">&lt;mainClass&gt;</span>org.example.HelloWorld<span class="tag">&lt;/mainClass&gt;</span>
        <span class="tag">&lt;/configuration&gt;</span>
      <span class="tag">&lt;/plugin&gt;</span>
    <span class="tag">&lt;/plugins&gt;</span>
  <span class="tag">&lt;/build&gt;</span>
<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="buildng-and-running-embedded-helloworld"><a class="anchor" href="#buildng-and-running-embedded-helloworld"></a><a class="link" href="#buildng-and-running-embedded-helloworld">Building and Running Embedded HelloWorld</a></h5>
<div class="paragraph">
<p>You can now compile and execute the HelloWorld class by using these commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mvn clean compile exec:java</pre>
</div>
</div>
<div class="paragraph">
<p>Point your browser to <code>http://localhost:8080</code> to see the <em>Hello World</em> page.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="developing-standard-webapp-with-jetty-and-maven"><a class="anchor" href="#developing-standard-webapp-with-jetty-and-maven"></a><a class="link" href="#developing-standard-webapp-with-jetty-and-maven">Developing a Standard WebApp with Jetty and Maven</a></h4>
<div class="paragraph">
<p>The previous section demonstrated how to use Maven with an application that embeds Jetty.
We can instead develop a standard webapp using Maven and Jetty.
First create the Maven structure (you can use the maven webapp archetype instead if you prefer):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mkdir JettyMavenHelloWarApp
&gt; cd JettyMavenHelloWebApp
&gt; mkdir -p src/main/java/org/example
&gt; mkdir -p src/main/webapp/WEB-INF</pre>
</div>
</div>
<div class="sect4">
<h5 id="creating-servlet"><a class="anchor" href="#creating-servlet"></a><a class="link" href="#creating-servlet">Creating a Servlet</a></h5>
<div class="paragraph">
<p>Use an editor to create the file <code>src/main/java/org/example/HelloServlet.java</code> with the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">package</span> <span class="namespace">org.example</span>;

<span class="keyword">import</span> <span class="include">java.io.IOException</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.ServletException</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.http.HttpServlet</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.http.HttpServletRequest</span>;
<span class="keyword">import</span> <span class="include">jakarta.servlet.http.HttpServletResponse</span>;

<span class="directive">public</span> <span class="type">class</span> <span class="class">HelloServlet</span> <span class="directive">extends</span> HttpServlet
{
    <span class="directive">protected</span> <span class="type">void</span> doGet(HttpServletRequest request, HttpServletResponse response) <span class="directive">throws</span> ServletException, <span class="exception">IOException</span>
    {
        response.setContentType(<span class="string"><span class="delimiter">&quot;</span><span class="content">text/html</span><span class="delimiter">&quot;</span></span>);
        response.setStatus(HttpServletResponse.SC_OK);
        response.getWriter().println(<span class="string"><span class="delimiter">&quot;</span><span class="content">&lt;h1&gt;Hello Servlet&lt;/h1&gt;</span><span class="delimiter">&quot;</span></span>);
        response.getWriter().println(<span class="string"><span class="delimiter">&quot;</span><span class="content">session=</span><span class="delimiter">&quot;</span></span> + request.getSession(<span class="predefined-constant">true</span>).getId());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This servlet must be declared in the web deployment descriptor, so create the file <code>src/main/webapp/WEB-INF/web.xml</code> and add the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="preprocessor">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="tag">&lt;web-app</span>
   <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">metadata-complete</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">false</span><span class="delimiter">&quot;</span></span>
   <span class="attribute-name">version</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">6.0</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;servlet&gt;</span>
    <span class="tag">&lt;servlet-name&gt;</span>Hello<span class="tag">&lt;/servlet-name&gt;</span>
    <span class="tag">&lt;servlet-class&gt;</span>org.example.HelloServlet<span class="tag">&lt;/servlet-class&gt;</span>
  <span class="tag">&lt;/servlet&gt;</span>
  <span class="tag">&lt;servlet-mapping&gt;</span>
    <span class="tag">&lt;servlet-name&gt;</span>Hello<span class="tag">&lt;/servlet-name&gt;</span>
    <span class="tag">&lt;url-pattern&gt;</span>/hello/*<span class="tag">&lt;/url-pattern&gt;</span>
  <span class="tag">&lt;/servlet-mapping&gt;</span>

<span class="tag">&lt;/web-app&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="creating-plugin-pom-descriptor"><a class="anchor" href="#creating-plugin-pom-descriptor"></a><a class="link" href="#creating-plugin-pom-descriptor">Creating the POM Descriptor</a></h5>
<div class="paragraph">
<p>The <code>pom.xml</code> file declares the project name and its dependencies.
Use an editor to create the file <code>pom.xml</code> with the following contents in the <code>JettyMavenHelloWarApp</code> directory, noting particularly the declaration of the <a href="#jetty-maven-plugin">jetty-maven-plugin</a> for the Jakarta EE 10 environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project</span> <span class="attribute-name">xmlns</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xmlns:xsi</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://www.w3.org/2001/XMLSchema-instance</span><span class="delimiter">&quot;</span></span>
         <span class="attribute-name">xsi:schemaLocation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>

  <span class="tag">&lt;modelVersion&gt;</span>4.0.0<span class="tag">&lt;/modelVersion&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.example<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>hello-world<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>0.1-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;packaging&gt;</span>war<span class="tag">&lt;/packaging&gt;</span>
  <span class="tag">&lt;name&gt;</span>Jetty HelloWorld WebApp<span class="tag">&lt;/name&gt;</span>

  <span class="tag">&lt;properties&gt;</span>
      <span class="tag">&lt;jettyVersion&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/jettyVersion&gt;</span>
  <span class="tag">&lt;/properties&gt;</span>

  <span class="tag">&lt;dependencies&gt;</span>
    <span class="tag">&lt;dependency&gt;</span>
      <span class="tag">&lt;groupId&gt;</span>jakarta.servlet<span class="tag">&lt;/groupId&gt;</span>
      <span class="tag">&lt;artifactId&gt;</span>jakarta.servlet-api<span class="tag">&lt;/artifactId&gt;</span>
      <span class="tag">&lt;version&gt;</span>6.0.0<span class="tag">&lt;/version&gt;</span>
      <span class="tag">&lt;scope&gt;</span>provided<span class="tag">&lt;/scope&gt;</span>
    <span class="tag">&lt;/dependency&gt;</span>
  <span class="tag">&lt;/dependencies&gt;</span>

  <span class="tag">&lt;build&gt;</span>
    <span class="tag">&lt;plugins&gt;</span>
      <span class="tag">&lt;plugin&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>${jettyVersion}<span class="tag">&lt;/version&gt;</span>
      <span class="tag">&lt;/plugin&gt;</span>
    <span class="tag">&lt;/plugins&gt;</span>
  <span class="tag">&lt;/build&gt;</span>

<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="building-and-running-web-application"><a class="anchor" href="#building-and-running-web-application"></a><a class="link" href="#building-and-running-web-application">Building and Running the Web Application</a></h5>
<div class="paragraph">
<p>The web application can now be built and run without first needing to assemble it into a war by using the <a href="#jetty-maven-plugin">jetty-maven-plugin</a> via the command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mvn jetty:run</pre>
</div>
</div>
<div class="paragraph">
<p>You can see the static and dynamic content at <code>http://localhost:8080/hello</code></p>
</div>
<div class="paragraph">
<p>There are a great deal of configuration options available for the jetty-maven-plugin to help you build and run your webapp.
The full reference is at <a href="#jetty-maven-plugin">Configuring the Jetty Maven Plugin</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="building-war-file"><a class="anchor" href="#building-war-file"></a><a class="link" href="#building-war-file">Building a WAR file</a></h5>
<div class="paragraph">
<p>A Web Application Archive (WAR) file can be produced from the project with the command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; mvn package</pre>
</div>
</div>
<div class="paragraph">
<p>The resulting war file is in the <code>target</code> directory and may be deployed on any standard servlet server, including <a href="#og-deploy">Jetty</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jetty-maven-plugin"><a class="anchor" href="#jetty-maven-plugin"></a><a class="link" href="#jetty-maven-plugin">Using the Jetty Maven Plugin</a></h3>
<div class="paragraph">
<p>The Jetty Maven plugin is useful for rapid development and testing.
It can optionally periodically scan a project for changes and automatically redeploy the webapp if any are found.
This makes the development cycle more productive by eliminating the build and deploy steps: use an IDE to make changes to the project, and the running web container automatically picks them up, allowing them to be tested straight away.</p>
</div>
<div class="paragraph">
<p>There are only 4 goals to run a webapp in Jetty:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jetty-run-goal">jetty:run</a></p>
</li>
<li>
<p><a href="#jetty-run-war-goal">jetty:run-war</a></p>
</li>
<li>
<p><a href="#jetty-start-goal">jetty:start</a></p>
</li>
<li>
<p><a href="#jetty-start-war-goal">jetty:start-war</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Plus two utility goals:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#jetty-stop-goal">jetty:stop</a></p>
</li>
<li>
<p><a href="#jetty-effective-web-xml-goal">jetty:effective-web-xml</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>jetty:run</code> and <code>jetty:start</code> are alike in that they both run an <em>unassembled</em> webapp in Jetty,however <code>jetty:run</code> is designed to be used at the command line, whereas <code>jetty:start</code> is specifically designed to be bound to execution phases in the build lifecycle.
<code>jetty:run</code> will pause Maven while jetty is running, echoing all output to the console, and then stop Maven when jetty exits.
<code>jetty:start</code> will not pause Maven, will write all its output to a file, and will not stop Maven when jetty exits.</p>
</div>
<div class="paragraph">
<p><code>jetty:run-war</code> and <code>jetty:start-war</code> are similar in that they both run an <em>assembled</em> war file in Jetty.
However, <code>jetty:run-war</code> is designed to be run at the command line, whereas <code>jetty:start-war</code> is specifically designed to be bound to execution phases in the build lifecycle.
<code>jetty:run-war</code> will pause Maven while Jetty is running, echoing all output to the console, and then stop Maven when Jetty exits.
<code>jetty:start-war</code> will not pause Maven, will write all its output to a file, and will not stop Maven when Jetty exits.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>While the Jetty Maven Plugin can be very useful for development we do not recommend its use in a <em>production capacity</em>.
In order for the plugin to work it needs to leverage many internal Maven APIs and Maven itself it not a production deployment tool.
We recommend either the traditional xrefr:og-deploy[distribution] deployment approach or using <a href="#og-arch">embedded Jetty</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="get-up-and-running"><a class="anchor" href="#get-up-and-running"></a><a class="link" href="#get-up-and-running">Get Up and Running</a></h4>
<div class="paragraph">
<p>Since Jetty 12, Jetty Maven plugin is repackaged for the corresponding Jakarta EE version with an <code>eeX</code> classifier in the groupId and artifactId.</p>
</div>
<div class="paragraph">
<p>First, add <code>jetty-ee{8,9,10}-maven-plugin</code> to your <code>pom.xml</code> definition. Here&#8217;s an example of how to do that for Jakarta EE 10:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, from the same directory as the project&#8217;s root <code>pom.xml</code>, type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mvn jetty:run</pre>
</div>
</div>
<div class="paragraph">
<p>This starts Jetty and serves up the project on <code>http://localhost:8080/</code>.</p>
</div>
<div class="paragraph">
<p>Jetty will continue to run until you stop it.
By default, it will not automatically restart your webapp.
Set a non-zero <code>&lt;scan&gt;</code> value to have Jetty scan your webapp for changes and automatically redeploy, or set <code>&lt;scan&gt;</code> to <code>0</code> to cause manual redeployment by hitting the <kbd>Enter</kbd> key.</p>
</div>
<div class="paragraph">
<p>Terminate the plugin with a <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>c</kbd></span> in the terminal window where it is running.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The classpath of the running Jetty instance and its deployed webapp are managed by Maven, and may not be exactly what you expect.
For example: a webapp&#8217;s dependent jars might be referenced via the local repository, or other projects in the reactor, not the <code>WEB-INF/lib</code> directory.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="supported-goals"><a class="anchor" href="#supported-goals"></a><a class="link" href="#supported-goals">Supported Goals</a></h4>
<div class="paragraph">
<p>The goals prefixed with <code>"run-"</code> are designed to be used at the <em>command line</em>.
They first run a Maven build on your project to ensure at least the classes are all built.
They then start Jetty and pause the Maven build process until Jetty is manually terminated, at which time the build will also be terminated.
Jetty can scan various files in your project for changes and redeploy the webapp as necessary, or you can choose to manually trigger a redeploy if you prefer.
All output from Jetty is echoed to the console.</p>
</div>
<div class="paragraph">
<p>The goals prefixed with <code>"start-"</code> are designed to be used with <em>build lifecycle bindings in the pom</em>, and <em>not</em> at the command line.
No part of your project will be rebuilt by invoking these goals - you should ensure that your bind the execution to a build phase where all necessary parts of your project have been built.
Maven will start and terminate Jetty at the appropriate points in the build lifecycle, continuing with the build.
Jetty will <em>not</em> scan any files in your project for changes, and your webapp will <em>not</em> be redeployed either automatically or manually.
Output from Jetty is directed to a file in the <code>target</code> directory.</p>
</div>
<div class="paragraph">
<p>To see a list of all goals supported by the Jetty Maven plugin, do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mvn jetty:help</pre>
</div>
</div>
<div class="paragraph">
<p>To see the detailed list of parameters that can be configured for a particular goal, in addition to its description, do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mvn jetty:help -Ddetail=true -Dgoal=&lt;goalName&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="deployment-modes"><a class="anchor" href="#deployment-modes"></a><a class="link" href="#deployment-modes">Deployment Modes</a></h4>
<div class="paragraph">
<p>All of the <code>"run-"</code> and <code>"start-"</code> goals can deploy your webapp either into the running maven process, or forked into a new child process, or forked into a Jetty distribution on disk.</p>
</div>
<div class="paragraph">
<p>This is controlled by setting the <code>deployMode</code> configuration parameter in the pom, but can also be set by defining the Maven property 'jetty.deployMode'.</p>
</div>
<div class="sect4">
<h5 id="pg-embedded"><a class="anchor" href="#pg-embedded"></a><a class="link" href="#pg-embedded">Embedded</a></h5>
<div class="paragraph">
<p><code>deployMode</code> of <code>EMBED</code>.
This is the "classic" Jetty Maven plugin deployment mode, running in-process with Maven.
This is the <em>default</em> mode.</p>
</div>
<div class="paragraph">
<p>These extra configuration parameters are available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">httpConnector</dt>
<dd>
<p>Optional.
Note that to configure a https connector, you will need to use xml configuration files instead, setting the <code>jettyXmls</code> parameter.
This parameter can only be used to configure a standard http connector.
If not specified, Jetty will create a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ServerConnector.html">ServerConnector</a> instance listening on port 8080.
You can change this default port number by using the system property <code>jetty.http.port</code> on the command line, for example, <code>mvn -Djetty.http.port=9999 jetty:run</code>.
Alternatively, you can use this configuration element to set up the information for the ServerConnector.
The following are the valid configuration sub-elements:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">port</dt>
<dd>
<p>The port number for the connector to listen on.
By default it is 8080.</p>
</dd>
<dt class="hdlist1">host</dt>
<dd>
<p>The particular interface for the connector to listen on.
By default, all interfaces.</p>
</dd>
<dt class="hdlist1">name</dt>
<dd>
<p>The name of the connector, which is useful for configuring contexts to respond only on particular connectors.</p>
</dd>
<dt class="hdlist1">idleTimeout</dt>
<dd>
<p>Maximum idle time for a connection.
You could instead configure the connectors in a standard <a href="#og-xml">jetty xml config file</a> and put its location into the <code>jettyXml</code> parameter.
Note that since Jetty 9.0 it is no longer possible to configure a https connector directly in the pom.xml: you need to use jetty xml config files to do it.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">loginServices</dt>
<dd>
<p>Optional.
A list of <code>org.eclipse.jetty.security.LoginService</code> implementations. Note that there is no default realm.
If you use a realm in your <code>web.xml</code> you can specify a corresponding realm here.
You could instead configure the login services in a jetty xml file and add its location to the <code>jettyXml</code> parameter.
See <a href="#configuring-security-settings">Configuring Security</a>.</p>
</dd>
<dt class="hdlist1">requestLog</dt>
<dd>
<p>Optional.
An implementation of the <code>org.eclipse.jetty.server.RequestLog</code> request log interface.
There are three other ways to configure the <code>RequestLog</code>:</p>
<div class="ulist">
<ul>
<li>
<p>In a Jetty xml config file, as specified in the <code>jettyXml</code> parameter.</p>
</li>
<li>
<p>In a context xml config file, as specified in the <code>contextXml</code> parameter.</p>
</li>
<li>
<p>In the <code>webApp</code> element.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="#pg-server-http-request-logging">Configuring Request Logs</a> for more information.</p>
</div>
</dd>
<dt class="hdlist1">server</dt>
<dd>
<p>Optional as of Jetty 9.3.1.
This would configure an instance of <code>org.eclipse.jetty.server.Server</code> for the plugin to use, however it is usually <em>not</em> necessary to configure this, as the plugin will automatically configure one for you.
In particular, if you use the <code>jettyXmls</code> element, then you generally <em>don&#8217;t</em> want to define this element, as you are probably using the <code>jettyXmls</code> file/s to configure up a Server with a special constructor argument, such as a custom threadpool.
If you define both a <code>server</code> element and use a <code>jettyXmls</code> element which points to a config file that has a line like <code>&lt;Configure id="Server" class="org.eclipse.jetty.server.Server"&gt;</code> then the the xml configuration will override what you configure for the <code>server</code> in the <code>pom.xml</code>.</p>
</dd>
<dt class="hdlist1">useProvidedScope</dt>
<dd>
<p>Default value is <code>false</code>.
If true, the dependencies with <code>&lt;scope&gt;provided&lt;/scope&gt;</code> are placed onto the <em>container classpath</em>.
Be aware that this is <em>not</em> the webapp classpath, as <code>provided</code> indicates that these dependencies would normally be expected to be provided by the container.
You should very rarely ever need to use this.
See <a href="#container-classpath">Container Classpath vs WebApp Classpath</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="pg-forked"><a class="anchor" href="#pg-forked"></a><a class="link" href="#pg-forked">Forked</a></h5>
<div class="paragraph">
<p><code>deployMode</code> of <code>FORK</code>.
This is similar to the old "jetty:run-forked" goal - a separate process is forked to run your webapp embedded into jetty.
These extra configuration parameters are available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">env</dt>
<dd>
<p>Optional.
Map of key/value pairs to pass as environment to the forked JVM.</p>
</dd>
<dt class="hdlist1">jvmArgs</dt>
<dd>
<p>Optional.
A space separated string representing arbitrary arguments to pass to the forked JVM.</p>
</dd>
<dt class="hdlist1">forkWebXml</dt>
<dd>
<p>Optional.
Defaults to <code>target/fork-web.xml</code>.
This is the location of a quickstart web xml file that will be <em>generated</em> during the forking of the jetty process.
You should not need to set this parameter, but it is available if you wish to control the name and location of that file.</p>
</dd>
<dt class="hdlist1">useProvidedScope</dt>
<dd>
<p>Default value is <code>false</code>.
If true, the dependencies with <code>&lt;scope&gt;provided&lt;/scope&gt;</code> are placed onto the <em>container classpath</em>.
Be aware that this is NOT the webapp classpath, as "provided" indicates that these dependencies would normally be expected to be provided by the container.
You should very rarely ever need to use this.
See <a href="#container-classpath">Container Classpath vs WebApp Classpath</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="pg-in-a-jetty-distribution"><a class="anchor" href="#pg-in-a-jetty-distribution"></a><a class="link" href="#pg-in-a-jetty-distribution">In a jetty distribution</a></h5>
<div class="paragraph">
<p><code>deployMode</code> of <code>EXTERNAL</code>.
This is similar to the old "jetty:run-distro" goal - your webapp is deployed into a dynamically downloaded, unpacked and configured Jetty distribution.
A separate process is forked to run it.
These extra configuration parameters are available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">jettyBase</dt>
<dd>
<p>Optional.
The location of an existing Jetty base directory to use to deploy the webapp.
The existing base will be copied to the <code>target/</code> directory before the webapp is deployed.
If there is no existing jetty base, a fresh one will be made in <code>target/jetty-base</code>.</p>
</dd>
<dt class="hdlist1">jettyHome</dt>
<dd>
<p>Optional.
The location of an existing unpacked Jetty distribution.
If one does not exist, a fresh Jetty distribution will be downloaded from Maven and installed to the <code>target</code> directory.</p>
</dd>
<dt class="hdlist1">jettyOptions</dt>
<dd>
<p>Optional.
A space separated string representing extra arguments to the synthesized Jetty command line.
Values for these arguments can be found in the section titled "Options" in the output of <code>java -jar $jetty.home/start.jar --help</code>.</p>
</dd>
<dt class="hdlist1">jvmArgs</dt>
<dd>
<p>Optional.
A space separated string representing arguments that should be passed to the jvm of the child process running the distro.</p>
</dd>
<dt class="hdlist1">modules</dt>
<dd>
<p>Optional.
An array of names of additional Jetty modules that the Jetty child process will activate.
Use this to change the <a href="#container-classpath">container classpath</a> instead of <code>useProvidedScope</code>.
These modules are enabled by default: <code>server,http,webapp,deploy</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="common-configuration"><a class="anchor" href="#common-configuration"></a><a class="link" href="#common-configuration">Common Configuration</a></h4>
<div class="paragraph">
<p>The following configuration parameters are common to all of the <code>"run-"</code> and <code>"start-"</code> goals:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">deployMode</dt>
<dd>
<p>One of <code>EMBED</code>, <code>FORK</code> or <code>EXTERNAL</code>.
Default <code>EMBED</code>.
Can also be configured by setting the Maven property <code>jetty.deployMode</code>.
This parameter determines whether the webapp will run in Jetty in-process with Maven, forked into a new process, or deployed into a Jetty distribution.
See <a href="#deployment-modes">Deployment Modes</a>.</p>
</dd>
<dt class="hdlist1">jettyXmls</dt>
<dd>
<p>Optional.
A comma separated list of locations of Jetty xml files to apply in addition to any plugin configuration parameters.
You might use it if you have other webapps, handlers, specific types of connectors etc., to deploy, or if you have other Jetty objects that you cannot configure from the plugin.</p>
</dd>
<dt class="hdlist1">skip</dt>
<dd>
<p>Default is false.
If true, the execution of the plugin exits.
Same as setting the SystemProperty <code>-Djetty.skip</code> on the command line.
This is most useful when configuring Jetty for execution during integration testing and you want to skip the tests.</p>
</dd>
<dt class="hdlist1">excludedGoals</dt>
<dd>
<p>Optional.
A list of Jetty plugin goal names that will cause the plugin to print an informative message and exit.
Useful if you want to prevent users from executing goals that you know cannot work with your project.</p>
</dd>
<dt class="hdlist1">supportedPackagings</dt>
<dd>
<p>Optional.
Defaults to <code>war</code>.
This is a list of maven &lt;packaging&gt; types that can work with the jetty plugin.
Usually, only <code>war</code> projects are suitable, however, you may configure other types.
The plugin will refuse to start if the &lt;packaging&gt; type in the pom is not in list of <code>supportedPackagings</code>.</p>
</dd>
<dt class="hdlist1">systemProperties</dt>
<dd>
<p>Optional.
Allows you to configure System properties for the execution of the plugin.
For more information, see <a href="#setting-system-properties">Setting System Properties</a>.</p>
</dd>
<dt class="hdlist1">systemPropertiesFile</dt>
<dd>
<p>Optional.
A file containing System properties to set for the execution of the plugin.
By default, settings that you make here <strong>do not</strong> override any system properties already set on the command line, by the JVM, or in the POM via <code>systemProperties</code>.
Read <a href="#setting-system-properties">Setting System Properties</a> for how to force overrides.</p>
</dd>
<dt class="hdlist1">jettyProperties</dt>
<dd>
<p>Optional.
A map of property name, value pairs.
Allows you to configure standard jetty properties.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="container-classpath"><a class="anchor" href="#container-classpath"></a><a class="link" href="#container-classpath">Container Classpath vs WebApp Classpath</a></h4>
<div class="paragraph">
<p>The Servlet Specification makes a strong distinction between the classpath for a <em>webapp</em>, and the classpath of the <em>container</em>.
When running in Maven, the plugin&#8217;s classpath is equivalent to the <em>container</em> classpath.
It will make a classpath for the <em>webapp</em> to be deployed comprised of &lt;dependencies&gt; specified in the pom.</p>
</div>
<div class="paragraph">
<p>If your production environment places specific jars onto the container&#8217;s classpath, the equivalent way to do this with Maven is to define these as &lt;dependencies&gt; for the <em>plugin</em> itself, not the <em>project</em>. See <a href="http://maven.apache.org/pom.html#Plugins">configuring maven plugins</a>.
This is suitable if you are using either <code>EMBED</code> or <code>FORK</code> mode.
If you are using <code>EXTERNAL</code> mode, then you should configure the <code>modules</code> parameter with the names of the Jetty modules that place these jars onto the container classpath.</p>
</div>
<div class="paragraph">
<p>Note that in <code>EMBED</code> or <code>FORK</code> mode, you could also influence the container classpath by setting the <code>useProvidedScope</code> parameter to <code>true</code>: this will place any dependencies with &lt;scope&gt;provided&lt;scope&gt; onto the plugin&#8217;s classpath.
Use this very cautiously: as the plugin already automatically places most Jetty jars onto the classpath, you could wind up with duplicate jars.</p>
</div>
</div>
<div class="sect3">
<h4 id="jetty-run-goal"><a class="anchor" href="#jetty-run-goal"></a><a class="link" href="#jetty-run-goal">jetty:run</a></h4>
<div class="paragraph">
<p>The <code>run</code> goal deploys a webapp that is <em>not</em> first built into a WAR.
A virtual webapp is constructed from the project&#8217;s sources and its dependencies.
It looks for the constituent parts of a webapp in the Maven default project locations, although you can override these in the plugin configuration.
For example, by default it looks for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>resources in <code>${project.basedir}/src/main/webapp</code></p>
</li>
<li>
<p>classes in <code>${project.build.outputDirectory}</code></p>
</li>
<li>
<p><code>web.xml</code> in <code>${project.basedir}/src/main/webapp/WEB-INF/</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The plugin first runs a Maven parallel build to ensure that the classes are built and up-to-date before deployment.
If you change the source of a class and your IDE automatically compiles it in the background, the plugin picks up the changed class (note you need to configure a non-zero <code>scan</code> interval for automatic redeployment).</p>
</div>
<div class="paragraph">
<p>If the plugin is invoked in a multi-module build, any dependencies that are also in the Maven reactor are used from their compiled classes.</p>
</div>
<div class="paragraph">
<p>Once invoked, you can configure the plugin to run continuously, scanning for changes in the project and automatically performing a hot redeploy when necessary.
Any changes you make are immediately reflected in the running instance of Jetty, letting you quickly jump from coding to testing, rather than going through the cycle of: code, compile, reassemble, redeploy, test.</p>
</div>
<div class="paragraph">
<p>The Maven build will be paused until Jetty exits, at which time Maven will also exit.</p>
</div>
<div class="paragraph">
<p>Stopping Jetty is accomplished by typing <code>cntrl-c</code> at the command line.</p>
</div>
<div class="paragraph">
<p>Output from Jetty will be logged to the console.</p>
</div>
<div class="paragraph">
<p>Here is an example, which turns on scanning for changes every ten seconds, and sets the webapp context path to <code>/test</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;scan&gt;</span>10<span class="tag">&lt;/scan&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="pg-configuration-2"><a class="anchor" href="#pg-configuration-2"></a><a class="link" href="#pg-configuration-2">Configuration</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1">webApp</dt>
<dd>
<p>This is an instance of <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/ee10}/maven/plugin/MavenWebAppContext.html">org.eclipse.jetty.ee10.maven.plugin.MavenWebAppContext</a>, which is an extension to the class  <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/ee10/webapp/WebAppContext.hml"><code>org.eclipse.jetty.ee10.webapp.WebAppContext</code></a>.
You can use any of the setter methods on this object to configure your webapp.
Here are a few of the most useful ones:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">contextPath</dt>
<dd>
<p>The context path for your webapp. By default, this is set to <code>/</code>.
If using a custom value for this parameter, you should include the leading <code>/</code>, example <code>/mycontext</code>.</p>
</dd>
<dt class="hdlist1">descriptor</dt>
<dd>
<p>The path to the <code>web.xml</code> file for your webapp.
By default, the plugin will look in <code>src/main/webapp/WEB-INF/web.xml</code>.</p>
</dd>
<dt class="hdlist1">defaultsDescriptor</dt>
<dd>
<p>The path to a <code>webdefault.xml</code> file that will be applied to your webapp before the <code>web.xml</code>.
If you don&#8217;t supply one, Jetty uses a default file baked into the <code>jetty-ee10-webapp.jar</code>.</p>
</dd>
<dt class="hdlist1">overrideDescriptor</dt>
<dd>
<p>The path to a <code>web.xml</code> file that Jetty applies after reading your <code>web.xml</code>.
You can use this to replace or add configuration.</p>
</dd>
<dt class="hdlist1">jettyEnvXml</dt>
<dd>
<p>Optional.
Location of a <code>jetty-env.xml</code> file, which allows you to make JNDI bindings that satisfy <code>env-entry</code>, <code>resource-env-ref</code>, and <code>resource-ref</code> linkages in the <code>web.xml</code> that are scoped  only to the webapp and not shared with other webapps that you might be deploying at the same time (for example, by using a <code>jettyXml</code> file).</p>
</dd>
<dt class="hdlist1">tempDirectory</dt>
<dd>
<p>The path to a dir that Jetty can use to expand or copy jars and jsp compiles when your webapp is running.
The default is <code>${project.build.outputDirectory}/tmp</code>.</p>
</dd>
<dt class="hdlist1">baseResource</dt>
<dd>
<p>The path from which Jetty serves static resources.
Defaults to <code>src/main/webapp</code>.
If this location does not exist (because, for example, your project does not use static content), then the plugin will synthesize a virtual static resource location of <code>target/webapp-synth</code>.</p>
</dd>
<dt class="hdlist1">resourceBases</dt>
<dd>
<p>Use instead of <code>baseResource</code> if you have multiple directories from which you want to serve static content.
This is an array of directory locations, either as urls or file paths.</p>
</dd>
<dt class="hdlist1">baseAppFirst</dt>
<dd>
<p>Defaults to "true".
Controls whether any overlaid wars are added before or after the original base resource(s) of the webapp.
See the section on <a href="#using-overlaid-wars">overlaid wars</a> for more information.</p>
</dd>
<dt class="hdlist1">containerIncludeJarPattern</dt>
<dd>
<p>Defaults to <code>.<strong>/jetty-jakarta-servlet-api-[<sup>/]</strong>\.jar$|.<strong>jakarta.servlet.jsp.jstl-[</sup>/]</strong>\.jar|.<strong>taglibs-standard-impl-.</strong>\.jar</code>.
This is a pattern that is applied to the names of the jars on the container&#8217;s classpath (ie the classpath of the plugin, not that of the webapp) that should be scanned for fragments, tlds, annotations etc.
This is analogous to the context attribute <a href="#og-container-include-jar-pattern">org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern</a> that is documented <a href="#og-container-include-jar-pattern">here</a>.
You can define extra patterns of jars that will be included in the scan.</p>
</dd>
<dt class="hdlist1">webInfIncludeJarPattern</dt>
<dd>
<p>Defaults to matching <em>all</em> of the dependency jars for the webapp (ie the equivalent of WEB-INF/lib).
You can make this pattern more restrictive to only match certain jars by using this setter.
This is analogous to the context attribute <a href="#og-web-inf-include-jar-pattern">org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern</a> that is documented <a href="#og-web-inf-include-jar-pattern">here</a>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">contextXml</dt>
<dd>
<p>The path to a context xml file that is applied to your webapp AFTER the <code>webApp</code> element.</p>
</dd>
<dt class="hdlist1">classesDirectory</dt>
<dd>
<p>Location of your compiled classes for the webapp.
You should rarely need to set this parameter.
Instead, you should set <code>&lt;build&gt;&lt;outputDirectory&gt;</code> in your <code>pom.xml</code>.</p>
</dd>
<dt class="hdlist1">testClassesDirectory</dt>
<dd>
<p>Location of the compiled test classes for your webapp. By default this is <code>${project.build.testOutputDirectory}</code>.</p>
</dd>
<dt class="hdlist1">useTestScope</dt>
<dd>
<p>If true, the classes from <code>testClassesDirectory</code> and dependencies of scope "test" are placed first on the classpath.
By default this is false.</p>
</dd>
<dt class="hdlist1">scan</dt>
<dd>
<p>The pause in seconds between sweeps of the webapp to check for changes and automatically hot redeploy if any are detected.
<strong>By default this is <code>-1</code>, which disables hot redeployment scanning.</strong>
A value of <code>0</code> means no hot redeployment is done, and that you must use the <kbd>Enter</kbd> key to manually force a redeploy.
Any positive integer will enable hot redeployment, using the number as the sweep interval in seconds.</p>
</dd>
<dt class="hdlist1">scanTargetPatterns</dt>
<dd>
<p>Optional.
List of extra directories with glob-style include/excludes patterns (see <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">javadoc</a> for <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">FileSystem.getPathMatcher</a>) to specify other files to periodically scan for changes.</p>
</dd>
<dt class="hdlist1">scanClassesPattern</dt>
<dd>
<p>Optional.
Include and exclude patterns that can be applied to the classesDirectory for the purposes of scanning, it does <strong>not</strong> affect the classpath.
If a file or directory is excluded by the patterns then a change in that file (or subtree in the case of a directory) is ignored and will not cause the webapp to redeploy.
Patterns are specified as a relative path using a glob-like syntax as described in the <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">javadoc</a> for <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">FileSystem.getPathMatcher</a>.</p>
</dd>
<dt class="hdlist1">scanTestClassesPattern</dt>
<dd>
<p>Optional.
Include and exclude patterns that can be applied to the testClassesDirectory for the purposes of scanning, it does <strong>not</strong> affect the classpath.
If a file or directory is excluded by the patterns then a change in that file (or subtree in the case of a directory) is ignored and will not cause the webapp to redeploy.
Patterns are specified as a relative path using a glob-like syntax as described in the <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">javadoc</a> for <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/file/FileSystem.html#getPathMatcher-java.lang.String-">FileSystem.getPathMatcher</a>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See <a href="#deployment-modes">Deployment Modes</a> for other configuration parameters available when using the <code>run</code> goal in EMBED, FORK or EXTERNAL modes.</p>
</div>
<div class="paragraph">
<p>Here is an example of a pom configuration for the plugin with the <code>run</code> goal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;project&gt;</span>
  ...
  <span class="tag">&lt;plugins&gt;</span>
    ...
    <span class="tag">&lt;plugin&gt;</span>
      <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
      <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
      <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
      <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;webApp&gt;</span>
          <span class="tag">&lt;contextPath&gt;</span>/<span class="tag">&lt;/contextPath&gt;</span>
          <span class="tag">&lt;descriptor&gt;</span>${project.basedir}/src/over/here/web.xml<span class="tag">&lt;/descriptor&gt;</span>
          <span class="tag">&lt;jettyEnvXml&gt;</span>${project.basedir}/src/over/here/jetty-env.xml<span class="tag">&lt;/jettyEnvXml&gt;</span>
          <span class="tag">&lt;baseResource&gt;</span>${project.basedir}/src/staticfiles<span class="tag">&lt;/baseResource&gt;</span>
        <span class="tag">&lt;/webApp&gt;</span>
        <span class="tag">&lt;classesDirectory&gt;</span>${project.basedir}/somewhere/else<span class="tag">&lt;/classesDirectory&gt;</span>
        <span class="tag">&lt;scanClassesPattern&gt;</span>
          <span class="tag">&lt;excludes&gt;</span>
             <span class="tag">&lt;exclude&gt;</span>**/Foo.class<span class="tag">&lt;/exclude&gt;</span>
          <span class="tag">&lt;/excludes&gt;</span>
        <span class="tag">&lt;/scanClassesPattern&gt;</span>
        <span class="tag">&lt;scanTargetPatterns&gt;</span>
          <span class="tag">&lt;scanTargetPattern&gt;</span>
            <span class="tag">&lt;directory&gt;</span>src/other-resources<span class="tag">&lt;/directory&gt;</span>
            <span class="tag">&lt;includes&gt;</span>
              <span class="tag">&lt;include&gt;</span>**/*.xml<span class="tag">&lt;/include&gt;</span>
              <span class="tag">&lt;include&gt;</span>**/*.properties<span class="tag">&lt;/include&gt;</span>
            <span class="tag">&lt;/includes&gt;</span>
            <span class="tag">&lt;excludes&gt;</span>
              <span class="tag">&lt;exclude&gt;</span>**/myspecial.xml<span class="tag">&lt;/exclude&gt;</span>
              <span class="tag">&lt;exclude&gt;</span>**/myspecial.properties<span class="tag">&lt;/exclude&gt;</span>
            <span class="tag">&lt;/excludes&gt;</span>
          <span class="tag">&lt;/scanTargetPattern&gt;</span>
        <span class="tag">&lt;/scanTargetPatterns&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
    <span class="tag">&lt;/plugin&gt;</span>
  <span class="tag">&lt;/plugins&gt;</span>
  ...
<span class="tag">&lt;/project&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If, for whatever reason, you cannot run on an unassembled webapp, the goal <code>run-war</code> works on assembled webapps.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-run-war-goal"><a class="anchor" href="#jetty-run-war-goal"></a><a class="link" href="#jetty-run-war-goal">jetty:run-war</a></h4>
<div class="paragraph">
<p>When invoked at the command line this goal first executes a maven build of your project to the package phase.</p>
</div>
<div class="paragraph">
<p>By default it then deploys the resultant war to Jetty, but you can use this goal instead to deploy <em>any</em> war file by simply setting the <code>&lt;webApp&gt;&lt;war&gt;</code> configuration parameter to its location.</p>
</div>
<div class="paragraph">
<p>If you set a non-zero <code>scan</code>, Jetty watches your <code>pom.xml</code> and the WAR file; if either changes, it redeploys the war.</p>
</div>
<div class="paragraph">
<p>The maven build is held up until Jetty exits, which is achieved by typing <code>cntrl-c</code> at the command line.</p>
</div>
<div class="paragraph">
<p>All Jetty output is directed to the console.</p>
</div>
<div class="sect4">
<h5 id="pg-configuration-3"><a class="anchor" href="#pg-configuration-3"></a><a class="link" href="#pg-configuration-3">Configuration</a></h5>
<div class="paragraph">
<p>Configuration parameters are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">webApp</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">war</dt>
<dd>
<p>The location of the built WAR file. This defaults to <code>${project.build.directory}/${project.build.finalName}.war</code>.
You can set it to the location of any pre-built war file.</p>
</dd>
<dt class="hdlist1">contextPath</dt>
<dd>
<p>The context path for your webapp. By default, this is set to <code>/</code>.
If using a custom value for this parameter, you should include the leading <code>/</code>, example <code>/mycontext</code>.</p>
</dd>
<dt class="hdlist1">defaultsDescriptor</dt>
<dd>
<p>The path to a <code>webdefault.xml</code> file that will be applied to your webapp before the <code>web.xml</code>.
If you don&#8217;t supply one, Jetty uses a default file baked into the <code>jetty-ee10-webapp.jar</code>.</p>
</dd>
<dt class="hdlist1">overrideDescriptor</dt>
<dd>
<p>The path to a <code>web.xml</code> file that Jetty applies after reading your <code>web.xml</code>.
You can use this to replace or add configuration.</p>
</dd>
<dt class="hdlist1">containerIncludeJarPattern</dt>
<dd>
<p>Defaults to <code>.<strong>/jetty-jakarta-servlet-api-[<sup>/]</strong>\.jar$|.<strong>jakarta.servlet.jsp.jstl-[</sup>/]</strong>\.jar|.<strong>taglibs-standard-impl-.</strong>\.jar</code>.
This is a pattern that is applied to the names of the jars on the container&#8217;s classpath (ie the classpath of the plugin, not that of the webapp) that should be scanned for fragments, tlds, annotations etc.
This is analogous to the context attribute <a href="#og-container-include-jar-pattern">org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern</a> that is documented <a href="#og-container-include-jar-pattern">here</a>.
You can define extra patterns of jars that will be included in the scan.</p>
</dd>
<dt class="hdlist1">webInfIncludeJarPattern</dt>
<dd>
<p>Defaults to matching <em>all</em> of the dependency jars for the webapp (ie the equivalent of WEB-INF/lib).
You can make this pattern more restrictive to only match certain jars by using this setter.
This is analogous to the context attribute <a href="#og-web-inf-include-jar-pattern">org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern</a> that is documented <a href="#og-web-inf-include-jar-pattern">here</a>.</p>
</dd>
<dt class="hdlist1">tempDirectory</dt>
<dd>
<p>The path to a dir that Jetty can use to expand or copy jars and jsp compiles when your webapp is running.
The default is <code>${project.build.outputDirectory}/tmp</code>.</p>
</dd>
<dt class="hdlist1">contextXml</dt>
<dd>
<p>The path to a context xml file that is applied to your webapp AFTER the <code>webApp</code> element.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">scan</dt>
<dd>
<p>The pause in seconds between sweeps of the webapp to check for changes and automatically hot redeploy if any are detected.
<strong>By default this is <code>-1</code>, which disables hot redeployment scanning.</strong>
A value of <code>0</code> means no hot redeployment is done, and that you must use the <kbd>Enter</kbd> key to manually force a redeploy.
Any positive integer will enable hot redeployment, using the number as the sweep interval in seconds.</p>
</dd>
<dt class="hdlist1">scanTargetPatterns</dt>
<dd>
<p>Optional.
List of directories with ant-style include/excludes patterns to specify other files to periodically scan for changes.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See <a href="#deployment-modes">Deployment Modes</a> for other configuration parameters available when using the <code>run-war</code> goal in EMBED, FORK or EXTERNAL modes.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-start-goal"><a class="anchor" href="#jetty-start-goal"></a><a class="link" href="#jetty-start-goal">jetty:start</a></h4>
<div class="paragraph">
<p>This is similar to the <code>jetty:run</code> goal, however it is <em>not</em> designed to be run from the command line and does <em>not</em> first execute the build up until the <code>test-compile</code> phase to ensure that all necessary classes and files of the webapp have been generated.
It will <em>not</em> scan your project for changes and restart your webapp.
It does <em>not</em> pause maven until Jetty is stopped.</p>
</div>
<div class="paragraph">
<p>Instead, it is designed to be used with build phase bindings in your pom.
For example to you can have Maven start your webapp at the beginning of your tests and stop at the end.</p>
</div>
<div class="paragraph">
<p>If the plugin is invoked as part of a multi-module build, any dependencies that are also in the maven reactor are used from their compiled classes.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of using the <code>pre-integration-test</code> and <code>post-integration-test</code> Maven build phases to trigger the execution and termination of Jetty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;stopKey&gt;</span>foo<span class="tag">&lt;/stopKey&gt;</span>
    <span class="tag">&lt;stopPort&gt;</span>9999<span class="tag">&lt;/stopPort&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
  <span class="tag">&lt;executions&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;id&gt;</span>start-jetty<span class="tag">&lt;/id&gt;</span>
      <span class="tag">&lt;phase&gt;</span>pre-integration-test<span class="tag">&lt;/phase&gt;</span>
      <span class="tag">&lt;goals&gt;</span>
        <span class="tag">&lt;goal&gt;</span>start<span class="tag">&lt;/goal&gt;</span>
      <span class="tag">&lt;/goals&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;id&gt;</span>stop-jetty<span class="tag">&lt;/id&gt;</span>
      <span class="tag">&lt;phase&gt;</span>post-integration-test<span class="tag">&lt;/phase&gt;</span>
       <span class="tag">&lt;goals&gt;</span>
         <span class="tag">&lt;goal&gt;</span>stop<span class="tag">&lt;/goal&gt;</span>
       <span class="tag">&lt;/goals&gt;</span>
     <span class="tag">&lt;/execution&gt;</span>
  <span class="tag">&lt;/executions&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This goal will generate output from jetty into the <code>target/jetty-start.out</code> file.</p>
</div>
<div class="sect4">
<h5 id="pg-configuration-4"><a class="anchor" href="#pg-configuration-4"></a><a class="link" href="#pg-configuration-4">Configuration</a></h5>
<div class="paragraph">
<p>These configuration parameters are available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">webApp</dt>
<dd>
<p>This is an instance of <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/ee10/maven/plugin/MavenWebAppContext.html">org.eclipse.jetty.ee10.maven.plugin.MavenWebAppContext</a>, which is an extension to the class  <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/webapp/WebAppContext.hml"><code>org.eclipse.jetty.ee9.webapp.WebAppContext</code></a>.
You can use any of the setter methods on this object to configure your webapp.
Here are a few of the most useful ones:</p>
<div class="dlist">
<dl>
<dt class="hdlist1">contextPath</dt>
<dd>
<p>The context path for your webapp. By default, this is set to <code>/</code>.
If using a custom value for this parameter, you should include the leading <code>/</code>, example <code>/mycontext</code>.</p>
</dd>
<dt class="hdlist1">descriptor</dt>
<dd>
<p>The path to the <code>web.xml</code> file for your webapp.
The default is <code>src/main/webapp/WEB-INF/web.xml</code>.</p>
</dd>
<dt class="hdlist1">defaultsDescriptor</dt>
<dd>
<p>The path to a <code>webdefault.xml</code> file that will be applied to your webapp before the <code>web.xml</code>.
If you don&#8217;t supply one, Jetty uses a default file baked into the <code>jetty-ee10-webapp.jar</code>.</p>
</dd>
<dt class="hdlist1">overrideDescriptor</dt>
<dd>
<p>The path to a <code>web.xml</code> file that Jetty applies after reading your <code>web.xml</code>.
You can use this to replace or add configuration.</p>
</dd>
<dt class="hdlist1">jettyEnvXml</dt>
<dd>
<p>Optional.
Location of a <code>jetty-env.xml</code> file, which allows you to make JNDI bindings that satisfy <code>env-entry</code>, <code>resource-env-ref</code>, and <code>resource-ref</code> linkages in the <code>web.xml</code> that are scoped  only to the webapp and not shared with other webapps that you might be deploying at the same time (for example, by using a <code>jettyXml</code> file).</p>
</dd>
<dt class="hdlist1">tempDirectory</dt>
<dd>
<p>The path to a dir that Jetty can use to expand or copy jars and jsp compiles when your webapp is running.
The default is <code>${project.build.outputDirectory}/tmp</code>.</p>
</dd>
<dt class="hdlist1">baseResource</dt>
<dd>
<p>The path from which Jetty serves static resources.
Defaults to <code>src/main/webapp</code>.</p>
</dd>
<dt class="hdlist1">resourceBases</dt>
<dd>
<p>Use instead of <code>baseResource</code> if you have multiple directories from which you want to serve static content.
This is an array of directory names.</p>
</dd>
<dt class="hdlist1">baseAppFirst</dt>
<dd>
<p>Defaults to "true".
Controls whether any overlaid wars are added before or after the original base resource(s) of the webapp.
See the section on <a href="#using-overlaid-wars">overlaid wars</a> for more information.</p>
</dd>
<dt class="hdlist1">containerIncludeJarPattern</dt>
<dd>
<p>Defaults to <code>.<strong>/jetty-jakarta-servlet-api-[<sup>/]</strong>\.jar$|.<strong>jakarta.servlet.jsp.jstl-[</sup>/]</strong>\.jar|.<strong>taglibs-standard-impl-.</strong>\.jar</code>.
This is a pattern that is applied to the names of the jars on the container&#8217;s classpath (ie the classpath of the plugin, not that of the webapp) that should be scanned for fragments, tlds, annotations etc.
This is analogous to the context attribute <a href="#og-container-include-jar-pattern">org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern</a> that is documented <a href="#og-container-include-jar-pattern">here</a>.
You can define extra patterns of jars that will be included in the scan.</p>
</dd>
<dt class="hdlist1">webInfIncludeJarPattern</dt>
<dd>
<p>Defaults to matching <em>all</em> of the dependency jars for the webapp (ie the equivalent of WEB-INF/lib).
You can make this pattern more restrictive to only match certain jars by using this setter.
This is analogous to the context attribute <a href="#og-web-inf-include-jar-pattern">org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern</a> that is documented <a href="#og-web-inf-include-jar-pattern">here</a>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">contextXml</dt>
<dd>
<p>The path to a context xml file that is applied to your webapp AFTER the <code>webApp</code> element.</p>
</dd>
<dt class="hdlist1">classesDirectory</dt>
<dd>
<p>Location of your compiled classes for the webapp.
You should rarely need to set this parameter.
Instead, you should set <code>build outputDirectory</code> in your <code>pom.xml</code>.</p>
</dd>
<dt class="hdlist1">testClassesDirectory</dt>
<dd>
<p>Location of the compiled test classes for your webapp. By default this is <code>${project.build.testOutputDirectory}</code>.</p>
</dd>
<dt class="hdlist1">useTestScope</dt>
<dd>
<p>If true, the classes from <code>testClassesDirectory</code> and dependencies of scope "test" are placed first on the classpath.
By default this is false.</p>
</dd>
<dt class="hdlist1">stopPort</dt>
<dd>
<p>Optional.
Port to listen on for stop commands.
Useful to use in conjunction with the <a href="#jetty-stop-goal">stop</a> and <a href="#jetty-start-goal">start</a> goals.</p>
</dd>
<dt class="hdlist1">stopKey</dt>
<dd>
<p>Optional.
Used in conjunction with stopPort for stopping jetty.
Useful to use in conjunction with the <a href="#jetty-stop-goal">stop</a> and <a href="#jetty-start-goal">start</a> goals.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These additional configuration parameters are available when running in <code>FORK</code> or <code>EXTERNAL</code> mode:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">maxChildStartChecks</dt>
<dd>
<p>Default is <code>10</code>.
This is maximum number of times the parent process checks to see if the forked jetty process has started correctly</p>
</dd>
<dt class="hdlist1">maxChildStartCheckMs</dt>
<dd>
<p>Default is <code>200</code>.
This is the time in milliseconds between checks on the startup of the forked jetty process.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-start-war-goal"><a class="anchor" href="#jetty-start-war-goal"></a><a class="link" href="#jetty-start-war-goal">jetty:start-war</a></h4>
<div class="paragraph">
<p>Similarly to the <code>jetty:start</code> goal, <code>jetty:start-war</code> is designed to be bound to build lifecycle phases in your pom.</p>
</div>
<div class="paragraph">
<p>It will <em>not</em> scan your project for changes and restart your webapp.
It does <em>not</em> pause maven until Jetty is stopped.</p>
</div>
<div class="paragraph">
<p>By default, if your pom is for a webapp project, it will deploy the war file for the project to jetty.
However, like the <code>jetty:run-war</code> project, you can nominate any war file to deploy by defining its location in the <code>&lt;webApp&gt;&lt;war&gt;</code> parameter.</p>
</div>
<div class="paragraph">
<p>If the plugin is invoked as part of a multi-module build, any dependencies that are also in the Maven reactor are used from their compiled classes.</p>
</div>
<div class="paragraph">
<p>This goal will generate output from jetty into the <code>target/jetty-start-war.out</code> file.</p>
</div>
<div class="sect4">
<h5 id="pg-configuration-5"><a class="anchor" href="#pg-configuration-5"></a><a class="link" href="#pg-configuration-5">Configuration</a></h5>
<div class="paragraph">
<p>These configuration parameters are available:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">webApp</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">war</dt>
<dd>
<p>The location of the built WAR file. This defaults to <code>${project.build.directory}/${project.build.finalName}.war</code>.
You can set it to the location of any pre-built war file.</p>
</dd>
<dt class="hdlist1">contextPath</dt>
<dd>
<p>The context path for your webapp. By default, this is set to <code>/</code>.
If using a custom value for this parameter, you should include the leading <code>/</code>, example <code>/mycontext</code>.</p>
</dd>
<dt class="hdlist1">defaultsDescriptor</dt>
<dd>
<p>The path to a <code>webdefault.xml</code> file that will be applied to your webapp before the <code>web.xml</code>.
If you don&#8217;t supply one, Jetty uses a default file baked into the <code>jetty-ee10-webapp.jar</code>.</p>
</dd>
<dt class="hdlist1">overrideDescriptor</dt>
<dd>
<p>The path to a <code>web.xml</code> file that Jetty applies after reading your <code>web.xml</code>.
You can use this to replace or add configuration.</p>
</dd>
<dt class="hdlist1">containerIncludeJarPattern</dt>
<dd>
<p>Defaults to <code>.<strong>/jetty-jakarta-servlet-api-[<sup>/]</strong>\.jar$|.<strong>jakarta.servlet.jsp.jstl-[</sup>/]</strong>\.jar|.<strong>taglibs-standard-impl-.</strong>\.jar</code>.
This is a pattern that is applied to the names of the jars on the container&#8217;s classpath (ie the classpath of the plugin, not that of the webapp) that should be scanned for fragments, tlds, annotations etc.
This is analogous to the context attribute <a href="#og-container-include-jar-pattern">org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern</a> that is documented <a href="#og-container-include-jar-pattern">here</a>.
You can define extra patterns of jars that will be included in the scan.</p>
</dd>
<dt class="hdlist1">webInfIncludeJarPattern</dt>
<dd>
<p>Defaults to matching <em>all</em> of the dependency jars for the webapp (ie the equivalent of WEB-INF/lib).
You can make this pattern more restrictive to only match certain jars by using this setter.
This is analogous to the context attribute <a href="#og-web-inf-include-jar-pattern">org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern</a> that is documented <a href="#og-web-inf-include-jar-pattern">here</a>.</p>
</dd>
<dt class="hdlist1">tempDirectory</dt>
<dd>
<p>The path to a dir that Jetty can use to expand or copy jars and jsp compiles when your webapp is running.
The default is <code>${project.build.outputDirectory}/tmp</code>.</p>
</dd>
<dt class="hdlist1">contextXml</dt>
<dd>
<p>The path to a context xml file that is applied to your webapp AFTER the <code>webApp</code> element.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1">stopPort</dt>
<dd>
<p>Optional.
Port to listen on for stop commands.
Useful to use in conjunction with the <a href="#jetty-stop-goal">stop</a>.</p>
</dd>
<dt class="hdlist1">stopKey</dt>
<dd>
<p>Optional.
Used in conjunction with stopPort for stopping jetty.
Useful to use in conjunction with the <a href="#jetty-stop-goal">stop</a>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>These additional configuration parameters are available when running in FORK or EXTERNAL mode:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">maxChildStartChecks</dt>
<dd>
<p>Default is <code>10</code>.
This is maximum number of times the parent process checks to see if the forked Jetty process has started correctly</p>
</dd>
<dt class="hdlist1">maxChildStartCheckMs</dt>
<dd>
<p>Default is <code>200</code>.
This is the time in milliseconds between checks on the startup of the forked Jetty process.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-stop-goal"><a class="anchor" href="#jetty-stop-goal"></a><a class="link" href="#jetty-stop-goal">jetty:stop</a></h4>
<div class="paragraph">
<p>The stop goal stops a FORK or EXTERNAL mode running instance of Jetty.
To use it, you need to configure the plugin with a special port number and key.
That same port number and key will also be used by the other goals that start Jetty.</p>
</div>
<div class="sect4">
<h5 id="pg-configuration-6"><a class="anchor" href="#pg-configuration-6"></a><a class="link" href="#pg-configuration-6">Configuration</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1">stopPort</dt>
<dd>
<p>A port number for Jetty to listen on to receive a stop command to cause it to shutdown.</p>
</dd>
<dt class="hdlist1">stopKey</dt>
<dd>
<p>A string value sent to the <code>stopPort</code> to validate the stop command.</p>
</dd>
<dt class="hdlist1">stopWait</dt>
<dd>
<p>The maximum time in seconds that the plugin will wait for confirmation that Jetty has stopped.
If false or not specified, the plugin does not wait for confirmation but exits after issuing the stop command.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Here&#8217;s a configuration example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;stopPort&gt;</span>9966<span class="tag">&lt;/stopPort&gt;</span>
    <span class="tag">&lt;stopKey&gt;</span>foo<span class="tag">&lt;/stopKey&gt;</span>
    <span class="tag">&lt;stopWait&gt;</span>10<span class="tag">&lt;/stopWait&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, while Jetty is running (in another window), type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mvn jetty:stop</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>stopPort</code> must be free on the machine you are running on.
If this is not the case, you will get an "Address already in use" error message after the "Started ServerConnector &#8230;&#8203;" message.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-effective-web-xml-goal"><a class="anchor" href="#jetty-effective-web-xml-goal"></a><a class="link" href="#jetty-effective-web-xml-goal">jetty:effective-web-xml</a></h4>
<div class="paragraph">
<p>This goal calculates a synthetic <code>web.xml</code> (the "effective web.xml") according to the rules of the Servlet Specification taking into account all sources of discoverable configuration of web components in your application: descriptors (<code>webdefault.xml</code>, <code>web.xml</code>, <code>web-fragment.xml`s, `web-override.xml</code>) and discovered annotations (<code>@WebServlet</code>, <code>@WebFilter</code>, <code>@WebListener</code>).
No programmatic declarations of servlets, filters and listeners can be taken into account.</p>
</div>
<div class="paragraph">
<p>You can calculate the effective web.xml for any pre-built war file by setting the <code>&lt;webApp&gt;&lt;war&gt;</code> parameter, or you can calculate it for the unassembled webapp by setting all of the usual <code>&lt;webApp&gt;</code> parameters as for <code>jetty:run</code>.</p>
</div>
<div class="paragraph">
<p>Other useful information about your webapp that is produced as part of the analysis is also stored as context parameters in the effective-web.xml.
The effective-web.xml can be used in conjunction with the <a href="#og-quickstart">Quickstart</a> feature to quickly start your webapp (note that Quickstart is not appropriate for the mvn jetty goals).</p>
</div>
<div class="paragraph">
<p>The effective web.xml from these combined sources is generated into a file, which by default is <code>target/effective-web.xml</code>, but can be changed by setting the <code>effectiveWebXml</code> configuration parameter.</p>
</div>
<div class="sect4">
<h5 id="pg-configuration-7"><a class="anchor" href="#pg-configuration-7"></a><a class="link" href="#pg-configuration-7">Configuration</a></h5>
<div class="dlist">
<dl>
<dt class="hdlist1">effectiveWebXml</dt>
<dd>
<p>The full path name of a file into which you would like the effective web xml generated.</p>
</dd>
<dt class="hdlist1">webApp</dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">war</dt>
<dd>
<p>The location of the built WAR file. This defaults to <code>${project.build.directory}/${project.build.finalName}.war</code>.
You can set it to the location of any pre-built war file.
Or you can leave it blank and set up the other <code>webApp</code> parameters as per <a href="#jetty-run-goal">jetty:run</a>, as well as the <code>webAppSourceDirectory</code>, <code>classes</code> and <code>testClasses</code> parameters.</p>
</dd>
<dt class="hdlist1">contextPath</dt>
<dd>
<p>The context path for your webapp. By default, this is set to <code>/</code>.
If using a custom value for this parameter, you should include the leading <code>/</code>, example <code>/mycontext</code>.</p>
</dd>
<dt class="hdlist1">defaultsDescriptor</dt>
<dd>
<p>The path to a <code>webdefault.xml</code> file that will be applied to your webapp before the <code>web.xml</code>.
If you don&#8217;t supply one, Jetty uses a default file baked into the <code>jetty-ee10-webapp.jar</code>.</p>
</dd>
<dt class="hdlist1">overrideDescriptor</dt>
<dd>
<p>The path to a <code>web.xml</code> file that Jetty applies after reading your <code>web.xml</code>.
You can use this to replace or add configuration.</p>
</dd>
<dt class="hdlist1">containerIncludeJarPattern</dt>
<dd>
<p>Defaults to <code>.<strong>/jetty-jakarta-servlet-api-[<sup>/]</strong>\.jar$|.<strong>jakarta.servlet.jsp.jstl-[</sup>/]</strong>\.jar|.<strong>taglibs-standard-impl-.</strong>\.jar</code>.
This is a pattern that is applied to the names of the jars on the container&#8217;s classpath (ie the classpath of the plugin, not that of the webapp) that should be scanned for fragments, tlds, annotations etc.
This is analogous to the context attribute <a href="#og-container-include-jar-pattern">org.eclipse.jetty.server.webapp.ContainerIncludeJarPattern</a> that is documented <a href="#og-container-include-jar-pattern">here</a>.
You can define extra patterns of jars that will be included in the scan.</p>
</dd>
<dt class="hdlist1">webInfIncludeJarPattern</dt>
<dd>
<p>Defaults to matching <em>all</em> of the dependency jars for the webapp (ie the equivalent of WEB-INF/lib).
You can make this pattern more restrictive to only match certain jars by using this setter.
This is analogous to the context attribute <a href="#og-web-inf-include-jar-pattern">org.eclipse.jetty.server.webapp.WebInfIncludeJarPattern</a> that is documented <a href="#og-web-inf-include-jar-pattern">here</a>.</p>
</dd>
<dt class="hdlist1">tempDirectory</dt>
<dd>
<p>The path to a dir that Jetty can use to expand or copy jars and jsp compiles when your webapp is running.
The default is <code>${project.build.outputDirectory}/tmp</code>.</p>
</dd>
<dt class="hdlist1">contextXml</dt>
<dd>
<p>The path to a context xml file that is applied to your webapp AFTER the <code>webApp</code> element.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>You can also generate the origin of each element into the effective web.xml file.
The origin is either a descriptor eg web.xml,web-fragment.xml,override-web.xml file, or an annotation eg @WebServlet.
Some examples of elements with origin attribute information are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;listener</span> <span class="attribute-name">origin</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">DefaultsDescriptor(file:///path/to/distro/etc/webdefault.xml):21</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;listener</span> <span class="attribute-name">origin</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">WebDescriptor(file:///path/to/base/webapps/test-spec/WEB-INF/web.xml):22</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;servlet-class</span> <span class="attribute-name">origin</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">FragmentDescriptor(jar:file:///path/to/base/webapps/test-spec/WEB-INF/lib/test-web-fragment.jar!/META-INF/web-fragment.xml):23</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
<span class="tag">&lt;servlet-class</span> <span class="attribute-name">origin</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">@WebServlet(com.acme.test.TestServlet):24</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>To generate origin information, use the following configuration parameters on the  <code>webApp</code> element:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">originAttribute</dt>
<dd>
<p>The name of the attribute that will contain the origin.
By default it is <code>origin</code>.</p>
</dd>
<dt class="hdlist1">generateOrigin</dt>
<dd>
<p>False by default. If true, will force the generation of the <code>originAttribute</code> onto each element.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-overlaid-wars"><a class="anchor" href="#using-overlaid-wars"></a><a class="link" href="#using-overlaid-wars">Using Overlaid wars</a></h4>
<div class="paragraph">
<p>If your webapp depends on other war files, the <a href="#jetty-run-goal">jetty:run</a> and <a href="#jetty-start-goal">jetty:start</a> goals are able to merge resources from all of them.
It can do so based on the settings of the <a href="http://maven.apache.org/plugins/maven-war-plugin/">maven-war-plugin</a>, or if your project does not use the <a href="http://maven.apache.org/plugins/maven-war-plugin/">maven-war-plugin</a> to handle the overlays, it can fall back to a simple algorithm to determine the ordering of resources.</p>
</div>
<div class="sect4">
<h5 id="pg-with-maven-war-plugin"><a class="anchor" href="#pg-with-maven-war-plugin"></a><a class="link" href="#pg-with-maven-war-plugin">With maven-war-plugin</a></h5>
<div class="paragraph">
<p>The <code>maven-war-plugin</code> has a rich set of capabilities for merging resources.
The <code>jetty:run</code> and <code>jetty:start</code> goals are able to interpret most of them and apply them during execution of your unassembled webapp.
This is probably best seen by looking at a concrete example.</p>
</div>
<div class="paragraph">
<p>Suppose your webapp depends on the following wars:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>X<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;type&gt;</span>war<span class="tag">&lt;/type&gt;</span>
<span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>Y<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;type&gt;</span>war<span class="tag">&lt;/type&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Containing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>WebAppX:

 /foo.jsp
 /bar.jsp
 /WEB-INF/web.xml

WebAppY:

 /bar.jsp
 /baz.jsp
 /WEB-INF/web.xml
 /WEB-INF/special.xml</pre>
</div>
</div>
<div class="paragraph">
<p>They are configured for the <a href="http://maven.apache.org/plugins/maven-war-plugin/overlays.html">maven-war-plugin</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>maven-war-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;overlays&gt;</span>
      <span class="tag">&lt;overlay&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>X<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;excludes&gt;</span>
          <span class="tag">&lt;exclude&gt;</span>bar.jsp<span class="tag">&lt;/exclude&gt;</span>
        <span class="tag">&lt;/excludes&gt;</span>
      <span class="tag">&lt;/overlay&gt;</span>
      <span class="tag">&lt;overlay&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>Y<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;excludes&gt;</span>
          <span class="tag">&lt;exclude&gt;</span>baz.jsp<span class="tag">&lt;/exclude&gt;</span>
        <span class="tag">&lt;/excludes&gt;</span>
      <span class="tag">&lt;/overlay&gt;</span>
      <span class="tag">&lt;overlay&gt;</span>
      <span class="tag">&lt;/overlay&gt;</span>
    <span class="tag">&lt;/overlays&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then executing jetty:run would yield the following ordering of resources: <code>com.acme.X.war : com.acme.Y.war: ${project.basedir}/src/main/webapp</code>.
Note that the current project&#8217;s resources are placed last in the ordering due to the empty &lt;overlay/&gt; element in the <code>maven-war-plugin</code>.
You can either use that, or specify the <code>&lt;baseAppFirst&gt;false&lt;/baseAppFirst&gt;</code> parameter to the <code>jetty-ee10-maven-plugin</code>.</p>
</div>
<div class="paragraph">
<p>Moreover, due to the <code>exclusions</code> specified above, a request for the resource ` bar.jsp` would only be satisfied from <code>com.acme.Y.war.</code>
Similarly as <code>baz.jsp</code> is excluded, a request for it would result in a 404 error.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-without-maven-war-plugin"><a class="anchor" href="#pg-without-maven-war-plugin"></a><a class="link" href="#pg-without-maven-war-plugin">Without maven-war-plugin</a></h5>
<div class="paragraph">
<p>The algorithm is fairly simple, is based on the ordering of declaration of the dependent wars, and does not support exclusions.
The configuration parameter <code>&lt;baseAppFirst&gt;</code> (see for example <a href="#jetty-run-goal">jetty:run</a> for more information) can be used to control whether your webapp&#8217;s resources are placed first or last on the resource path at runtime.</p>
</div>
<div class="paragraph">
<p>For example, suppose our webapp depends on these two wars:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>X<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;type&gt;</span>war<span class="tag">&lt;/type&gt;</span>
<span class="tag">&lt;/dependency&gt;</span>
<span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>com.acme<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>Y<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;type&gt;</span>war<span class="tag">&lt;/type&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Suppose the webapps contain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>WebAppX:

 /foo.jsp
 /bar.jsp
 /WEB-INF/web.xml

WebAppY:

 /bar.jsp
 /baz.jsp
 /WEB-INF/web.xml
 /WEB-INF/special.xml</pre>
</div>
</div>
<div class="paragraph">
<p>Then our webapp has available these additional resources:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/foo.jsp (X)
/bar.jsp (X)
/baz.jsp (Y)
/WEB-INF/web.xml (X)
/WEB-INF/special.xml (Y)</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-security-settings"><a class="anchor" href="#configuring-security-settings"></a><a class="link" href="#configuring-security-settings">Configuring Security Settings</a></h4>
<div class="paragraph">
<p>You can configure LoginServices in the plugin.
Here&#8217;s an example of setting up the <code>HashLoginService</code> for a webapp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;scan&gt;</span>10<span class="tag">&lt;/scan&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
    <span class="tag">&lt;loginServices&gt;</span>
      <span class="tag">&lt;loginService</span> <span class="attribute-name">implementation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.security.HashLoginService</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;name&gt;</span>Test Realm<span class="tag">&lt;/name&gt;</span>
        <span class="tag">&lt;config&gt;</span>${project.basedir}/src/etc/realm.properties<span class="tag">&lt;/config&gt;</span>
      <span class="tag">&lt;/loginService&gt;</span>
    <span class="tag">&lt;/loginServices&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="using-multiple-webapp-root-directories"><a class="anchor" href="#using-multiple-webapp-root-directories"></a><a class="link" href="#using-multiple-webapp-root-directories">Using Multiple Webapp Root Directories</a></h4>
<div class="paragraph">
<p>If you have external resources that you want to incorporate in the execution of a webapp, but which are not assembled into war files, you can&#8217;t use the overlaid wars method described above, but you can tell Jetty the directories in which these external resources are located.
At runtime, when Jetty receives a request for a resource, it searches all the locations to retrieve the resource.
It&#8217;s a lot like the overlaid war situation, but without the war.</p>
</div>
<div class="paragraph">
<p>Here is a configuration example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;configuration&gt;</span>
  <span class="tag">&lt;webApp&gt;</span>
    <span class="tag">&lt;contextPath&gt;</span>/${build.finalName}<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;resourceBases&gt;</span>
      <span class="tag">&lt;resourceBase&gt;</span>src/main/webapp<span class="tag">&lt;/resourceBase&gt;</span>
      <span class="tag">&lt;resourceBase&gt;</span>/home/johndoe/path/to/my/other/source<span class="tag">&lt;/resourceBase&gt;</span>
      <span class="tag">&lt;resourceBase&gt;</span>/yet/another/folder<span class="tag">&lt;/resourceBase&gt;</span>
    <span class="tag">&lt;/resourceBases&gt;</span>
  <span class="tag">&lt;/webApp&gt;</span>
<span class="tag">&lt;/configuration&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-more-than-one-webapp"><a class="anchor" href="#running-more-than-one-webapp"></a><a class="link" href="#running-more-than-one-webapp">Running More than One Webapp</a></h4>
<div class="sect4">
<h5 id="pg-with-jettyrun"><a class="anchor" href="#pg-with-jettyrun"></a><a class="link" href="#pg-with-jettyrun">With jetty:run</a></h5>
<div class="paragraph">
<p>You can use either a <code>jetty.xml</code> file to configure extra (pre-compiled) webapps that you want to deploy, or you can use the <code>&lt;contextHandlers&gt;</code> configuration element to do so.
If you want to deploy webapp A, and webapps B and C in the same Jetty instance:</p>
</div>
<div class="paragraph">
<p>Putting the configuration in webapp A&#8217;s <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;scan&gt;</span>10<span class="tag">&lt;/scan&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
    <span class="tag">&lt;contextHandlers&gt;</span>
      <span class="tag">&lt;contextHandler</span> <span class="attribute-name">implementation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.ee10.maven.plugin.MavenWebAppContext</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;war&gt;</span>${project.basedir}../../B.war<span class="tag">&lt;/war&gt;</span>
        <span class="tag">&lt;contextPath&gt;</span>/B<span class="tag">&lt;/contextPath&gt;</span>
      <span class="tag">&lt;/contextHandler&gt;</span>
      <span class="tag">&lt;contextHandler</span> <span class="attribute-name">implementation</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.ee10.maven.plugin.MavenWebAppContext</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;war&gt;</span>${project.basedir}../../C.war<span class="tag">&lt;/war&gt;</span>
        <span class="tag">&lt;contextPath&gt;</span>/C<span class="tag">&lt;/contextPath&gt;</span>
      <span class="tag">&lt;/contextHandler&gt;</span>
    <span class="tag">&lt;/contextHandlers&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If the <code>ContextHandler</code> you are deploying is a webapp, it is <strong>essential</strong> that you use an <code>org.eclipse.jetty.ee10.maven.plugin.MavenWebAppContext</code> instance rather than a standard <code>org.eclipse.jetty.ee10.webapp.WebAppContext</code> instance.
Only the former will allow the webapp to function correctly in the Maven environment.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, add a <code>jetty.xml</code> file to webapp A.
Copy the <code>jetty.xml</code> file from the Jetty distribution, and then add WebAppContexts for the other 2 webapps:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;Ref</span> <span class="attribute-name">refid</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">Contexts</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
  <span class="tag">&lt;Call</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">addHandler</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
    <span class="tag">&lt;Arg&gt;</span>
      <span class="tag">&lt;New</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.{ee-current}.maven.plugin.MavenWebAppContext</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;Set</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">contextPath</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>/B<span class="tag">&lt;/Set&gt;</span>
        <span class="tag">&lt;Set</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">war</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>../../B.war<span class="tag">&lt;/Set&gt;</span>
      <span class="tag">&lt;/New&gt;</span>
    <span class="tag">&lt;/Arg&gt;</span>
  <span class="tag">&lt;/Call&gt;</span>
  <span class="tag">&lt;Call&gt;</span>
    <span class="tag">&lt;Arg&gt;</span>
      <span class="tag">&lt;New</span> <span class="attribute-name">class</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.{ee-current}.maven.plugin.MavenWebAppContext</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>
        <span class="tag">&lt;Set</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">contextPath</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>/C<span class="tag">&lt;/Set&gt;</span>
        <span class="tag">&lt;Set</span> <span class="attribute-name">name</span>=<span class="string"><span class="delimiter">&quot;</span><span class="content">war</span><span class="delimiter">&quot;</span></span><span class="tag">&gt;</span>../../C.war<span class="tag">&lt;/Set&gt;</span>
      <span class="tag">&lt;/New&gt;</span>
    <span class="tag">&lt;/Arg&gt;</span>
  <span class="tag">&lt;/Call&gt;</span>
<span class="tag">&lt;/Ref&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Then configure the location of this <code>jetty.xml</code> file into webapp A&#8217;s Jetty plugin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;scan&gt;</span>10<span class="tag">&lt;/scan&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
    <span class="tag">&lt;jettyXml&gt;</span>src/main/etc/jetty.xml<span class="tag">&lt;/jettyXml&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>For either of these solutions, the other webapps must already have been built, and they are not automatically monitored for changes.
You can refer either to the packed WAR file of the pre-built webapps or to their expanded equivalents.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-system-properties"><a class="anchor" href="#setting-system-properties"></a><a class="link" href="#setting-system-properties">Setting System Properties</a></h4>
<div class="paragraph">
<p>You can specify property name/value pairs that Jetty sets as System properties for the execution of the plugin.
This feature is useful to tidy up the command line and save a lot of typing.</p>
</div>
<div class="paragraph">
<p>However, <strong>sometimes it is not possible to use this feature to set System properties</strong> - sometimes the software component using the System property is already initialized by the time that maven runs (in which case you will need to provide the System property on the command line), or by the time that Jetty runs.
In the latter case, you can use the <a href="http://www.mojohaus.org/">maven properties plugin</a> to define the system properties instead. Here&#8217;s an example that configures the logback logging system as the Jetty logger:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.codehaus.mojo<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>properties-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;executions&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;goals&gt;</span>
        <span class="tag">&lt;goal&gt;</span>set-system-properties<span class="tag">&lt;/goal&gt;</span>
      <span class="tag">&lt;/goals&gt;</span>
      <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;properties&gt;</span>
          <span class="tag">&lt;property&gt;</span>
            <span class="tag">&lt;name&gt;</span>logback.configurationFile<span class="tag">&lt;/name&gt;</span>
            <span class="tag">&lt;value&gt;</span>${project.baseUri}/resources/logback.xml<span class="tag">&lt;/value&gt;</span>
          <span class="tag">&lt;/property&gt;</span>
        <span class="tag">&lt;/properties&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
  <span class="tag">&lt;/executions&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If a System property is already set (for example, from the command line or by the JVM itself), then by default these configured properties <strong>DO NOT</strong> override them.
However, they can override system properties set from a file instead, see <a href="#specifying-properties-in-file">specifying system properties in a file</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="specifying-properties-in-pom"><a class="anchor" href="#specifying-properties-in-pom"></a><a class="link" href="#specifying-properties-in-pom">Specifying System Properties in the POM</a></h5>
<div class="paragraph">
<p>Here&#8217;s an example of how to specify System properties in the POM:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.{ee-current}<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-{ee-current}-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;systemProperties&gt;</span>
        <span class="tag">&lt;fooprop&gt;</span>222<span class="tag">&lt;/fooprop&gt;</span>
    <span class="tag">&lt;/systemProperties&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="specifying-properties-in-file"><a class="anchor" href="#specifying-properties-in-file"></a><a class="link" href="#specifying-properties-in-file">Specifying System Properties in a File</a></h5>
<div class="paragraph">
<p>You can also specify your System properties in a file.
System properties you specify in this way <strong>do not</strong> override System properties that set on the command line, by the JVM, or directly in the POM via <code>systemProperties</code>.</p>
</div>
<div class="paragraph">
<p>Suppose we have a file called <code>mysys.props</code> which contains the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>fooprop=222</pre>
</div>
</div>
<div class="paragraph">
<p>This can be configured on the plugin like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.{ee-current}<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-{ee-current}-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;systemPropertiesFile&gt;</span>${project.basedir}/mysys.props<span class="tag">&lt;/systemPropertiesFile&gt;</span>
    <span class="tag">&lt;webApp&gt;</span>
      <span class="tag">&lt;contextPath&gt;</span>/test<span class="tag">&lt;/contextPath&gt;</span>
    <span class="tag">&lt;/webApp&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can instead specify the file by setting the System property <code>jetty.systemPropertiesFile</code> on the command line.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jetty-jspc-maven-plugin"><a class="anchor" href="#jetty-jspc-maven-plugin"></a><a class="link" href="#jetty-jspc-maven-plugin">Jetty Jspc Maven Plugin</a></h3>
<div class="paragraph">
<p>This plugin will pre-compile your JSP and works in conjunction with the Maven war plugin to put them inside an assembled war.</p>
</div>
<div class="sect3">
<h4 id="jspc-config"><a class="anchor" href="#jspc-config"></a><a class="link" href="#jspc-config">Configuration</a></h4>
<div class="paragraph">
<p>Here&#8217;s the basic setup required to put the JSPC plugin into your build for the Jakarta EE ee10 environment:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
   <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-jspc-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
   <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
   <span class="tag">&lt;executions&gt;</span>
     <span class="tag">&lt;execution&gt;</span>
       <span class="tag">&lt;id&gt;</span>jspc<span class="tag">&lt;/id&gt;</span>
       <span class="tag">&lt;goals&gt;</span>
         <span class="tag">&lt;goal&gt;</span>jspc<span class="tag">&lt;/goal&gt;</span>
       <span class="tag">&lt;/goals&gt;</span>
       <span class="tag">&lt;configuration&gt;</span>
       <span class="tag">&lt;/configuration&gt;</span>
     <span class="tag">&lt;/execution&gt;</span>
   <span class="tag">&lt;/executions&gt;</span>
 <span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The configurable parameters are as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">webXmlFragment</dt>
<dd>
<p>Default value: <code>${project.basedir}/target/webfrag.xml</code></p>
<div class="paragraph">
<p>File into which to generate the servlet declarations.
Will be merged with an existing <code>web.xml</code>.</p>
</div>
</dd>
<dt class="hdlist1">webAppSourceDirectory</dt>
<dd>
<p>Default value: <code>${project.basedir}/src/main/webapp</code></p>
<div class="paragraph">
<p>Root of resources directory where jsps, tags etc are located.</p>
</div>
</dd>
<dt class="hdlist1">webXml</dt>
<dd>
<p>Default value: <code>${project.basedir}/src/main/webapp/WEB-INF/web.xml</code></p>
<div class="paragraph">
<p>The web.xml file to use to merge with the generated fragments.</p>
</div>
</dd>
<dt class="hdlist1">includes</dt>
<dd>
<p>Default value: <code>**/*.jsp, **/*.jspx</code></p>
<div class="paragraph">
<p>The comma separated list of patterns for file extensions to be processed.</p>
</div>
</dd>
<dt class="hdlist1">excludes</dt>
<dd>
<p>Default value: <code>**/.svn/**</code></p>
<div class="paragraph">
<p>The comma separated list of patterns for file extensions to be skipped.</p>
</div>
</dd>
<dt class="hdlist1">classesDirectory</dt>
<dd>
<p>Default value: <code>${project.build.outputDirectory}</code></p>
<div class="paragraph">
<p>Location of classes for the webapp.</p>
</div>
</dd>
<dt class="hdlist1">generatedClasses</dt>
<dd>
<p>Default value: <code>${project.build.outputDirectory}</code></p>
<div class="paragraph">
<p>Location to put the generated classes for the jsps.</p>
</div>
</dd>
<dt class="hdlist1">insertionMarker</dt>
<dd>
<p>Default value: <em>none</em></p>
<div class="paragraph">
<p>A marker string in the src <code>web.xml</code> file which indicates where to merge in the generated web.xml fragment.
Note that the marker string will NOT be preserved during the insertion.
Can be left blank, in which case the generated fragment is inserted just before the line containing <code>&lt;/web-app&gt;</code>.</p>
</div>
</dd>
<dt class="hdlist1">useProvidedScope</dt>
<dd>
<p>Default value: false</p>
<div class="paragraph">
<p>If true, jars of dependencies marked with &lt;scope&gt;provided&lt;/scope&gt; will be placed on the compilation classpath.</p>
</div>
</dd>
<dt class="hdlist1">mergeFragment</dt>
<dd>
<p>Default value: true</p>
<div class="paragraph">
<p>Whether or not to merge the generated fragment file with the source web.xml.
The merged file will go into the same directory as the webXmlFragment.</p>
</div>
</dd>
<dt class="hdlist1">keepSources</dt>
<dd>
<p>Default value: false</p>
<div class="paragraph">
<p>If true, the generated .java files are not deleted at the end of processing.</p>
</div>
</dd>
<dt class="hdlist1">scanAllDirectories</dt>
<dd>
<p>Default value: true</p>
<div class="paragraph">
<p>Determines if dirs on the classpath should be scanned as well as jars.
If true, this allows scanning for tlds of dependent projects that
are in the reactor as unassembled jars.</p>
</div>
</dd>
<dt class="hdlist1">scanManifest</dt>
<dd>
<p>Default value: true</p>
<div class="paragraph">
<p>Determines if the manifest of JAR files found on the classpath should be scanned.</p>
</div>
</dd>
<dt class="hdlist1">sourceVersion</dt>
<dd>
<p>Java version of jsp source files.
The default value depends on the version of the <code>jetty-ee10-jspc-maven-plugin</code>.</p>
</dd>
<dt class="hdlist1">targetVersion</dt>
<dd>
<p>Java version of class files generated from jsps.
The default value depends on the version of the <code>jetty-ee10-jspc-maven-plugin</code>.</p>
</dd>
<dt class="hdlist1">tldJarNamePatterns</dt>
<dd>
<p>Default value: <code>.*taglibs[^/]*\.jar|.*jstl[^/]*\.jar$</code></p>
<div class="paragraph">
<p>Patterns of jars on the 'system' (ie container) path that contain tlds.
Use | to separate each pattern.</p>
</div>
</dd>
<dt class="hdlist1">jspc</dt>
<dd>
<p>Default value: the <code>org.apache.jasper.JspC</code> instance being configured.</p>
<div class="paragraph">
<p>The JspC class actually performs the pre-compilation.
All setters on the JspC class are available.</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Taking all the default settings, here&#8217;s how to configure the war plugin to use the generated <code>web.xml</code> that includes all of the jsp servlet declarations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>maven-war-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;configuration&gt;</span>
    <span class="tag">&lt;webXml&gt;</span>${project.basedir}/target/web.xml<span class="tag">&lt;/webXml&gt;</span>
  <span class="tag">&lt;/configuration&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jspc-production-precompile"><a class="anchor" href="#jspc-production-precompile"></a><a class="link" href="#jspc-production-precompile">Precompiling only for Production Build</a></h4>
<div class="paragraph">
<p>As compiling jsps is usually done during preparation for a production release and not usually done during development, it is more convenient to put the plugin setup inside a &lt;profile&gt; which which can be deliberately invoked during prep for production.</p>
</div>
<div class="paragraph">
<p>For example, the following profile will only be invoked if the flag <code>-Dprod</code> is present on the run line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;profiles&gt;</span>
  <span class="tag">&lt;profile&gt;</span>
    <span class="tag">&lt;id&gt;</span>prod<span class="tag">&lt;/id&gt;</span>
    <span class="tag">&lt;activation&gt;</span>
      <span class="tag">&lt;property&gt;</span><span class="tag">&lt;name&gt;</span>prod<span class="tag">&lt;/name&gt;</span><span class="tag">&lt;/property&gt;</span>
    <span class="tag">&lt;/activation&gt;</span>
    <span class="tag">&lt;build&gt;</span>
    <span class="tag">&lt;plugins&gt;</span>
      <span class="tag">&lt;plugin&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-jspc-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
        <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
        <span class="comment">&lt;!-- put your configuration in here --&gt;</span>
      <span class="tag">&lt;/plugin&gt;</span>
      <span class="tag">&lt;plugin&gt;</span>
        <span class="tag">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/groupId&gt;</span>
        <span class="tag">&lt;artifactId&gt;</span>maven-war-plugin<span class="tag">&lt;/artifactId&gt;</span>
        <span class="comment">&lt;!-- put your configuration in here --&gt;</span>
      <span class="tag">&lt;/plugin&gt;</span>
    <span class="tag">&lt;/plugins&gt;</span>
    <span class="tag">&lt;/build&gt;</span>
  <span class="tag">&lt;/profile&gt;</span>
<span class="tag">&lt;/profiles&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The following invocation would cause your code to be compiled, the jsps to be compiled, the &lt;servlet&gt; and &lt;servlet-mapping&gt;s inserted in the <code>web.xml</code> and your webapp assembled into a war:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ mvn -Dprod package</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jspc-overlay-precompile"><a class="anchor" href="#jspc-overlay-precompile"></a><a class="link" href="#jspc-overlay-precompile">Precompiling Jsps with Overlaid Wars</a></h4>
<div class="paragraph">
<p>Precompiling jsps with an overlaid war requires a bit more configuration.
This is because you need to separate the steps of unpacking the overlaid war and then repacking the final target war so the <code>jetty-ee10-jspc-maven-plugin</code> has the opportunity to access the overlaid resources.</p>
</div>
<div class="paragraph">
<p>In the following example the overlaid war will provide the <code>web.xml</code> file but the jsps will be in <code>src/main/webapp</code> (i.e. part of the project that uses the overlay).
The overlaid war file will be unpacked, the jsps compiled and their servlet definitions merged into the extracted <code>web.xml</code>, and everything packed into a war.</p>
</div>
<div class="paragraph">
<p>An example configuration of the war plugin that separates those phases into an unpack phase, and then a packing phase:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>maven-war-plugin<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;executions&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;id&gt;</span>unpack<span class="tag">&lt;/id&gt;</span>
      <span class="tag">&lt;goals&gt;</span><span class="tag">&lt;goal&gt;</span>exploded<span class="tag">&lt;/goal&gt;</span><span class="tag">&lt;/goals&gt;</span>
      <span class="tag">&lt;phase&gt;</span>generate-resources<span class="tag">&lt;/phase&gt;</span>
      <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;webappDirectory&gt;</span>target/foo<span class="tag">&lt;/webappDirectory&gt;</span>
        <span class="tag">&lt;overlays&gt;</span>
          <span class="tag">&lt;overlay</span> <span class="tag">/&gt;</span>
          <span class="tag">&lt;overlay&gt;</span>
            <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.{ee-current}.demos<span class="tag">&lt;/groupId&gt;</span>
            <span class="tag">&lt;artifactId&gt;</span>jetty-{ee-current}-demo-jetty-webapp<span class="tag">&lt;/artifactId&gt;</span>
          <span class="tag">&lt;/overlay&gt;</span>
        <span class="tag">&lt;/overlays&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
    <span class="tag">&lt;execution&gt;</span>
      <span class="tag">&lt;id&gt;</span>pack<span class="tag">&lt;/id&gt;</span>
      <span class="tag">&lt;goals&gt;</span><span class="tag">&lt;goal&gt;</span>war<span class="tag">&lt;/goal&gt;</span><span class="tag">&lt;/goals&gt;</span>
      <span class="tag">&lt;phase&gt;</span>package<span class="tag">&lt;/phase&gt;</span>
      <span class="tag">&lt;configuration&gt;</span>
        <span class="tag">&lt;warSourceDirectory&gt;</span>target/foo<span class="tag">&lt;/warSourceDirectory&gt;</span>
        <span class="tag">&lt;webXml&gt;</span>target/web.xml<span class="tag">&lt;/webXml&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
  <span class="tag">&lt;/executions&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you also need to configure the <code>jetty-ee10-jspc-maven-plugin</code> so that it can use the web.xml that was extracted by the war unpacking and merge in the generated definitions of the servlets.
This is in <code>target/foo/WEB-INF/web.xml</code>.
Using the default settings, the <code>web.xml</code> merged with the jsp servlet definitions will be put into <code>target/web.xml</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;plugin&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty.ee10<span class="tag">&lt;/groupId&gt;</span>
   <span class="tag">&lt;artifactId&gt;</span>jetty-ee10-jspc-maven-plugin<span class="tag">&lt;/artifactId&gt;</span>
   <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
   <span class="tag">&lt;executions&gt;</span>
     <span class="tag">&lt;execution&gt;</span>
       <span class="tag">&lt;id&gt;</span>jspc<span class="tag">&lt;/id&gt;</span>
       <span class="tag">&lt;goals&gt;</span>
         <span class="tag">&lt;goal&gt;</span>jspc<span class="tag">&lt;/goal&gt;</span>
       <span class="tag">&lt;/goals&gt;</span>
       <span class="tag">&lt;configuration&gt;</span>
          <span class="tag">&lt;webXml&gt;</span>target/foo/WEB-INF/web.xml<span class="tag">&lt;/webXml&gt;</span>
          <span class="tag">&lt;includes&gt;</span>**/*.foo<span class="tag">&lt;/includes&gt;</span>
          <span class="tag">&lt;excludes&gt;</span>**/*.fff<span class="tag">&lt;/excludes&gt;</span>
      <span class="tag">&lt;/configuration&gt;</span>
    <span class="tag">&lt;/execution&gt;</span>
  <span class="tag">&lt;/executions&gt;</span>
<span class="tag">&lt;/plugin&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pg-arch"><a class="anchor" href="#pg-arch"></a><a class="link" href="#pg-arch">Appendix A: Jetty Architecture</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="pg-arch-bean"><a class="anchor" href="#pg-arch-bean"></a><a class="link" href="#pg-arch-bean">Jetty Component Architecture</a></h3>
<div class="paragraph">
<p>Applications that use the Jetty libraries (both client and server) create objects from Jetty classes and compose them together to obtain the desired functionalities.</p>
</div>
<div class="paragraph">
<p>A client application creates a <code>ClientConnector</code> instance, a <code>HttpClientTransport</code> instance and an <code>HttpClient</code> instance and compose them to have a working HTTP client that uses to call third party services.</p>
</div>
<div class="paragraph">
<p>A server application creates a <code>ThreadPool</code> instance, a <code>Server</code> instance, a <code>ServerConnector</code> instance, a <code>Handler</code> instance and compose them together to expose an HTTP service.</p>
</div>
<div class="paragraph">
<p>Internally, the Jetty libraries create even more instances of other components that also are composed together with the main ones created by applications.</p>
</div>
<div class="paragraph">
<p>The end result is that an application based on the Jetty libraries is a <em>tree</em> of components.
In server application the root of the component tree is a <code>Server</code> instance, while in client applications the root of the component tree is an <code>HttpClient</code> instance.</p>
</div>
<div class="paragraph">
<p>Having all the Jetty components in a tree is beneficial in a number of use cases.
It makes possible to register the components in the tree as <a href="#pg-arch-jmx">JMX MBeans</a> so that a JMX console can look at the internal state of the components.
It also makes possible to <a href="#pg-troubleshooting-component-dump">dump the component tree</a> (and therefore each component&#8217;s internal state) to a log file or to the console for <a href="#pg-troubleshooting">troubleshooting purposes</a>.</p>
</div>
<div class="sect3">
<h4 id="pg-arch-bean-lifecycle"><a class="anchor" href="#pg-arch-bean-lifecycle"></a><a class="link" href="#pg-arch-bean-lifecycle">Jetty Component Lifecycle</a></h4>
<div class="paragraph">
<p>Jetty components typically have a life cycle: they can be started and stopped.
The Jetty components that have a life cycle implement the <code>org.eclipse.jetty.util.component.LifeCycle</code> interface.</p>
</div>
<div class="paragraph">
<p>Jetty components that contain other components implement the <code>org.eclipse.jetty.util.component.Container</code> interface and typically extend the <code>org.eclipse.jetty.util.component.ContainerLifeCycle</code> class.
<code>ContainerLifeCycle</code> can contain these type of components, also called <em>bean</em>s:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>managed</em> beans, <code>LifeCycle</code> instances whose life cycle is tied to the life cycle of their container</p>
</li>
<li>
<p><em>unmanaged</em> beans, <code>LifeCycle</code> instances whose life cycle is <em>not</em> tied to the life cycle of their container</p>
</li>
<li>
<p><em>POJO</em> (Plain Old Java Object) beans, instances that do not implement <code>LifeCycle</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ContainerLifeCycle</code> uses the following logic to determine if a bean should be <em>managed</em>, <em>unmanaged</em> or <em>POJO</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the bean implements <code>LifeCycle</code></p>
<div class="ulist">
<ul>
<li>
<p>the bean is not started, add it as <em>managed</em></p>
</li>
<li>
<p>the bean is started, add it as <em>unmanaged</em></p>
</li>
</ul>
</div>
</li>
<li>
<p>the bean does not implement <code>LifeCycle</code>, add it as <em>POJO</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a <code>ContainerLifeCycle</code> is started, it also starts recursively all its managed beans (if they implement <code>LifeCycle</code>); unmanaged beans are not started during the <code>ContainerLifeCycle</code> start cycle.
Likewise, stopping a <code>ContainerLifeCycle</code> stops recursively and in reverse order all its managed beans; unmanaged beans are not stopped during the <code>ContainerLifeCycle</code> stop cycle.</p>
</div>
<div class="paragraph">
<p>Components can also be started and stopped individually, therefore activating or deactivating the functionalities that they offer.</p>
</div>
<div class="paragraph">
<p>Applications should first compose components in the desired structure, and then start the root component:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Monitor</span> <span class="directive">extends</span> AbstractLifeCycle
{
}

<span class="type">class</span> <span class="class">Root</span> <span class="directive">extends</span> ContainerLifeCycle
{
    <span class="comment">// Monitor is an internal component.</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Monitor</span> monitor = <span class="keyword">new</span> <span class="predefined-type">Monitor</span>();

    <span class="directive">public</span> Root()
    {
        <span class="comment">// The Monitor life cycle is managed by Root.</span>
        addManaged(monitor);
    }
}

<span class="type">class</span> <span class="class">Service</span> <span class="directive">extends</span> ContainerLifeCycle
{
    <span class="comment">// An instance of the Java scheduler service.</span>
    <span class="directive">private</span> <span class="predefined-type">ScheduledExecutorService</span> scheduler;

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStart() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Java's schedulers cannot be restarted, so they must</span>
        <span class="comment">// be created anew every time their container is started.</span>
        scheduler = <span class="predefined-type">Executors</span>.newSingleThreadScheduledExecutor();
        <span class="comment">// Even if Java scheduler does not implement</span>
        <span class="comment">// LifeCycle, make it part of the component tree.</span>
        addBean(scheduler);
        <span class="comment">// Start all the children beans.</span>
        <span class="local-variable">super</span>.doStart();
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStop() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Perform the opposite operations that were</span>
        <span class="comment">// performed in doStart(), in reverse order.</span>
        <span class="local-variable">super</span>.doStop();
        removeBean(scheduler);
        scheduler.shutdown();
    }
}

<span class="comment">// Create a Root instance.</span>
Root root = <span class="keyword">new</span> Root();

<span class="comment">// Create a Service instance.</span>
Service service = <span class="keyword">new</span> Service();

<span class="comment">// Link the components.</span>
root.addBean(service);

<span class="comment">// Start the root component to</span>
<span class="comment">// start the whole component tree.</span>
root.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The component tree is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">Root
├── Monitor (MANAGED)
└── Service (MANAGED)
    └── ScheduledExecutorService (POJO)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>Root</code> instance is created, also the <code>Monitor</code> instance is created and added as bean, so <code>Monitor</code> is the first bean of <code>Root</code>.
<code>Monitor</code> is a <em>managed</em> bean, because it has been explicitly added to <code>Root</code> via <code>ContainerLifeCycle.addManaged(&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>Then, the application creates a <code>Service</code> instance and adds it to <code>Root</code> via <code>ContainerLifeCycle.addBean(&#8230;&#8203;)</code>, so <code>Service</code> is the second bean of <code>Root</code>.
<code>Service</code> is a <em>managed</em> bean too, because it is a <code>LifeCycle</code> and at the time it was added to <code>Root</code> is was not started.</p>
</div>
<div class="paragraph">
<p>The <code>ScheduledExecutorService</code> within <code>Service</code> does not implement <code>LifeCycle</code> so it is added as a <em>POJO</em> to <code>Service</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to stop and re-start any component in a tree, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Root</span> <span class="directive">extends</span> ContainerLifeCycle
{
}

<span class="type">class</span> <span class="class">Service</span> <span class="directive">extends</span> ContainerLifeCycle
{
    <span class="comment">// An instance of the Java scheduler service.</span>
    <span class="directive">private</span> <span class="predefined-type">ScheduledExecutorService</span> scheduler;

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStart() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Java's schedulers cannot be restarted, so they must</span>
        <span class="comment">// be created anew every time their container is started.</span>
        scheduler = <span class="predefined-type">Executors</span>.newSingleThreadScheduledExecutor();
        <span class="comment">// Even if Java scheduler does not implement</span>
        <span class="comment">// LifeCycle, make it part of the component tree.</span>
        addBean(scheduler);
        <span class="comment">// Start all the children beans.</span>
        <span class="local-variable">super</span>.doStart();
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStop() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Perform the opposite operations that were</span>
        <span class="comment">// performed in doStart(), in reverse order.</span>
        <span class="local-variable">super</span>.doStop();
        removeBean(scheduler);
        scheduler.shutdown();
    }
}

Root root = <span class="keyword">new</span> Root();
Service service = <span class="keyword">new</span> Service();
root.addBean(service);

<span class="comment">// Start the Root component.</span>
root.start();

<span class="comment">// Stop temporarily Service without stopping the Root.</span>
service.stop();

<span class="comment">// Restart Service.</span>
service.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Service</code> can be stopped independently of <code>Root</code>, and re-started.
Starting and stopping a non-root component does not alter the structure of the component tree, just the state of the subtree starting from the component that has been stopped and re-started.</p>
</div>
<div class="paragraph">
<p><code>Container</code> provides an API to find beans in the component tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Root</span> <span class="directive">extends</span> ContainerLifeCycle
{
}

<span class="type">class</span> <span class="class">Service</span> <span class="directive">extends</span> ContainerLifeCycle
{
    <span class="directive">private</span> <span class="predefined-type">ScheduledExecutorService</span> scheduler;

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStart() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        scheduler = <span class="predefined-type">Executors</span>.newSingleThreadScheduledExecutor();
        addBean(scheduler);
        <span class="local-variable">super</span>.doStart();
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> doStop() <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="local-variable">super</span>.doStop();
        removeBean(scheduler);
        scheduler.shutdown();
    }
}

Root root = <span class="keyword">new</span> Root();
Service service = <span class="keyword">new</span> Service();
root.addBean(service);

<span class="comment">// Start the Root component.</span>
root.start();

<span class="comment">// Find all the direct children of root.</span>
<span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Object</span>&gt; children = root.getBeans();
<span class="comment">// children contains only service</span>

<span class="comment">// Find all descendants of root that are instance of a particular class.</span>
<span class="predefined-type">Collection</span>&lt;<span class="predefined-type">ScheduledExecutorService</span>&gt; schedulers = root.getContainedBeans(<span class="predefined-type">ScheduledExecutorService</span>.class);
<span class="comment">// schedulers contains the service scheduler.</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can add your own beans to the component tree at application startup time, and later find them from your application code to access their services.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The component tree should be used for long-lived or medium-lived components such as thread pools, web application contexts, etc.</p>
</div>
<div class="paragraph">
<p>It is not recommended adding to, and removing from, the component tree short-lived objects such as HTTP requests or TCP connections, for performance reasons.</p>
</div>
<div class="paragraph">
<p>If you need component tree features such as automatic <a href="#pg-arch-jmx">export to JMX</a> or <a href="#pg-troubleshooting-component-dump">dump capabilities</a> for short-lived objects, consider having a long-lived container in the component tree instead.
You can make the long-lived container efficient at adding/removing the short-lived components using a data structure that is not part of the component tree, and make the long-lived container handle the JMX and dump features for the short-lived components.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-bean-listener"><a class="anchor" href="#pg-arch-bean-listener"></a><a class="link" href="#pg-arch-bean-listener">Jetty Component Listeners</a></h4>
<div class="paragraph">
<p>A component that extends <code>AbstractLifeCycle</code> inherits the possibility to add/remove event <em>listeners</em> for various events emitted by components.</p>
</div>
<div class="paragraph">
<p>A component that implements <code>java.util.EventListener</code> that is added to a <code>ContainerLifeCycle</code> is also registered as an event listener.</p>
</div>
<div class="paragraph">
<p>The following sections describe in details the various listeners available in the Jetty component architecture.</p>
</div>
<div class="sect4">
<h5 id="pg-arch-bean-listener-lifecycle"><a class="anchor" href="#pg-arch-bean-listener-lifecycle"></a><a class="link" href="#pg-arch-bean-listener-lifecycle">LifeCycle.Listener</a></h5>
<div class="paragraph">
<p>A <code>LifeCycle.Listener</code> emits events for life cycle events such as starting, stopping and failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Add an event listener of type LifeCycle.Listener.</span>
server.addEventListener(<span class="keyword">new</span> LifeCycle.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> lifeCycleStarted(LifeCycle lifeCycle)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Server {0} has been started</span><span class="delimiter">&quot;</span></span>, lifeCycle);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> lifeCycleFailure(LifeCycle lifeCycle, <span class="predefined-type">Throwable</span> failure)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Server {0} failed to start</span><span class="delimiter">&quot;</span></span>, lifeCycle, failure);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> lifeCycleStopped(LifeCycle lifeCycle)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Server {0} has been stopped</span><span class="delimiter">&quot;</span></span>, lifeCycle);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, a life cycle listener attached to a <code>Server</code> instance could be used to create (for the <em>started</em> event) and delete (for the <em>stopped</em> event) a file containing the process ID of the JVM that runs the <code>Server</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-bean-listener-container"><a class="anchor" href="#pg-arch-bean-listener-container"></a><a class="link" href="#pg-arch-bean-listener-container">Container.Listener</a></h5>
<div class="paragraph">
<p>A component that implements <code>Container</code> is a container for other components and <code>ContainerLifeCycle</code> is the typical implementation.</p>
</div>
<div class="paragraph">
<p>A <code>Container</code> emits events when a component (also called <em>bean</em>) is added to or removed from the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Add an event listener of type LifeCycle.Listener.</span>
server.addEventListener(<span class="keyword">new</span> <span class="predefined-type">Container</span>.Listener()
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> beanAdded(<span class="predefined-type">Container</span> parent, <span class="predefined-type">Object</span> child)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Added bean {1} to {0}</span><span class="delimiter">&quot;</span></span>, parent, child);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> beanRemoved(<span class="predefined-type">Container</span> parent, <span class="predefined-type">Object</span> child)
    {
        <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">server</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">Removed bean {1} from {0}</span><span class="delimiter">&quot;</span></span>, parent, child);
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>Container.Listener</code> added as a bean will also be registered as a listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Parent</span> <span class="directive">extends</span> ContainerLifeCycle
{
}

<span class="type">class</span> <span class="class">Child</span>
{
}

<span class="comment">// The older child takes care of its siblings.</span>
<span class="type">class</span> <span class="class">OlderChild</span> <span class="directive">extends</span> Child <span class="directive">implements</span> <span class="predefined-type">Container</span>.Listener
{
    <span class="directive">private</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Object</span>&gt; siblings = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> beanAdded(<span class="predefined-type">Container</span> parent, <span class="predefined-type">Object</span> child)
    {
        siblings.add(child);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> beanRemoved(<span class="predefined-type">Container</span> parent, <span class="predefined-type">Object</span> child)
    {
        siblings.remove(child);
    }
}

Parent parent = <span class="keyword">new</span> Parent();

Child older = <span class="keyword">new</span> OlderChild();
<span class="comment">// The older child is a child bean _and_ a listener.</span>
parent.addBean(older);

Child younger = <span class="keyword">new</span> Child();
<span class="comment">// Adding a younger child will notify the older child.</span>
parent.addBean(younger);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-bean-listener-inherited"><a class="anchor" href="#pg-arch-bean-listener-inherited"></a><a class="link" href="#pg-arch-bean-listener-inherited">Container.InheritedListener</a></h5>
<div class="paragraph">
<p>A <code>Container.InheritedListener</code> is a listener that will be added to all descendants that are also <code>Container</code>s.</p>
</div>
<div class="paragraph">
<p>Listeners of this type may be added to the component tree root only, but will be notified of every descendant component that is added to or removed from the component tree (not only first level children).</p>
</div>
<div class="paragraph">
<p>The primary use of <code>Container.InheritedListener</code> within the Jetty Libraries is <code>MBeanContainer</code> from the <a href="#pg-arch-jmx">Jetty JMX support</a>.</p>
</div>
<div class="paragraph">
<p><code>MBeanContainer</code> listens for every component added to the tree, converts it to an MBean and registers it to the MBeanServer; for every component removed from the tree, it unregisters the corresponding MBean from the MBeanServer.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-arch-threads"><a class="anchor" href="#pg-arch-threads"></a><a class="link" href="#pg-arch-threads">Jetty Threading Architecture</a></h3>
<div class="paragraph">
<p>Writing a performant client or server is difficult, because it should:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scale well with the number of processors.</p>
</li>
<li>
<p>Be efficient at using processor caches to avoid <a href="https://en.wikipedia.org/wiki/Parallel_slowdown">parallel slowdown</a>.</p>
</li>
<li>
<p>Support multiple network protocols that may have very different requirements; for example, multiplexed protocols such as HTTP/2 introduce new challenges that are not present in non-multiplexed protocols such as HTTP/1.1.</p>
</li>
<li>
<p>Support different application threading models; for example, if a Jetty server invokes server-side application code that is allowed to call blocking APIs, then the Jetty server should not be affected by how long the blocking API call takes, and should be able to process other connections or other requests in a timely fashion.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="pg-arch-threads-execution-strategy"><a class="anchor" href="#pg-arch-threads-execution-strategy"></a><a class="link" href="#pg-arch-threads-execution-strategy">Execution Strategies</a></h4>
<div class="paragraph">
<p>The Jetty threading architecture can be modeled with a producer/consumer pattern, where produced tasks needs to be consumed efficiently.</p>
</div>
<div class="paragraph">
<p>For example, Jetty produces (among others) these tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A task that wraps a NIO selection event, see the <a href="#pg-arch-io">Jetty I/O architecture</a>.</p>
</li>
<li>
<p>A task that wraps the invocation of application code that may block (for example, the invocation of a Servlet to handle an HTTP request).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A task is typically a <code>Runnable</code> object that may implement <code>org.eclipse.jetty.util.thread.Invocable</code> to indicate the behavior of the task (in particular, whether the task may block or not).</p>
</div>
<div class="paragraph">
<p>Once a task has been produced, it may be consumed using these modes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pg-arch-threads-execution-strategy-pc"><code>Produce-Consume</code></a></p>
</li>
<li>
<p><a href="#pg-arch-threads-execution-strategy-pec"><code>Produce-Execute-Consume</code></a></p>
</li>
<li>
<p><a href="#pg-arch-threads-execution-strategy-epc"><code>Execute-Produce-Consume</code></a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-execution-strategy-pc"><a class="anchor" href="#pg-arch-threads-execution-strategy-pc"></a><a class="link" href="#pg-arch-threads-execution-strategy-pc">Produce-Consume</a></h5>
<div class="paragraph">
<p>In the <code>Produce-Consume</code> mode, the producer thread loops to produce a task that is run directly by the <code>Producer Thread</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-00328cb3d2df8187923760470ae4b579.png" alt="Diagram" width="825" height="61">
</div>
</div>
<div class="paragraph">
<p>If the task is a NIO selection event, then this mode is the thread-per-selector mode which is very CPU core cache efficient, but suffers from the <a href="http://en.wikipedia.org/wiki/Head-of-line_blocking">head-of-line blocking</a>: if one of the tasks blocks or runs slowly, then subsequent tasks cannot be produced (and therefore cannot be consumed either) and will pay in latency the cost of running previous, possibly unrelated, tasks.</p>
</div>
<div class="paragraph">
<p>This mode should only be used if the produced task is known to never block, or if the system tolerates well (or does not care about) head-of-line blocking.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-execution-strategy-pec"><a class="anchor" href="#pg-arch-threads-execution-strategy-pec"></a><a class="link" href="#pg-arch-threads-execution-strategy-pec">Produce-Execute-Consume</a></h5>
<div class="paragraph">
<p>In the <code>Produce-Execute-Consume</code> mode, the <code>Producer Thread</code> loops to produce tasks that are submitted to a <code>java.util.concurrent.Executor</code> to be run by <code>Worker Thread</code>s different from the <code>Producer Thread</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-624524d586ade94fb3c1aaff2ce724bc.png" alt="Diagram" width="625" height="181">
</div>
</div>
<div class="paragraph">
<p>The <code>Executor</code> implementation typically adds the task to a queue, and dequeues the task when there is a worker thread available to run it.</p>
</div>
<div class="paragraph">
<p>This mode solves the head-of-line blocking discussed in the <a href="#pg-arch-threads-execution-strategy-pc"><code>Produce-Consume</code> section</a>, but suffers from other issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is not CPU core cache efficient, as the data available to the producer thread will need to be accessed by another thread that likely is going to run on a CPU core that will not have that data in its caches.</p>
</li>
<li>
<p>If the tasks take time to be run, the <code>Executor</code> queue may grow indefinitely.</p>
</li>
<li>
<p>A small latency is added to every task: the time it waits in the <code>Executor</code> queue.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-execution-strategy-epc"><a class="anchor" href="#pg-arch-threads-execution-strategy-epc"></a><a class="link" href="#pg-arch-threads-execution-strategy-epc">Execute-Produce-Consume</a></h5>
<div class="paragraph">
<p>In the <code>Execute-Produce-Consume</code> mode, the producer thread <code>Thread 1</code> loops to produce a task, then submits one internal task to an <code>Executor</code> to take over production on thread <code>Thread 2</code>, and then runs the task in <code>Thread 1</code>, and so on.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/diag-plantuml-md5-2186143f423f5fb7696a7e6e67d9a227.png" alt="Diagram" width="662" height="181">
</div>
</div>
<div class="paragraph">
<p>This mode may operate like <a href="#pg-arch-threads-execution-strategy-pc"><code>Produce-Consume</code></a> when the take over production task run, for example, by thread <code>Thread 3</code> takes time to be executed (for example, in a busy server): then thread <code>Thread 2</code> will produce one task and run it, then produce another task and run it, etc.&#8201;&#8212;&#8201;<code>Thread 2</code> behaves exactly like the <code>Produce-Consume</code> mode.
By the time thread <code>Thread 3</code> takes over task production from <code>Thread 2</code>, all the work might already be done.</p>
</div>
<div class="paragraph">
<p>This mode may also operate similarly to <a href="#pg-arch-threads-execution-strategy-pec"><code>Produce-Execute-Consume</code></a> when the take over production task always finds a free CPU core immediately (for example, in a mostly idle server): thread <code>Thread 1</code> will produce a task, yield production to <code>Thread 2</code> while <code>Thread 1</code> is running the task; <code>Thread 2</code> will produce a task, yield production to <code>Thread 3</code> while <code>Thread 2</code> is running the task, etc.</p>
</div>
<div class="paragraph">
<p>Differently from <code>Produce-Execute-Consume</code>, here production happens on different threads, but the advantage is that the task is run by the same thread that produced it (which is CPU core cache efficient).</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-execution-strategy-adaptive"><a class="anchor" href="#pg-arch-threads-execution-strategy-adaptive"></a><a class="link" href="#pg-arch-threads-execution-strategy-adaptive">Adaptive Execution Strategy</a></h5>
<div class="paragraph">
<p>The modes of task consumption discussed above are captured by the <code>org.eclipse.jetty.util.thread.ExecutionStrategy</code> interface, with an additional implementation that also takes into account the behavior of the task when the task implements <code>Invocable</code>.</p>
</div>
<div class="paragraph">
<p>For example, a task that declares itself as non-blocking can be consumed using the <code>Produce-Consume</code> mode, since there is no risk to stop production because the task will not block.</p>
</div>
<div class="paragraph">
<p>Conversely, a task that declares itself as blocking will stop production, and therefore must be consumed using either the <code>Produce-Execute-Consume</code> mode or the <code>Execute-Produce-Consume</code> mode.
Deciding between these two modes depends on whether there is a free thread immediately available to take over production, and this is captured by the <code>org.eclipse.jetty.util.thread.TryExecutor</code> interface.</p>
</div>
<div class="paragraph">
<p>An implementation of <code>TryExecutor</code> can be asked whether a thread can be immediately and exclusively allocated to run a task, as opposed to a normal <code>Executor</code> that can only queue the task in the expectation that there will be a thread available in the near future to run the task.</p>
</div>
<div class="paragraph">
<p>The concept of task consumption modes, coupled with <code>Invocable</code> tasks that expose their own behavior, coupled with a <code>TryExecutor</code> that guarantees whether production can be immediately taken over are captured by the default Jetty execution strategy, named <code>org.eclipse.jetty.util.thread.AdaptiveExecutionStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>AdaptiveExecutionStrategy</code> was previously named <code>EatWhatYouKill</code>, named after a hunting proverb in the sense that one should produce (kill) only what it consumes (eats).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-threads-thread-pool"><a class="anchor" href="#pg-arch-threads-thread-pool"></a><a class="link" href="#pg-arch-threads-thread-pool">Thread Pool</a></h4>
<div class="paragraph">
<p>Jetty&#8217;s <a href="#pg-arch-threads">threading architecture</a> requires a more sophisticated thread pool than what offered by Java&#8217;s <code>java.util.concurrent.ExecutorService</code>.</p>
</div>
<div class="paragraph">
<p>Jetty&#8217;s default thread pool implementation is <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/util/thread/QueuedThreadPool.html"><code>QueuedThreadPool</code></a>.</p>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool</code> integrates with the <a href="#pg-arch-bean">Jetty component model</a>, implements <code>Executor</code>, provides a <code>TryExecutor</code> implementation (discussed in the <a href="#pg-arch-threads-execution-strategy-adaptive">adaptive execution strategy section</a>), and supports <a href="#pg-arch-threads-thread-pool-virtual-threads">virtual threads</a> (introduced as a preview feature in Java 19 and Java 20, and as an official feature since Java 21).</p>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-thread-pool-queue"><a class="anchor" href="#pg-arch-threads-thread-pool-queue"></a><a class="link" href="#pg-arch-threads-thread-pool-queue">Thread Pool Queue</a></h5>
<div class="paragraph">
<p><code>QueuedThreadPool</code> uses a <code>BlockingQueue</code> to store tasks that will be executed as soon as a thread is available.</p>
</div>
<div class="paragraph">
<p>It is common, but too simplistic, to think that an upper bound to the thread pool queue is a good way to limit the number of concurrent HTTP requests.</p>
</div>
<div class="paragraph">
<p>In case of asynchronous servers like Jetty, applications may have more than one thread handling a single request.
Furthermore, the server implementation may produce a number of tasks that <em>must</em> be run by the thread pool, otherwise the server stops working properly.</p>
</div>
<div class="paragraph">
<p>Therefore, the "one-thread-per-request" model is too simplistic, and the real model that predicts the number of threads that are necessary is too complicated to produce an accurate value.</p>
</div>
<div class="paragraph">
<p>For example, a sudden large spike of requests arriving to the server may find the thread pool in an idle state where the number of threads is shrunk to the minimum.
This will cause many tasks to be queued up, way before an HTTP request is even read from the network.
Add to this that there could be I/O failures processing requests, which may be submitted as a new task to the thread pool.
Furthermore, multiplexed protocols like HTTP/2 have a much more complex model (due to <a href="#pg-server-http2-flow-control">data flow control</a>).
For multiplexed protocols, the implementation must be able to write in order to progress reads (and must be able to read in order to progress writes), possibly causing more tasks to be submitted to the thread pool.</p>
</div>
<div class="paragraph">
<p>If any of the submitted tasks is rejected because the queue is bounded the server may grind to a halt, because the task <em>must</em> be executed, sometimes <em>necessarily</em> in a different thread.</p>
</div>
<div class="paragraph">
<p>For these reasons:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The thread pool queue must be unbounded.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are better strategies to limit the number of concurrent requests, discussed in <a href="#pg-server-http-handler-use-qos">this section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-thread-pool-configuration"><a class="anchor" href="#pg-arch-threads-thread-pool-configuration"></a><a class="link" href="#pg-arch-threads-thread-pool-configuration"><code>QueuedThreadPool</code> configuration</a></h5>
<div class="paragraph">
<p><code>QueuedThreadPool</code> can be configured with a <code>maxThreads</code> value.</p>
</div>
<div class="paragraph">
<p>However, some of the Jetty components (such as the <a href="#pg-arch-io-selector-manager">selectors</a>) permanently steal threads for their internal use, or rather <code>QueuedThreadPool</code> leases some threads to these components.
These threads are reported by <code>QueuedThreadPool.leasedThreads</code> and are not available to run application code.</p>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool</code> can be configured with a <code>reservedThreads</code> value.
This value represents the maximum number of threads that can be reserved and used by the <code>TryExecutor</code> implementation.
A negative value for <code>QueuedThreadPool.reservedThreads</code> means that the actual value will be heuristically derived from the number of CPU cores and <code>QueuedThreadPool.maxThreads</code>.
A value of zero for <code>QueuedThreadPool.reservedThreads</code> means that reserved threads are disabled, and therefore the <a href="#pg-arch-threads-execution-strategy-epc"><code>Execute-Produce-Consume</code> mode</a> is never used&#8201;&#8212;&#8201;the <a href="#pg-arch-threads-execution-strategy-pec"><code>Produce-Execute-Consume</code> mode</a> is always used instead.</p>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool</code> always maintains the number of threads between <code>QueuedThreadPool.minThreads</code> and <code>QueuedThreadPool.maxThreads</code>; during load spikes the number of thread grows to meet the load demand, and when the load on the system diminishes or the system goes idle, the number of threads shrinks.</p>
</div>
<div class="paragraph">
<p>Shrinking <code>QueuedThreadPool</code> is important in particular in containerized environments, where typically you want to return the memory occupied by the threads to the operative system.
The shrinking of the <code>QueuedThreadPool</code> is controlled by two parameters: <code>QueuedThreadPool.idleTimeout</code> and <code>QueuedThreadPool.maxEvictCount</code>.</p>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool.idleTimeout</code> indicates how long a thread should stay around when it is idle, waiting for tasks to execute.
The longer the threads stay around, the more ready they are in case of new load spikes on the system; however, they consume resources: a Java platform thread typically allocates 1 MiB of native memory.</p>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool.maxEvictCount</code> controls how many idle threads are evicted for one <code>QueuedThreadPool.idleTimeout</code> period.
The larger this value is, the quicker the threads are evicted when the <code>QueuedThreadPool</code> is idle or has less load, and their resources returned to the operative system; however, large values may result in too much thread thrashing: the <code>QueuedThreadPool</code> shrinks too fast and must re-create a lot of threads in case of a new load spike on the system.</p>
</div>
<div class="paragraph">
<p>A good balance between <code>QueuedThreadPool.idleTimeout</code> and <code>QueuedThreadPool.maxEvictCount</code> depends on the load profile of your system, and it is often tuned via trial and error.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-threads-thread-pool-virtual-threads"><a class="anchor" href="#pg-arch-threads-thread-pool-virtual-threads"></a><a class="link" href="#pg-arch-threads-thread-pool-virtual-threads">Virtual Threads</a></h5>
<div class="paragraph">
<p>Virtual threads have been introduced in Java 19 and Java 20 as a preview feature, and have become an official feature since Java 21.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Java versions where virtual threads are a preview feature, remember to add <code>--enable-preview</code> to the JVM command line options to use virtual threads.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>QueuedThreadPool</code> can be configured to use virtual threads by specifying the virtual threads <code>Executor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">QueuedThreadPool threadPool = <span class="keyword">new</span> QueuedThreadPool();
threadPool.setVirtualThreadsExecutor(<span class="predefined-type">Executors</span>.newVirtualThreadPerTaskExecutor());

Server server = <span class="keyword">new</span> Server(threadPool);</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Jetty cannot enforce that the <code>Executor</code> passed to <code>setVirtualThreadsExecutor(Executor)</code> uses virtual threads, so make sure to specify a <em>virtual</em> threads <code>Executor</code> and not a normal <code>Executor</code> that uses platform threads.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>AdaptiveExecutionStrategy</code> makes use of this setting when it determines that a task should be run with the <a href="#pg-arch-threads-execution-strategy-pec"><code>Produce-Execute-Consume</code> mode</a>: rather than submitting the task to <code>QueuedThreadPool</code> to be run in a platform thread, it submits the task to the virtual threads <code>Executor</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Enabling virtual threads in <code>QueuedThreadPool</code> will default the number of reserved threads to zero, unless the number of reserved threads is explicitly configured to a positive value.</p>
</div>
<div class="paragraph">
<p>Defaulting the number of reserved threads to zero ensures that the <a href="#pg-arch-threads-execution-strategy-pec">Produce-Execute-Consume mode</a> is always used, which means that virtual threads will always be used for blocking tasks.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-arch-io"><a class="anchor" href="#pg-arch-io"></a><a class="link" href="#pg-arch-io">Jetty I/O Architecture</a></h3>
<div class="paragraph">
<p>The Jetty libraries (both client and server) use Java NIO to handle I/O, so that at its core Jetty I/O is completely non-blocking.</p>
</div>
<div class="sect3">
<h4 id="pg-arch-io-selector-manager"><a class="anchor" href="#pg-arch-io-selector-manager"></a><a class="link" href="#pg-arch-io-selector-manager">Jetty I/O: <code>SelectorManager</code></a></h4>
<div class="paragraph">
<p>The main class of The Jetty I/O library is <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/SelectorManager.html"><code>SelectorManager</code></a>.</p>
</div>
<div class="paragraph">
<p><code>SelectorManager</code> manages internally a configurable number of <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/ManagedSelector.html"><code>ManagedSelector</code></a>s.
Each <code>ManagedSelector</code> wraps an instance of <code>java.nio.channels.Selector</code> that in turn manages a number of <code>java.nio.channels.SocketChannel</code> instances.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
TODO: add image
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>SocketChannel</code> instances are typically created by the Jetty implementation, on client-side when connecting to a server and on server-side when accepting connections from clients.
In both cases the <code>SocketChannel</code> instance is passed to <code>SelectorManager</code> (which passes it to <code>ManagedSelector</code> and eventually to <code>java.nio.channels.Selector</code>) to be registered for use within Jetty.</p>
</div>
<div class="paragraph">
<p>It is possible for an application to create the <code>SocketChannel</code> instances outside Jetty, even perform some initial network traffic also outside Jetty (for example for authentication purposes), and then pass the <code>SocketChannel</code> instance to <code>SelectorManager</code> for use within Jetty.</p>
</div>
<div class="paragraph">
<p>This example shows how a client can connect to a server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> connect(SelectorManager selectorManager, <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; context) <span class="directive">throws</span> <span class="exception">IOException</span>
{
    <span class="predefined-type">String</span> host = <span class="string"><span class="delimiter">&quot;</span><span class="content">host</span><span class="delimiter">&quot;</span></span>;
    <span class="type">int</span> port = <span class="integer">8080</span>;

    <span class="comment">// Create an unconnected SocketChannel.</span>
    <span class="predefined-type">SocketChannel</span> socketChannel = <span class="predefined-type">SocketChannel</span>.open();
    socketChannel.configureBlocking(<span class="predefined-constant">false</span>);

    <span class="comment">// Connect and register to Jetty.</span>
    <span class="keyword">if</span> (socketChannel.connect(<span class="keyword">new</span> <span class="predefined-type">InetSocketAddress</span>(host, port)))
        selectorManager.accept(socketChannel, context);
    <span class="keyword">else</span>
        selectorManager.connect(socketChannel, context);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example shows how a server accepts a client connection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">ServerSocketChannel</span> acceptor, SelectorManager selectorManager) <span class="directive">throws</span> <span class="exception">IOException</span>
{
    <span class="comment">// Wait until a client connects.</span>
    <span class="predefined-type">SocketChannel</span> socketChannel = acceptor.accept();
    socketChannel.configureBlocking(<span class="predefined-constant">false</span>);

    <span class="comment">// Accept and register to Jetty.</span>
    <span class="predefined-type">Object</span> attachment = <span class="predefined-constant">null</span>;
    selectorManager.accept(socketChannel, attachment);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-endpoint-connection"><a class="anchor" href="#pg-arch-io-endpoint-connection"></a><a class="link" href="#pg-arch-io-endpoint-connection">Jetty I/O: <code>EndPoint</code> and <code>Connection</code></a></h4>
<div class="paragraph">
<p><code>SocketChannel</code>s that are passed to <code>SelectorManager</code> are wrapped into two related components: an <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/EndPoint.html"><code>EndPoint</code></a> and a <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/Connection.html"><code>Connection</code></a>.</p>
</div>
<div class="paragraph">
<p><code>EndPoint</code> is the Jetty abstraction for a <code>SocketChannel</code> or a <code>DatagramChannel</code>: you can read bytes from an <code>EndPoint</code>, you can write bytes to an <code>EndPoint</code> , you can close an <code>EndPoint</code>, etc.</p>
</div>
<div class="paragraph">
<p><code>Connection</code> is the Jetty abstraction that is responsible to read bytes from the <code>EndPoint</code> and to deserialize the read bytes into objects.
For example, an HTTP/1.1 server-side <code>Connection</code> implementation is responsible to deserialize HTTP/1.1 request bytes into an HTTP request object.
Conversely, an HTTP/1.1 client-side <code>Connection</code> implementation is responsible to deserialize HTTP/1.1 response bytes into an HTTP response object.</p>
</div>
<div class="paragraph">
<p><code>Connection</code> is the abstraction that implements the reading side of a specific protocol such as HTTP/1.1, or HTTP/2, or HTTP/3, or WebSocket: it is able to read and parse incoming bytes in that protocol.</p>
</div>
<div class="paragraph">
<p>The writing side for a specific protocol <em>may</em> be implemented in the <code>Connection</code> but may also be implemented in other components, although eventually the bytes to write will be written through the <code>EndPoint</code>.</p>
</div>
<div class="paragraph">
<p>While there are primarily only two implementations of <code>EndPoint</code>,<a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/SocketChannelEndPoint.html"><code>SocketChannelEndPoint</code></a> for TCP and <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/DatagramChannelEndPoint.html"><code>DatagramChannelEndPoint</code></a> for UDP (used both on the client-side and on the server-side), there are many implementations of <code>Connection</code>, typically two for each protocol (one for the client-side and one for the server-side).</p>
</div>
<div class="paragraph">
<p>The <code>EndPoint</code> and <code>Connection</code> pairs can be chained, for example in case of encrypted communication using the TLS protocol.
There is an <code>EndPoint</code> and <code>Connection</code> TLS pair where the <code>EndPoint</code> reads the encrypted bytes from the socket and the <code>Connection</code> decrypts them; next in the chain there is an <code>EndPoint</code> and <code>Connection</code> pair where the <code>EndPoint</code> "reads" decrypted bytes (provided by the previous <code>Connection</code>) and the <code>Connection</code> deserializes them into specific protocol objects (for example HTTP/2 frame objects).</p>
</div>
<div class="paragraph">
<p>Certain protocols, such as WebSocket, start the communication with the server using one protocol (for example, HTTP/1.1), but then change the communication to use another protocol (for example, WebSocket).
<code>EndPoint</code> supports changing the <code>Connection</code> object on-the-fly via <code>EndPoint.upgrade(Connection)</code>.
This allows to use the HTTP/1.1 <code>Connection</code> during the initial communication and later to replace it with a WebSocket <code>Connection</code>.</p>
</div>
<div class="paragraph">
<p><code>SelectorManager</code> is an abstract class because while it knows how to create concrete <code>EndPoint</code> instances, it does not know how to create protocol specific <code>Connection</code> instances.</p>
</div>
<div class="paragraph">
<p>Creating <code>Connection</code> instances is performed on the server-side by <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ConnectionFactory.html"><code>ConnectionFactory</code></a>s and on the client-side by <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/ClientConnectionFactory.html"><code>ClientConnectionFactory</code></a>s.</p>
</div>
<div class="paragraph">
<p>On the server-side, the component that aggregates a <code>SelectorManager</code> with a set of <code>ConnectionFactory</code>s is <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ServerConnector.html"><code>ServerConnector</code></a> for TCP sockets, <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/quic/server/QuicServerConnector.html"><code>QuicServerConnector</code></a> for QUIC sockets, and <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/unixdomain/server/UnixDomainServerConnector.html"><code>UnixDomainServerConnector</code></a> for Unix-Domain sockets (see the <a href="#pg-server-io-arch">server-side architecture section</a> for more information).</p>
</div>
<div class="paragraph">
<p>On the client-side, the components that aggregates a <code>SelectorManager</code> with a set of <code>ClientConnectionFactory</code>s are <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/client/HttpClientTransport.html"><code>HttpClientTransport</code></a> subclasses (see the <a href="#pg-client-io-arch">client-side architecture section</a> for more information).</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-endpoint"><a class="anchor" href="#pg-arch-io-endpoint"></a><a class="link" href="#pg-arch-io-endpoint">Jetty I/O: <code>EndPoint</code></a></h4>
<div class="paragraph">
<p>The Jetty I/O library use Java NIO to handle I/O, so that I/O is non-blocking.</p>
</div>
<div class="paragraph">
<p>At the Java NIO level, in order to be notified when a <code>SocketChannel</code> or <code>DatagramChannel</code> has data to be read, the <code>SelectionKey.OP_READ</code> flag must be set.</p>
</div>
<div class="paragraph">
<p>In the Jetty I/O library, you can call <code>EndPoint.fillInterested(Callback)</code> to declare interest in the "read" (also called "fill") event, and the <code>Callback</code> parameter is the object that is notified when such an event occurs.</p>
</div>
<div class="paragraph">
<p>At the Java NIO level, a <code>SocketChannel</code> or <code>DatagramChannel</code> is always writable, unless it becomes congested.
In order to be notified when a channel uncongests and it is therefore writable again, the <code>SelectionKey.OP_WRITE</code> flag must be set.</p>
</div>
<div class="paragraph">
<p>In the Jetty I/O library, you can call <code>EndPoint.write(Callback, ByteBuffer&#8230;&#8203;)</code> to write the <code>ByteBuffer</code>s and the <code>Callback</code> parameter is the object that is notified when the whole write is finished (i.e. <em>all</em> <code>ByteBuffer</code>s have been fully written, even if they are delayed by congestion/uncongestion).</p>
</div>
<div class="paragraph">
<p>The <code>EndPoint</code> APIs abstract out the Java NIO details by providing non-blocking APIs based on <code>Callback</code> objects for I/O operations.
The <code>EndPoint</code> APIs are typically called by <code>Connection</code> implementations, see <a href="#pg-arch-io-connection">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-connection"><a class="anchor" href="#pg-arch-io-connection"></a><a class="link" href="#pg-arch-io-connection">Jetty I/O: <code>Connection</code></a></h4>
<div class="paragraph">
<p><code>Connection</code> is the abstraction that deserializes incoming bytes into objects, for example an HTTP request object or a WebSocket frame object, that can be used by more abstract layers.</p>
</div>
<div class="paragraph">
<p><code>Connection</code> instances have two lifecycle methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Connection.onOpen()</code>, invoked when the <code>Connection</code> is associated with the <code>EndPoint</code>.</p>
</li>
<li>
<p><code>Connection.onClose(Throwable)</code>, invoked when the <code>Connection</code> is disassociated from the <code>EndPoint</code>, where the <code>Throwable</code> parameter indicates whether the disassociation was normal (when the parameter is <code>null</code>) or was due to an error (when the parameter is not <code>null</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a <code>Connection</code> is first created, it is not registered for any Java NIO event.
It is therefore typical to implement <code>onOpen()</code> to call <code>EndPoint.fillInterested(Callback)</code> so that the <code>Connection</code> declares interest for read events, and it is invoked (via the <code>Callback</code>) when the read event happens.</p>
</div>
<div class="paragraph">
<p>The abstract class <code>AbstractConnection</code> partially implements <code>Connection</code> and provides simpler APIs.
The example below shows a typical implementation that extends <code>AbstractConnection</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Extend AbstractConnection to inherit basic implementation.</span>
<span class="type">class</span> <span class="class">MyConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="directive">public</span> MyConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest for fill events.</span>
        <span class="comment">// When the fill event happens, method onFillable() below is invoked.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        <span class="comment">// Invoked when a fill event happens.</span>
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-io-connection-listener"><a class="anchor" href="#pg-arch-io-connection-listener"></a><a class="link" href="#pg-arch-io-connection-listener">Jetty I/O: <code>Connection.Listener</code></a></h5>
<div class="paragraph">
<p>The Jetty I/O library allows applications to register <a href="#pg-arch-listener">event listeners</a> for the <code>Connection</code> events "opened" and "closed" via the interface <code>Connection.Listener</code>.</p>
</div>
<div class="paragraph">
<p>This is useful in many cases, for example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Gather statistics about connection lifecycle, such as time of creation and duration.</p>
</li>
<li>
<p>Gather statistics about the number of concurrent connections, and take action if a threshold is exceeded.</p>
</li>
<li>
<p>Gather statistics about the number of bytes read and written, and the number of "messages" read and written, where "messages" may mean HTTP/1.1 requests or responses, or WebSocket frames, or HTTP/2 frames, etc.</p>
</li>
<li>
<p>Gather statistics about the different types of connections being opened (TLS, HTTP/1.1, HTTP/2, WebSocket, etc.).</p>
</li>
<li>
<p>Etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Connection.Listener</code> implementations must be added as beans to a server-side <code>Connector</code>, or to client-side <code>HttpClient</code>, <code>WebSocketClient</code>, <code>HTTP2Client</code> or <code>HTTP3Client</code>.
You can add as beans many <code>Connection.Listener</code> objects, each with its own logic, so that you can separate different logics into different <code>Connection.Listener</code> implementations.</p>
</div>
<div class="paragraph">
<p>The Jetty I/O library provides useful <code>Connection.Listener</code> implementations that you should evaluate before writing your own:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/ConnectionStatistics.html"><code>ConnectionStatistics</code></a></p>
</li>
<li>
<p><a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ConnectionLimit.html"><code>ConnectionLimit</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is a simple example of a <code>Connection.Listener</code> used both on the client and on the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ThresholdConnectionListener</span> <span class="directive">implements</span> <span class="predefined-type">Connection</span>.Listener
{
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> connections = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">private</span> <span class="type">int</span> threshold;
    <span class="directive">private</span> <span class="type">boolean</span> notified;

    <span class="directive">public</span> ThresholdConnectionListener(<span class="type">int</span> threshold)
    {
        <span class="local-variable">this</span>.threshold = threshold;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpened(<span class="predefined-type">Connection</span> connection)
    {
        <span class="type">int</span> count = connections.incrementAndGet();
        <span class="keyword">if</span> (count &gt; threshold &amp;&amp; !notified)
        {
            notified = <span class="predefined-constant">true</span>;
            <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">connection.threshold</span><span class="delimiter">&quot;</span></span>).log(<span class="predefined-type">System</span>.Logger.Level.WARNING, <span class="string"><span class="delimiter">&quot;</span><span class="content">Connection threshold exceeded</span><span class="delimiter">&quot;</span></span>);
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onClosed(<span class="predefined-type">Connection</span> connection)
    {
        <span class="type">int</span> count = connections.decrementAndGet();
        <span class="comment">// Reset the alert when we are below 90% of the threshold.</span>
        <span class="keyword">if</span> (count &lt; threshold * <span class="float">0.9F</span>)
            notified = <span class="predefined-constant">false</span>;
    }
}

<span class="comment">// Configure server-side connectors with Connection.Listeners.</span>
Server server = <span class="keyword">new</span> Server();
ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);
server.addConnector(connector);
<span class="comment">// Add statistics.</span>
connector.addBean(<span class="keyword">new</span> ConnectionStatistics());
<span class="comment">// Add your own Connection.Listener.</span>
connector.addBean(<span class="keyword">new</span> ThresholdConnectionListener(<span class="integer">2048</span>));
server.start();

<span class="comment">// Configure client-side HttpClient with Connection.Listeners.</span>
HttpClient httpClient = <span class="keyword">new</span> HttpClient();
<span class="comment">// Add statistics.</span>
httpClient.addBean(<span class="keyword">new</span> ConnectionStatistics());
<span class="comment">// Add your own Connection.Listener.</span>
httpClient.addBean(<span class="keyword">new</span> ThresholdConnectionListener(<span class="integer">512</span>));
httpClient.start();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-echo"><a class="anchor" href="#pg-arch-io-echo"></a><a class="link" href="#pg-arch-io-echo">Jetty I/O: TCP Network Echo</a></h4>
<div class="paragraph">
<p>With the concepts above it is now possible to write a simple, fully non-blocking, <code>Connection</code> implementation that simply echoes the bytes that it reads back to the other peer.</p>
</div>
<div class="paragraph">
<p>A naive, but wrong, implementation may be the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">WrongEchoConnection</span> <span class="directive">extends</span> AbstractConnection <span class="directive">implements</span> <span class="predefined-type">Callback</span>
{
    <span class="directive">public</span> WrongEchoConnection(EndPoint endPoint, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endPoint, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest for fill events.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        <span class="keyword">try</span>
        {
            <span class="predefined-type">ByteBuffer</span> buffer = BufferUtil.allocate(<span class="integer">1024</span>);
            <span class="type">int</span> filled = getEndPoint().fill(buffer);
            <span class="keyword">if</span> (filled &gt; <span class="integer">0</span>)
            {
                <span class="comment">// Filled some bytes, echo them back.</span>
                getEndPoint().write(<span class="local-variable">this</span>, buffer);
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (filled == <span class="integer">0</span>)
            {
                <span class="comment">// No more bytes to fill, declare</span>
                <span class="comment">// again interest for fill events.</span>
                fillInterested();
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// The other peer closed the</span>
                <span class="comment">// connection, close it back.</span>
                getEndPoint().close();
            }
        }
        <span class="keyword">catch</span> (<span class="exception">Exception</span> x)
        {
            getEndPoint().close(x);
        }
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> succeeded()
    {
        <span class="comment">// The write is complete, fill again.</span>
        onFillable();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> failed(<span class="predefined-type">Throwable</span> x)
    {
        getEndPoint().close(x);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The implementation above is wrong and leads to <code>StackOverflowError</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The problem with this implementation is that if the writes always complete synchronously (i.e. without being delayed by TCP congestion), you end up with this sequence of calls:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Connection.onFillable()
  EndPoint.write()
    Connection.succeeded()
      Connection.onFillable()
        EndPoint.write()
          Connection.succeeded()
          ...</pre>
</div>
</div>
<div class="paragraph">
<p>which leads to <code>StackOverflowError</code>.</p>
</div>
<div class="paragraph">
<p>This is a typical side effect of asynchronous programming using non-blocking APIs, and happens in the Jetty I/O library as well.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The callback is invoked synchronously for efficiency reasons.
Submitting the invocation of the callback to an <code>Executor</code> to be invoked in a different thread would cause a context switch and make simple writes extremely inefficient.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This side effect of asynchronous programming leading to <code>StackOverflowError</code> is so common that the Jetty libraries have a generic solution for it: a specialized <code>Callback</code> implementation named <code>org.eclipse.jetty.util.IteratingCallback</code> that turns recursion into iteration, therefore avoiding the <code>StackOverflowError</code>.</p>
</div>
<div class="paragraph">
<p><code>IteratingCallback</code> is a <code>Callback</code> implementation that should be passed to non-blocking APIs such as <code>EndPoint.write(Callback, ByteBuffer&#8230;&#8203;)</code> when they are performed in a loop.</p>
</div>
<div class="paragraph">
<p><code>IteratingCallback</code> works by starting the loop with <code>IteratingCallback.iterate()</code>.
In turn, this calls <code>IteratingCallback.process()</code>, an abstract method that must be implemented with the code that should be executed for each loop.</p>
</div>
<div class="paragraph">
<p>Method <code>process()</code> must return:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Action.SCHEDULED</code>, to indicate whether the loop has performed a non-blocking, possibly asynchronous, operation</p>
</li>
<li>
<p><code>Action.IDLE</code>, to indicate that the loop should temporarily be suspended to be resumed later</p>
</li>
<li>
<p><code>Action.SUCCEEDED</code> to indicate that the loop exited successfully</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any exception thrown within <code>process()</code> exits the loops with a failure.</p>
</div>
<div class="paragraph">
<p>Now that you know how <code>IteratingCallback</code> works, a correct implementation for the echo <code>Connection</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EchoConnection</span> <span class="directive">extends</span> AbstractConnection
{
    <span class="directive">private</span> <span class="directive">final</span> IteratingCallback callback = <span class="keyword">new</span> EchoIteratingCallback();

    <span class="directive">public</span> EchoConnection(EndPoint endp, <span class="predefined-type">Executor</span> executor)
    {
        <span class="local-variable">super</span>(endp, executor);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onOpen()
    {
        <span class="local-variable">super</span>.onOpen();

        <span class="comment">// Declare interest for fill events.</span>
        fillInterested();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> onFillable()
    {
        <span class="comment">// Start the iteration loop that reads and echoes back.</span>
        callback.iterate();
    }

    <span class="type">class</span> <span class="class">EchoIteratingCallback</span> <span class="directive">extends</span> IteratingCallback
    {
        <span class="directive">private</span> <span class="predefined-type">ByteBuffer</span> buffer;

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="predefined-type">Action</span> process() <span class="directive">throws</span> <span class="predefined-type">Throwable</span>
        {
            <span class="comment">// Obtain a buffer if we don't already have one.</span>
            <span class="keyword">if</span> (buffer == <span class="predefined-constant">null</span>)
                buffer = BufferUtil.allocate(<span class="integer">1024</span>);

            <span class="type">int</span> filled = getEndPoint().fill(buffer);
            <span class="keyword">if</span> (filled &gt; <span class="integer">0</span>)
            {
                <span class="comment">// We have filled some bytes, echo them back.</span>
                getEndPoint().write(<span class="local-variable">this</span>, buffer);

                <span class="comment">// Signal that the iteration should resume</span>
                <span class="comment">// when the write() operation is completed.</span>
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.SCHEDULED;
            }
            <span class="keyword">else</span> <span class="keyword">if</span> (filled == <span class="integer">0</span>)
            {
                <span class="comment">// We don't need the buffer anymore, so</span>
                <span class="comment">// don't keep it around while we are idle.</span>
                buffer = <span class="predefined-constant">null</span>;

                <span class="comment">// No more bytes to read, declare</span>
                <span class="comment">// again interest for fill events.</span>
                fillInterested();

                <span class="comment">// Signal that the iteration is now IDLE.</span>
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.IDLE;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// The other peer closed the connection,</span>
                <span class="comment">// the iteration completed successfully.</span>
                <span class="keyword">return</span> <span class="predefined-type">Action</span>.SUCCEEDED;
            }
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteSuccess()
        {
            <span class="comment">// The iteration completed successfully.</span>
            getEndPoint().close();
        }

        <span class="annotation">@Override</span>
        <span class="directive">protected</span> <span class="type">void</span> onCompleteFailure(<span class="predefined-type">Throwable</span> cause)
        {
            <span class="comment">// The iteration completed with a failure.</span>
            getEndPoint().close(cause);
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> InvocationType getInvocationType()
        {
            <span class="keyword">return</span> InvocationType.NON_BLOCKING;
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>onFillable()</code> is called, for example the first time that bytes are available from the network, the iteration is started.
Starting the iteration calls <code>process()</code>, where a buffer is allocated and filled with bytes read from the network via <code>EndPoint.fill(ByteBuffer)</code>; the buffer is subsequently written back via <code>EndPoint.write(Callback, ByteBuffer&#8230;&#8203;)</code>&#8201;&#8212;&#8201;note that the callback passed to <code>EndPoint.write()</code> is <code>this</code>, i.e. the <code>IteratingCallback</code> itself; finally <code>Action.SCHEDULED</code> is returned, returning from the <code>process()</code> method.</p>
</div>
<div class="paragraph">
<p>At this point, the call to <code>EndPoint.write(Callback, ByteBuffer&#8230;&#8203;)</code> may have completed synchronously; <code>IteratingCallback</code> would know that and call <code>process()</code> again; within <code>process()</code>, the buffer has already been allocated so it will be reused, saving further allocations; the buffer will be filled and possibly written again; <code>Action.SCHEDULED</code> is returned again, returning again from the <code>process()</code> method.</p>
</div>
<div class="paragraph">
<p>At this point, the call to <code>EndPoint.write(Callback, ByteBuffer&#8230;&#8203;)</code> may have not completed synchronously, so <code>IteratingCallback</code> will not call <code>process()</code> again; the processing thread is free to return to the Jetty I/O system where it may be put back into the thread pool.
If this was the only active network connection, the system would now be idle, with no threads blocked, waiting that the <code>write()</code> completes. This thread-less wait is one of the most important features that make non-blocking asynchronous servers more scalable: they use less resources.</p>
</div>
<div class="paragraph">
<p>Eventually, the Jetty I/O system will notify that the <code>write()</code> completed; this notifies the <code>IteratingCallback</code> that can now resume the loop and call <code>process()</code> again.</p>
</div>
<div class="paragraph">
<p>When <code>process()</code> is called, it is possible that zero bytes are read from the network; in this case, you want to deallocate the buffer since the other peer may never send more bytes for the <code>Connection</code> to read, or it may send them after a long pause&#8201;&#8212;&#8201;in both cases we do not want to retain the memory allocated by the buffer; next, you want to call <code>fillInterested()</code> to declare again interest for read events, and return <code>Action.IDLE</code> since there is nothing to write back and therefore the loop may be suspended.
When more bytes are again available to be read from the network, <code>onFillable()</code> will be called again and that will start the iteration again.</p>
</div>
<div class="paragraph">
<p>Another possibility is that during <code>process()</code> the read returns <code>-1</code> indicating that the other peer has closed the connection; this means that there will not be more bytes to read and the loop can be exited, so you return <code>Action.SUCCEEDED</code>; <code>IteratingCallback</code> will then call <code>onCompleteSuccess()</code> where you can close the <code>EndPoint</code>.</p>
</div>
<div class="paragraph">
<p>The last case is that during <code>process()</code> an exception is thrown, for example by <code>EndPoint.fill(ByteBuffer)</code> or, in more advanced implementations, by code that parses the bytes that have been read and finds them unacceptable; any exception thrown within <code>process()</code> will be caught by <code>IteratingCallback</code> that will exit the loop with a failure and call <code>onCompleteFailure(Throwable)</code> with the exception that has been thrown, where you can close the <code>EndPoint</code>, passing the exception that is the reason for closing prematurely the <code>EndPoint</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Asynchronous programming is hard.</p>
</div>
<div class="paragraph">
<p>Rely on the Jetty classes to implement <code>Connection</code> to avoid mistakes that will be difficult to diagnose and reproduce.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-content-source"><a class="anchor" href="#pg-arch-io-content-source"></a><a class="link" href="#pg-arch-io-content-source"><code>Content.Source</code></a></h4>
<div class="paragraph">
<p>The high-level abstraction that Jetty offers to read bytes is <code>org.eclipse.jetty.io.Content.Source</code>.</p>
</div>
<div class="paragraph">
<p><code>Content.Source</code> offers a non-blocking demand/read model where a read returns a <code>Content.Chunk</code> (see also <a href="#pg-arch-io-content-source-chunk">this section</a>).</p>
</div>
<div class="paragraph">
<p>A <code>Content.Chunk</code> groups the following information:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>ByteBuffer</code> with the bytes that have been read; it may be empty.</p>
</li>
<li>
<p>Whether the read reached end-of-file, via its <code>last</code> flag.</p>
</li>
<li>
<p>A failure that might have happened during the read, via its <code>getFailure()</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>Content.Chunk</code> returned from <code>Content.Source.read()</code> can either be a <em>normal</em> chunk (a chunk containing a <code>ByteBuffer</code> and a <code>null</code> failure), or a <em>failure</em> chunk (a chunk containing an empty <code>ByteBuffer</code> and a non-<code>null</code> failure).</p>
</div>
<div class="paragraph">
<p>A failure chunk also indicates (via the <code>last</code> flag) whether the failure is a fatal (when <code>last=true</code>) or transient (when <code>last=false</code>) failure.</p>
</div>
<div class="paragraph">
<p>A transient failure is a temporary failure that happened during the read, it may be ignored, and it is recoverable: it is possible to call <code>read()</code> again and obtain a normal chunk (or a <code>null</code> chunk).
Typical cases of transient failures are idle timeout failures, where the read timed out, but the application may decide to insist reading until some other event happens.
The application may convert a transient failure into a fatal failure by calling <code>Content.Source.fail(Throwable)</code>.</p>
</div>
<div class="paragraph">
<p>A <code>Content.Source</code> must be fully consumed by reading all its content, or failed by calling <code>Content.Source.fail(Throwable)</code> to signal that the reader is not interested in reading anymore, otherwise it may leak underlying resources.</p>
</div>
<div class="paragraph">
<p>Fully consuming a <code>Content.Source</code> means reading from it until it returns a <code>Content.Chunk</code> whose <code>last</code> flag is <code>true</code>.
Reading or demanding from an already fully consumed <code>Content.Source</code> is always immediately serviced with the last state of the <code>Content.Source</code>: a <code>Content.Chunk</code> with the <code>last</code> flag set to <code>true</code>, either an end-of-file chunk, or a failure chunk.</p>
</div>
<div class="paragraph">
<p>Once failed, a <code>Content.Source</code> is considered fully consumed.
Further attempts to read from a failed <code>Content.Source</code> return a failure chunk whose <code>getFailure()</code> method returns the exception passed to <code>Content.Source.fail(Throwable)</code>.</p>
</div>
<div class="paragraph">
<p>When reading a normal chunk, its <code>ByteBuffer</code> is typically a slice of a different <code>ByteBuffer</code> that has been read by a lower layer.
There may be multiple layers between the bottom layer (where the initial read typically happens) and the application layer that calls <code>Content.Source.read()</code>.</p>
</div>
<div class="paragraph">
<p>By slicing the <code>ByteBuffer</code> (rather than copying its bytes), there is no copy of the bytes between the layers, which yields greater performance.
However, this comes with the cost that the <code>ByteBuffer</code>, and the associated <code>Content.Chunk</code>, have an intrinsic lifecycle: the final consumer of a <code>Content.Chunk</code> at the application layer must indicate when it has consumed the chunk, so that the bottom layer may reuse/recycle the <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>Consuming the chunk means that the bytes in the <code>ByteBuffer</code> are read (or ignored), and that the application will not look at or reference that <code>ByteBuffer</code> ever again.</p>
</div>
<div class="paragraph">
<p><code>Content.Chunk</code> offers a retain/release model to deal with the <code>ByteBuffer</code> lifecycle, with a simple rule:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
A <code>Content.Chunk</code> returned by a call to <code>Content.Source.read()</code> <strong>must</strong> be released, except for <code>Content.Chunk</code>s that are failure chunks.
Failure chunks <em>may</em> be released, but they do not <em>need</em> to be.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The example below is the idiomatic way of reading from a <code>Content.Source</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> read(Content.Source source)
{
    <span class="comment">// Read from the source in a loop.</span>
    <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
    {
        <span class="comment">// Read a chunk, must be eventually released.</span>
        Content.Chunk chunk = source.read(); <i class="conum" data-value="1"></i><b>(1)</b>

        <span class="comment">// If no chunk, demand to be called back when there are more chunks.</span>
        <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
        {
            source.demand(() -&gt; read(source));
            <span class="keyword">return</span>;
        }

        <span class="comment">// If there is a failure reading, handle it.</span>
        <span class="keyword">if</span> (Content.Chunk.isFailure(chunk))
        {
            <span class="type">boolean</span> fatal = chunk.isLast();
            <span class="keyword">if</span> (fatal)
            {
                <span class="comment">// A fatal failure, such as a network failure.</span>
                handleFatalFailure(chunk.getFailure());
                <span class="comment">// No recovery is possible, stop reading</span>
                <span class="comment">// by returning without demanding.</span>
                <span class="keyword">return</span>;
            }
            <span class="keyword">else</span>
            {
                <span class="comment">// A transient failure such as a read timeout.</span>
                handleTransientFailure(chunk.getFailure());
                <span class="comment">// Recovery is possible, try to read again.</span>
                <span class="keyword">continue</span>;
            }
        }

        <span class="comment">// A normal chunk of content, consume it.</span>
        consume(chunk);

        <span class="comment">// Release the chunk.</span>
        chunk.release(); <i class="conum" data-value="2"></i><b>(2)</b>

        <span class="comment">// Stop reading if EOF was reached.</span>
        <span class="keyword">if</span> (chunk.isLast())
            <span class="keyword">return</span>;

        <span class="comment">// Loop around to read another chunk.</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>read()</code> that must be paired with a <code>release()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>release()</code> that pairs the <code>read()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note how the reads happen in a loop, consuming the <code>Content.Source</code> as soon as it has content available to be read, and therefore no backpressure is applied to the reads.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Calling <code>Content.Chunk.release()</code> must be done only after the bytes in the <code>ByteBuffer</code> returned by <code>Content.Chunk.getByteBuffer()</code> have been consumed.
When the <code>Content.Chunk</code> is released, the implementation may reuse the <code>ByteBuffer</code> and overwrite the bytes with different bytes; if the application looks at the <code>ByteBuffer</code> <em>after</em> having released the <code>Content.Chunk</code> is may see other, unrelated, bytes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An alternative way to read from a <code>Content.Source</code>, to use when the chunk is consumed asynchronously, and you don&#8217;t want to read again until the <code>Content.Chunk</code> is consumed, is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> read(Content.Source source)
{
    <span class="comment">// Read a chunk, must be eventually released.</span>
    Content.Chunk chunk = source.read(); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="comment">// If no chunk, demand to be called back when there are more chunks.</span>
    <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
    {
        source.demand(() -&gt; read(source));
        <span class="keyword">return</span>;
    }

    <span class="comment">// If there is a failure reading, always treat it as fatal.</span>
    <span class="keyword">if</span> (Content.Chunk.isFailure(chunk))
    {
        <span class="comment">// If the failure is transient, fail the source</span>
        <span class="comment">// to indicate that there will be no more reads.</span>
        <span class="keyword">if</span> (!chunk.isLast())
            source.fail(chunk.getFailure());

        <span class="comment">// Handle the failure and stop reading by not demanding.</span>
        handleFatalFailure(chunk.getFailure());
        <span class="keyword">return</span>;
    }

    <span class="comment">// Consume the chunk asynchronously, and do not</span>
    <span class="comment">// read more chunks until this has been consumed.</span>
    CompletableFuture&lt;<span class="predefined-type">Void</span>&gt; consumed = consumeAsync(chunk);

    <span class="comment">// Release the chunk.</span>
    chunk.release(); <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="comment">// Only when the chunk has been consumed try to read more.</span>
    consumed.whenComplete((result, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Continue reading if EOF was not reached.</span>
            <span class="keyword">if</span> (!chunk.isLast())
                source.demand(() -&gt; read(source));
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// If there is a failure reading, handle it,</span>
            <span class="comment">// and stop reading by not demanding.</span>
            handleFatalFailure(failure);
        }
    });
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>read()</code> that must be paired with a <code>release()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>release()</code> that pairs the <code>read()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note how the reads do not happen in a loop, and therefore backpressure is applied to the reads, because there is not a next read until the chunk from the previous read has been consumed (and this may take time).</p>
</div>
<div class="paragraph">
<p>Since the <code>Chunk</code> is consumed asynchronously, you may need to retain it to extend its lifecycle, as explained in <a href="#pg-arch-io-content-source-chunk">this section</a>.</p>
</div>
<div class="paragraph">
<p>You can use <code>Content.Source</code> static methods to conveniently read (in a blocking way or non-blocking way), for example via <code>static Content.Source.asStringAsync(Content.Source, Charset)</code>, or via an <code>InputStream</code> using <code>static Content.Source.asInputStream(Content.Source)</code>.</p>
</div>
<div class="paragraph">
<p>Refer to the <code>Content.Source</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/io/Content.Source.html"><code>javadocs</code></a> for further details.</p>
</div>
<div class="sect4">
<h5 id="pg-arch-io-content-source-chunk"><a class="anchor" href="#pg-arch-io-content-source-chunk"></a><a class="link" href="#pg-arch-io-content-source-chunk"><code>Content.Chunk</code></a></h5>
<div class="paragraph">
<p><code>Content.Chunk</code> offers a retain/release API to control the lifecycle of its <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>When <code>Content.Chunk</code>s are consumed synchronously, no additional retain/release API call is necessary, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> consume(Content.Chunk chunk) <span class="directive">throws</span> <span class="exception">IOException</span>
{
    <span class="comment">// Consume the chunk synchronously within this method.</span>

    <span class="comment">// For example, parse the bytes into other objects,</span>
    <span class="comment">// or copy the bytes elsewhere (e.g. the file system).</span>
    fileChannel.write(chunk.getByteBuffer());

    <span class="keyword">if</span> (chunk.isLast())
        fileChannel.close();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the other hand, if the <code>Content.Chunk</code> is not consumed immediately, then it must be retained, and you must arrange for the <code>Content.Chunk</code> to be released at a later time, thus pairing the retain.
For example, you may accumulate the <code>Content.Chunk</code>s in a <code>List</code> to convert them to a <code>String</code> when all the <code>Content.Chunk</code>s have been read.</p>
</div>
<div class="paragraph">
<p>Since reading from a <code>Content.Source</code> is asynchronous, the <code>String</code> result is produced via a <code>CompletableFuture</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// CompletableTask is-a CompletableFuture.</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ChunksToString</span> <span class="directive">extends</span> CompletableTask&lt;<span class="predefined-type">String</span>&gt;
{
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;Content.Chunk&gt; chunks = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
    <span class="directive">private</span> <span class="directive">final</span> Content.Source source;

    <span class="directive">public</span> ChunksToString(Content.Source source)
    {
        <span class="local-variable">this</span>.source = source;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> run()
    {
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
        {
            <span class="comment">// Read a chunk, must be eventually released.</span>
            Content.Chunk chunk = source.read(); <i class="conum" data-value="1"></i><b>(1)</b>

            <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
            {
                source.demand(<span class="local-variable">this</span>);
                <span class="keyword">return</span>;
            }

            <span class="keyword">if</span> (Content.Chunk.isFailure(chunk))
            {
                handleFatalFailure(chunk.getFailure());
                <span class="keyword">return</span>;
            }

            <span class="comment">// A normal chunk of content, consume it.</span>
            consume(chunk);

            <span class="comment">// Release the chunk.</span>
            <span class="comment">// This pairs the call to read() above.</span>
            chunk.release(); <i class="conum" data-value="2"></i><b>(2)</b>

            <span class="keyword">if</span> (chunk.isLast())
            {
                <span class="comment">// Produce the result.</span>
                <span class="predefined-type">String</span> result = getResult();

                <span class="comment">// Complete this CompletableFuture with the result.</span>
                complete(result);

                <span class="comment">// The reading is complete.</span>
                <span class="keyword">return</span>;
            }
        }
    }

    <span class="directive">public</span> <span class="type">void</span> consume(Content.Chunk chunk)
    {
        <span class="comment">// The chunk is not consumed within this method, but</span>
        <span class="comment">// stored away for later use, so it must be retained.</span>
        chunk.retain(); <i class="conum" data-value="3"></i><b>(3)</b>
        chunks.add(chunk);
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getResult()
    {
        Utf8StringBuilder builder = <span class="keyword">new</span> Utf8StringBuilder();
        <span class="comment">// Iterate over the chunks, copying and releasing.</span>
        <span class="keyword">for</span> (Content.Chunk chunk : chunks)
        {
            <span class="comment">// Copy the chunk bytes into the builder.</span>
            builder.append(chunk.getByteBuffer());

            <span class="comment">// The chunk has been consumed, release it.</span>
            <span class="comment">// This pairs the retain() in consume().</span>
            chunk.release(); <i class="conum" data-value="4"></i><b>(4)</b>
        }
        <span class="keyword">return</span> builder.toCompleteString();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>read()</code> that must be paired with a <code>release()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>release()</code> that pairs the <code>read()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>retain()</code> that must be paired with a <code>release()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>release()</code> that pairs the <code>retain()</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note how method <code>consume(Content.Chunk)</code> retains the <code>Content.Chunk</code> because it does not consume it, but rather stores it away for later use.
With this additional retain, the retain count is now <code>2</code>: one implicitly from the <code>read()</code> that returned the <code>Content.Chunk</code>, and one explicit in <code>consume(Content.Chunk)</code>.</p>
</div>
<div class="paragraph">
<p>However, just after returning from <code>consume(Content.Chunk)</code> the <code>Content.Chunk</code> is released (pairing the implicit retain from <code>read()</code>), so that the retain count goes to <code>1</code>, and an additional release is still necessary.</p>
</div>
<div class="paragraph">
<p>Method <code>getResult()</code> arranges to release all the <code>Content.Chunk</code>s that have been accumulated, pairing the retains done in <code>consume(Content.Chunk)</code>, so that the retain count for the <code>Content.Chunk</code>s goes finally to <code>0</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-io-content-sink"><a class="anchor" href="#pg-arch-io-content-sink"></a><a class="link" href="#pg-arch-io-content-sink"><code>Content.Sink</code></a></h4>
<div class="paragraph">
<p>The high-level abstraction that Jetty offers to write bytes is <code>org.eclipse.jetty.io.Content.Sink</code>.</p>
</div>
<div class="paragraph">
<p>The primary method to use is <code>Content.Sink.write(boolean, ByteBuffer, Callback)</code>, which performs a non-blocking write of the given <code>ByteBuffer</code>, with the indication of whether the write is the last.</p>
</div>
<div class="paragraph">
<p>The <code>Callback</code> parameter is completed, successfully or with a failure, and possibly asynchronously by a different thread, when the write is complete.</p>
</div>
<div class="paragraph">
<p>Your application can typically perform zero or more non-last writes, and one final last write.</p>
</div>
<div class="paragraph">
<p>However, because the writes may be asynchronous, you cannot start a next write before the previous write is completed.</p>
</div>
<div class="paragraph">
<p>This code is wrong:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> wrongWrite(Content.Sink sink, <span class="predefined-type">ByteBuffer</span> content1, <span class="predefined-type">ByteBuffer</span> content2)
{
    <span class="comment">// Initiate a first write.</span>
    sink.write(<span class="predefined-constant">false</span>, content1, <span class="predefined-type">Callback</span>.NOOP);

    <span class="comment">// WRONG! Cannot initiate a second write before the first is complete.</span>
    sink.write(<span class="predefined-constant">true</span>, content2, <span class="predefined-type">Callback</span>.NOOP);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You must initiate a second write only when the first is finished, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> manyWrites(Content.Sink sink, <span class="predefined-type">ByteBuffer</span> content1, <span class="predefined-type">ByteBuffer</span> content2)
{
    <span class="comment">// Initiate a first write.</span>
    <span class="predefined-type">Callback</span>.Completable resultOfWrites = <span class="predefined-type">Callback</span>.Completable.with(callback1 -&gt; sink.write(<span class="predefined-constant">false</span>, content1, callback1))
        <span class="comment">// Chain a second write only when the first is complete.</span>
        .compose(callback2 -&gt; sink.write(<span class="predefined-constant">true</span>, content2, callback2));

    <span class="comment">// Use the resulting Callback.Completable as you would use a CompletableFuture.</span>
    <span class="comment">// For example:</span>
    resultOfWrites.whenComplete((ignored, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
            <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">sink</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">writes completed successfully</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">else</span>
            <span class="predefined-type">System</span>.getLogger(<span class="string"><span class="delimiter">&quot;</span><span class="content">sink</span><span class="delimiter">&quot;</span></span>).log(INFO, <span class="string"><span class="delimiter">&quot;</span><span class="content">writes failed</span><span class="delimiter">&quot;</span></span>, failure);
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you need to perform an unknown number of writes, you must use an <code>IteratingCallback</code>, explained in <a href="#pg-arch-io-echo">this section</a>, to avoid <code>StackOverFlowError</code>s.</p>
</div>
<div class="paragraph">
<p>For example, to copy from a <code>Content.Source</code> to a <code>Content.Sink</code> you should use the convenience method <code>Content.copy(Content.Source, Content.Sink, Callback)</code>.
For illustrative purposes, below you can find the implementation of <code>copy(Content.Source, Content.Sink, Callback)</code> that uses an <code>IteratingCallback</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@SuppressWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">InnerClassMayBeStatic</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">Copy</span> <span class="directive">extends</span> IteratingCallback
{
    <span class="directive">private</span> <span class="directive">final</span> Content.Source source;
    <span class="directive">private</span> <span class="directive">final</span> Content.Sink sink;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Callback</span> callback;
    <span class="directive">private</span> Content.Chunk chunk;

    <span class="directive">public</span> Copy(Content.Source source, Content.Sink sink, <span class="predefined-type">Callback</span> callback)
    {
        <span class="local-variable">this</span>.source = source;
        <span class="local-variable">this</span>.sink = sink;
        <span class="comment">// The callback to notify when the copy is completed.</span>
        <span class="local-variable">this</span>.callback = callback;
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="predefined-type">Action</span> process() <span class="directive">throws</span> <span class="predefined-type">Throwable</span>
    {
        <span class="comment">// If the last write completed, succeed this IteratingCallback,</span>
        <span class="comment">// causing onCompleteSuccess() to be invoked.</span>
        <span class="keyword">if</span> (chunk != <span class="predefined-constant">null</span> &amp;&amp; chunk.isLast())
            <span class="keyword">return</span> <span class="predefined-type">Action</span>.SUCCEEDED;

        <span class="comment">// Read a chunk.</span>
        chunk = source.read();

        <span class="comment">// No chunk, demand to be called back when there will be more chunks.</span>
        <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
        {
            source.demand(<span class="local-variable">this</span>::iterate);
            <span class="keyword">return</span> <span class="predefined-type">Action</span>.IDLE;
        }

        <span class="comment">// The read failed, re-throw the failure</span>
        <span class="comment">// causing onCompleteFailure() to be invoked.</span>
        <span class="keyword">if</span> (Content.Chunk.isFailure(chunk))
            <span class="keyword">throw</span> chunk.getFailure();

        <span class="comment">// Copy the chunk.</span>
        sink.write(chunk.isLast(), chunk.getByteBuffer(), <span class="local-variable">this</span>);
        <span class="keyword">return</span> <span class="predefined-type">Action</span>.SCHEDULED;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> succeeded()
    {
        <span class="comment">// After every successful write, release the chunk.</span>
        chunk.release();
        <span class="local-variable">super</span>.succeeded();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> failed(<span class="predefined-type">Throwable</span> x)
    {
        <span class="local-variable">super</span>.failed(x);
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onCompleteSuccess()
    {
        <span class="comment">// The copy is succeeded, succeed the callback.</span>
        callback.succeeded();
    }

    <span class="annotation">@Override</span>
    <span class="directive">protected</span> <span class="type">void</span> onCompleteFailure(<span class="predefined-type">Throwable</span> failure)
    {
        <span class="comment">// In case of a failure, either on the</span>
        <span class="comment">// read or on the write, release the chunk.</span>
        chunk.release();

        <span class="comment">// The copy is failed, fail the callback.</span>
        callback.failed(failure);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> InvocationType getInvocationType()
    {
        <span class="keyword">return</span> InvocationType.NON_BLOCKING;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Non-blocking writes can be easily turned in blocking writes.
This leads to perhaps code that is simpler to read, but that also comes with a price: greater resource usage that may lead to less scalability and less performance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">void</span> blockingWrite(Content.Sink sink, <span class="predefined-type">ByteBuffer</span> content1, <span class="predefined-type">ByteBuffer</span> content2) <span class="directive">throws</span> <span class="exception">IOException</span>
{
    <span class="comment">// First blocking write, returns only when the write is complete.</span>
    Content.Sink.write(sink, <span class="predefined-constant">false</span>, content1);

    <span class="comment">// Second blocking write, returns only when the write is complete.</span>
    <span class="comment">// It is legal to perform the writes sequentially, since they are blocking.</span>
    Content.Sink.write(sink, <span class="predefined-constant">true</span>, content2);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-arch-listener"><a class="anchor" href="#pg-arch-listener"></a><a class="link" href="#pg-arch-listener">Jetty Listeners</a></h3>
<div class="paragraph">
<p>The Jetty architecture is based on <a href="#pg-arch-bean">components</a>, typically organized in a component tree.
These components have an internal state that varies with the component life cycle (that is, whether the component is started or stopped), as well as with the component use at runtime.
The typical example is a thread pool, whose internal state&#8201;&#8212;&#8201;such as the number of pooled threads or the job queue size&#8201;&#8212;&#8201;changes as the thread pool is used by the running client or server.</p>
</div>
<div class="paragraph">
<p>In many cases, the component state change produces an event that is broadcast to listeners.
Applications can register listeners to these components to be notified of the events they produce.</p>
</div>
<div class="paragraph">
<p>This section lists the listeners available in the Jetty components, but the events and listener APIs are discussed in the component specific sections.</p>
</div>
<div class="paragraph">
<p>Listeners common to both client and server:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pg-arch-bean-listener">Jetty Component Listeners</a></p>
</li>
<li>
<p><a href="#pg-arch-io-connection-listener">Jetty I/O: <code>Connection.Listener</code></a></p>
</li>
<li>
<p><a href="#pg-client-http-configuration-tls-listener">HttpClient <code>SslHandshakeListener</code></a></p>
</li>
<li>
<p><a href="#pg-server-http-connector-protocol">Configuring Protocols</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Listeners that are server specific:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#pg-server-http-request-processing-events">Request Processing Events</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="pg-arch-jmx"><a class="anchor" href="#pg-arch-jmx"></a><a class="link" href="#pg-arch-jmx">Jetty JMX Support</a></h3>
<div class="paragraph">
<p>The Java Management Extensions (JMX) APIs are standard API for managing and monitoring resources such as applications, devices, services, and the Java Virtual Machine itself.</p>
</div>
<div class="paragraph">
<p>The JMX API includes remote access, so a remote management console such as <a href="https://openjdk.java.net/projects/jmc/">Java Mission Control</a> can interact with a running application for these purposes.</p>
</div>
<div class="paragraph">
<p>Jetty architecture is based on <a href="#pg-arch-bean">components</a> organized in a tree. Every time a component is added to or removed from the component tree, an event is emitted, and <a href="#pg-arch-bean-listener-container">Container.Listener</a> implementations can listen to those events and perform additional actions.</p>
</div>
<div class="paragraph">
<p><code>org.eclipse.jetty.jmx.MBeanContainer</code> listens to those events and registers/unregisters the Jetty components as MBeans into the platform MBeanServer.</p>
</div>
<div class="paragraph">
<p>The Jetty components are annotated with <a href="#pg-arch-jmx-annotation">Jetty JMX annotations</a> so that they can provide specific JMX metadata such as attributes and operations that should be exposed via JMX.</p>
</div>
<div class="paragraph">
<p>Therefore, when a component is added to the component tree, <code>MBeanContainer</code> is notified, it creates the MBean from the component POJO and registers it to the <code>MBeanServer</code>.
Similarly, when a component is removed from the tree, <code>MBeanContainer</code> is notified, and unregisters the MBean from the <code>MBeanServer</code>.</p>
</div>
<div class="paragraph">
<p>The Maven coordinates for the Jetty JMX support are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="xml"><span class="tag">&lt;dependency&gt;</span>
  <span class="tag">&lt;groupId&gt;</span>org.eclipse.jetty<span class="tag">&lt;/groupId&gt;</span>
  <span class="tag">&lt;artifactId&gt;</span>jetty-jmx<span class="tag">&lt;/artifactId&gt;</span>
  <span class="tag">&lt;version&gt;</span>12.0.10-SNAPSHOT<span class="tag">&lt;/version&gt;</span>
<span class="tag">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="pg-enabling-jmx-support"><a class="anchor" href="#pg-enabling-jmx-support"></a><a class="link" href="#pg-enabling-jmx-support">Enabling JMX Support</a></h4>
<div class="paragraph">
<p>Enabling JMX support is always recommended because it provides valuable information about the system, both for monitoring purposes and for troubleshooting purposes in case of problems.</p>
</div>
<div class="paragraph">
<p>To enable JMX support on the server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Create an MBeanContainer with the platform MBeanServer.</span>
MBeanContainer mbeanContainer = <span class="keyword">new</span> MBeanContainer(<span class="predefined-type">ManagementFactory</span>.getPlatformMBeanServer());

<span class="comment">// Add MBeanContainer to the root component.</span>
server.addBean(mbeanContainer);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly on the client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">HttpClient httpClient = <span class="keyword">new</span> HttpClient();

<span class="comment">// Create an MBeanContainer with the platform MBeanServer.</span>
MBeanContainer mbeanContainer = <span class="keyword">new</span> MBeanContainer(<span class="predefined-type">ManagementFactory</span>.getPlatformMBeanServer());

<span class="comment">// Add MBeanContainer to the root component.</span>
httpClient.addBean(mbeanContainer);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The MBeans exported to the platform MBeanServer can only be accessed locally (from the same machine), not from remote machines.</p>
</div>
<div class="paragraph">
<p>This means that this configuration is enough for development, where you have easy access (with graphical user interface) to the machine where Jetty runs, but it is typically not enough when the machine where Jetty runs is remote, or only accessible via SSH or otherwise without graphical user interface support.
In these cases, you have to enable <a href="#pg-arch-jmx-remote">JMX Remote Access</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-jmx-remote"><a class="anchor" href="#pg-arch-jmx-remote"></a><a class="link" href="#pg-arch-jmx-remote">Enabling JMX Remote Access</a></h4>
<div class="paragraph">
<p>There are two ways of enabling remote connectivity so that JMC can connect to the remote JVM to visualize MBeans.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>com.sun.management.jmxremote</code> system property on the command line.
Unfortunately, this solution does not work well with firewalls and is not flexible.</p>
</li>
<li>
<p>Use Jetty&#8217;s <code>ConnectorServer</code> class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>org.eclipse.jetty.jmx.ConnectorServer</code> will use by default RMI to allow connection from remote clients, and it is a wrapper around the standard JDK class <code>JMXConnectorServer</code>, which is the class that provides remote access to JMX clients.</p>
</div>
<div class="paragraph">
<p>Connecting to the remote JVM is a two step process:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>First, the client will connect to the RMI <em>registry</em> to download the RMI stub for the <code>JMXConnectorServer</code>; this RMI stub contains the IP address and port to connect to the RMI server, i.e. the remote <code>JMXConnectorServer</code>.</p>
</li>
<li>
<p>Second, the client uses the RMI stub to connect to the RMI <em>server</em> (i.e. the remote <code>JMXConnectorServer</code>) typically on an address and port that may be different from the RMI registry address and port.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The host and port configuration for the RMI registry and the RMI server is specified by a <code>JMXServiceURL</code>.
The string format of an RMI <code>JMXServiceURL</code> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">service:jmx:rmi://&lt;rmi_server_host&gt;:&lt;rmi_server_port&gt;/jndi/rmi://&lt;rmi_registry_host&gt;:&lt;rmi_registry_port&gt;/jmxrmi</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default values are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">rmi_server_host = localhost
rmi_server_port = 1099
rmi_registry_host = localhost
rmi_registry_port = 1099</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the default configuration, only clients that are local to the server machine can connect to the RMI registry and RMI server - this is done for security reasons.
With this configuration it would still be possible to access the MBeans from remote using a <a href="#pg-arch-jmx-remote-ssh-tunnel">SSH tunnel</a>.</p>
</div>
<div class="paragraph">
<p>By specifying an appropriate <code>JMXServiceURL</code>, you can fine tune the network interfaces the RMI registry and the RMI server bind to, and the ports that the RMI registry and the RMI server listen to.
The RMI server and RMI registry hosts and ports can be the same (as in the default configuration) because RMI is able to multiplex traffic arriving to a port to multiple RMI objects.</p>
</div>
<div class="paragraph">
<p>If you need to allow JMX remote access through a firewall, you must open both the RMI registry and the RMI server ports.</p>
</div>
<div class="paragraph">
<p><code>JMXServiceURL</code> common examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">service:jmx:rmi:///jndi/rmi:///jmxrmi
  rmi_server_host = local host address
  rmi_server_port = randomly chosen
  rmi_registry_host = local host address
  rmi_registry_port = 1099

service:jmx:rmi://0.0.0.0:1099/jndi/rmi://0.0.0.0:1099/jmxrmi
  rmi_server_host = any address
  rmi_server_port = 1099
  rmi_registry_host = any address
  rmi_registry_port = 1099

service:jmx:rmi://localhost:1100/jndi/rmi://localhost:1099/jmxrmi
  rmi_server_host = loopback address
  rmi_server_port = 1100
  rmi_registry_host = loopback address
  rmi_registry_port = 1099</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>When <code>ConnectorServer</code> is started, its RMI stub is exported to the RMI registry.
The RMI stub contains the IP address and port to connect to the RMI object, but the IP address is typically the machine host name, not the host specified in the <code>JMXServiceURL</code>.</p>
</div>
<div class="paragraph">
<p>To control the IP address stored in the RMI stub you need to set the system property <code>java.rmi.server.hostname</code> with the desired value.
This is especially important when binding the RMI server host to the loopback address for security reasons. See also <a href="#pg-arch-jmx-remote-ssh-tunnel">JMX Remote Access via SSH Tunnel.</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To allow JMX remote access, create and configure a <code>ConnectorServer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Setup Jetty JMX.</span>
MBeanContainer mbeanContainer = <span class="keyword">new</span> MBeanContainer(<span class="predefined-type">ManagementFactory</span>.getPlatformMBeanServer());
server.addBean(mbeanContainer);

<span class="comment">// Setup ConnectorServer.</span>

<span class="comment">// Bind the RMI server to the wildcard address and port 1999.</span>
<span class="comment">// Bind the RMI registry to the wildcard address and port 1099.</span>
<span class="predefined-type">JMXServiceURL</span> jmxURL = <span class="keyword">new</span> <span class="predefined-type">JMXServiceURL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">rmi</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="integer">1999</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/jndi/rmi:///jmxrmi</span><span class="delimiter">&quot;</span></span>);
ConnectorServer jmxServer = <span class="keyword">new</span> ConnectorServer(jmxURL, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.jmx:name=rmiconnectorserver</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Add ConnectorServer as a bean, so it is started</span>
<span class="comment">// with the Server and also exported as MBean.</span>
server.addBean(jmxServer);

server.start();</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-jmx-remote-authorization"><a class="anchor" href="#pg-arch-jmx-remote-authorization"></a><a class="link" href="#pg-arch-jmx-remote-authorization">JMX Remote Access Authorization</a></h5>
<div class="paragraph">
<p>The standard <code>JMXConnectorServer</code> provides several options to authorize access, for example via JAAS or via configuration files.
For a complete guide to controlling authentication and authorization in JMX, see <a href="https://docs.oracle.com/en/java/javase/11/management/">the official JMX documentation</a>.</p>
</div>
<div class="paragraph">
<p>In the sections below we detail one way to setup JMX authentication and authorization, using configuration files for users, passwords and roles:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Setup Jetty JMX.</span>
MBeanContainer mbeanContainer = <span class="keyword">new</span> MBeanContainer(<span class="predefined-type">ManagementFactory</span>.getPlatformMBeanServer());
server.addBean(mbeanContainer);

<span class="comment">// Setup ConnectorServer.</span>
<span class="predefined-type">JMXServiceURL</span> jmxURL = <span class="keyword">new</span> <span class="predefined-type">JMXServiceURL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">rmi</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="integer">1099</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/jndi/rmi:///jmxrmi</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; env = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
env.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.sun.management.jmxremote.access.file</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/users.access</span><span class="delimiter">&quot;</span></span>);
env.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">com.sun.management.jmxremote.password.file</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/users.password</span><span class="delimiter">&quot;</span></span>);
ConnectorServer jmxServer = <span class="keyword">new</span> ConnectorServer(jmxURL, env, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.jmx:name=rmiconnectorserver</span><span class="delimiter">&quot;</span></span>);
server.addBean(jmxServer);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>users.access</code> file format is defined in the <code>$JAVA_HOME/conf/management/jmxremote.access</code> file.
A simplified version is the following:</p>
</div>
<div class="listingblock">
<div class="title">users.access</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">user1 readonly
user2 readwrite</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>users.password</code> file format is defined in the <code>$JAVA_HOME/conf/management/jmxremote.password.template</code> file.
A simplified version is the following:</p>
</div>
<div class="listingblock">
<div class="title">users.password</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">user1 password1
user2 password2</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
The <code>users.access</code> and <code>users.password</code> files are not standard <code>*.properties</code> files&#8201;&#8212;&#8201;the user must be separated from the role or password by a space character.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="pg-securing-jmx-remote-access-with-tls"><a class="anchor" href="#pg-securing-jmx-remote-access-with-tls"></a><a class="link" href="#pg-securing-jmx-remote-access-with-tls">Securing JMX Remote Access with TLS</a></h5>
<div class="paragraph">
<p>The JMX communication via RMI happens by default in clear-text.</p>
</div>
<div class="paragraph">
<p>It is possible to configure the <code>ConnectorServer</code> with a <code>SslContextFactory</code> so that the JMX communication via RMI is encrypted:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">Server server = <span class="keyword">new</span> Server();

<span class="comment">// Setup Jetty JMX.</span>
MBeanContainer mbeanContainer = <span class="keyword">new</span> MBeanContainer(<span class="predefined-type">ManagementFactory</span>.getPlatformMBeanServer());
server.addBean(mbeanContainer);

<span class="comment">// Setup SslContextFactory.</span>
SslContextFactory.Server sslContextFactory = <span class="keyword">new</span> SslContextFactory.Server();
sslContextFactory.setKeyStorePath(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/keystore</span><span class="delimiter">&quot;</span></span>);
sslContextFactory.setKeyStorePassword(<span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="comment">// Setup ConnectorServer with SslContextFactory.</span>
<span class="predefined-type">JMXServiceURL</span> jmxURL = <span class="keyword">new</span> <span class="predefined-type">JMXServiceURL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">rmi</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">null</span>, <span class="integer">1099</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/jndi/rmi:///jmxrmi</span><span class="delimiter">&quot;</span></span>);
ConnectorServer jmxServer = <span class="keyword">new</span> ConnectorServer(jmxURL, <span class="predefined-constant">null</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">org.eclipse.jetty.jmx:name=rmiconnectorserver</span><span class="delimiter">&quot;</span></span>, sslContextFactory);
server.addBean(jmxServer);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to use the same <code>SslContextFactory.Server</code> used to configure the Jetty <code>ServerConnector</code> that supports TLS also for the JMX communication via RMI.</p>
</div>
<div class="paragraph">
<p>The keystore must contain a valid certificate signed by a Certification Authority.</p>
</div>
<div class="paragraph">
<p>The RMI mechanic is the usual one: the RMI client (typically a monitoring console) will connect first to the RMI registry (using TLS), download the RMI server stub that contains the address and port of the RMI server to connect to, then connect to the RMI server (using TLS).</p>
</div>
<div class="paragraph">
<p>This also mean that if the RMI registry and the RMI server are on different hosts, the RMI client must have available the cryptographic material to validate both hosts.</p>
</div>
<div class="paragraph">
<p>Having certificates signed by a Certification Authority simplifies by a lot the configuration needed to get the JMX communication over TLS working properly.</p>
</div>
<div class="paragraph">
<p>If that is not the case (for example the certificate is self-signed), then you need to specify the required system properties that allow RMI (especially when acting as an RMI client) to retrieve the cryptographic material necessary to establish the TLS connection.</p>
</div>
<div class="paragraph">
<p>For example, trying to connect using the JDK standard <code>JMXConnector</code> with both the RMI server and the RMI registry via TLS to <code>domain.com</code> with a self-signed certificate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// System properties necessary for an RMI client to trust a self-signed certificate.</span>
<span class="predefined-type">System</span>.setProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">javax.net.ssl.trustStore</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/path/to/trustStore</span><span class="delimiter">&quot;</span></span>);
<span class="predefined-type">System</span>.setProperty(<span class="string"><span class="delimiter">&quot;</span><span class="content">javax.net.ssl.trustStorePassword</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">secret</span><span class="delimiter">&quot;</span></span>);

<span class="predefined-type">JMXServiceURL</span> jmxURL = <span class="keyword">new</span> <span class="predefined-type">JMXServiceURL</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">service:jmx:rmi:///jndi/rmi://domain.com:1100/jmxrmi</span><span class="delimiter">&quot;</span></span>);

<span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; clientEnv = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();
<span class="comment">// Required to connect to the RMI registry via TLS.</span>
clientEnv.put(ConnectorServer.RMI_REGISTRY_CLIENT_SOCKET_FACTORY_ATTRIBUTE, <span class="keyword">new</span> <span class="predefined-type">SslRMIClientSocketFactory</span>());

<span class="keyword">try</span> (<span class="predefined-type">JMXConnector</span> client = <span class="predefined-type">JMXConnectorFactory</span>.connect(jmxURL, clientEnv))
{
    <span class="predefined-type">Set</span>&lt;<span class="predefined-type">ObjectName</span>&gt; names = client.getMBeanServerConnection().queryNames(<span class="predefined-constant">null</span>, <span class="predefined-constant">null</span>);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, to launch JMC:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">$ jmc -vmargs -Djavax.net.ssl.trustStore=/path/to/trustStore -Djavax.net.ssl.trustStorePassword=secret</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
These system properties are required when launching the <code>ConnectorServer</code> too, on the server, because it acts as an RMI client with respect to the RMI registry.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="pg-arch-jmx-remote-ssh-tunnel"><a class="anchor" href="#pg-arch-jmx-remote-ssh-tunnel"></a><a class="link" href="#pg-arch-jmx-remote-ssh-tunnel">JMX Remote Access with Port Forwarding via SSH Tunnel</a></h5>
<div class="paragraph">
<p>You can access JMX MBeans on a remote machine when the RMI ports are not open, for example because of firewall policies, but you have SSH access to the machine using local port forwarding via an SSH tunnel.</p>
</div>
<div class="paragraph">
<p>In this case you want to configure the <code>ConnectorServer</code> with a <code>JMXServiceURL</code> that binds the RMI server and the RMI registry to the loopback interface only: <code>service:jmx:rmi://localhost:1099/jndi/rmi://localhost:1099/jmxrmi</code>.</p>
</div>
<div class="paragraph">
<p>Then you setup the local port forwarding with the SSH tunnel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">$ ssh -L 1099:localhost:1099 &lt;user&gt;@&lt;machine_host&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can use JConsole or JMC to connect to <code>localhost:1099</code> on your local computer.
The traffic will be forwarded to <code>machine_host</code> and when there, SSH will forward the traffic to <code>localhost:1099</code>, which is exactly where the <code>ConnectorServer</code> listens.</p>
</div>
<div class="paragraph">
<p>When you configure <code>ConnectorServer</code> in this way, you must set the system property <code>-Djava.rmi.server.hostname=localhost</code>, on the server.
This is required because when the RMI server is exported, its address and port are stored in the RMI stub. You want the address in the RMI stub to be <code>localhost</code> so that when the RMI stub is downloaded to the remote client, the RMI communication will go through the SSH tunnel.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-arch-jmx-annotation"><a class="anchor" href="#pg-arch-jmx-annotation"></a><a class="link" href="#pg-arch-jmx-annotation">Jetty JMX Annotations</a></h4>
<div class="paragraph">
<p>The Jetty JMX support, and in particular <code>MBeanContainer</code>, is notified every time a bean is added to the component tree.</p>
</div>
<div class="paragraph">
<p>The bean is scanned for Jetty JMX annotations to obtain JMX metadata: the JMX attributes and JMX operations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">// Annotate the class with @ManagedObject and provide a description.</span>
<span class="annotation">@ManagedObject</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Services that provide useful features</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">Services</span>
{
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; services = <span class="keyword">new</span> <span class="predefined-type">ConcurrentHashMap</span>&lt;&gt;();
    <span class="directive">private</span> <span class="type">boolean</span> enabled = <span class="predefined-constant">true</span>;

    <span class="comment">// A read-only attribute with description.</span>
    <span class="annotation">@ManagedAttribute</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">The number of services</span><span class="delimiter">&quot;</span></span>, readonly = <span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="type">int</span> getServiceCount()
    {
        <span class="keyword">return</span> services.size();
    }

    <span class="comment">// A read-write attribute with description.</span>
    <span class="comment">// Only the getter is annotated.</span>
    <span class="annotation">@ManagedAttribute</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">Whether the services are enabled</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isEnabled()
    {
        <span class="keyword">return</span> enabled;
    }

    <span class="comment">// There is no need to annotate the setter.</span>
    <span class="directive">public</span> <span class="type">void</span> setEnabled(<span class="type">boolean</span> enabled)
    {
        <span class="local-variable">this</span>.enabled = enabled;
    }

    <span class="comment">// An operation with description and impact.</span>
    <span class="comment">// The @Name annotation is used to annotate parameters</span>
    <span class="comment">// for example to display meaningful parameter names.</span>
    <span class="annotation">@ManagedOperation</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">Retrieves the service with the given name</span><span class="delimiter">&quot;</span></span>, impact = <span class="string"><span class="delimiter">&quot;</span><span class="content">INFO</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">Object</span> getService(<span class="annotation">@Name</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">serviceName</span><span class="delimiter">&quot;</span></span>) <span class="predefined-type">String</span> n)
    {
        <span class="keyword">return</span> services.get(n);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JMX metadata and the bean are wrapped by an instance of <code>org.eclipse.jetty.jmx.ObjectMBean</code> that exposes the JMX metadata and, upon request from JMX consoles, invokes methods on the bean to get/set attribute values and perform operations.</p>
</div>
<div class="paragraph">
<p>You can provide a custom subclass of <code>ObjectMBean</code> to further customize how the bean is exposed to JMX.</p>
</div>
<div class="paragraph">
<p>The custom <code>ObjectMBean</code> subclass must respect the following naming convention: <code>&lt;package&gt;.jmx.&lt;class&gt;MBean</code>.
For example, class <code>com.acme.Foo</code> may have a custom <code>ObjectMBean</code> subclass named <code>com.acme.<strong>jmx</strong>.Foo<strong>MBean</strong></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//package com.acme;</span>
<span class="annotation">@ManagedObject</span>
<span class="type">class</span> <span class="class">Service</span>
{
}

<span class="comment">//package com.acme.jmx;</span>
<span class="type">class</span> <span class="class">ServiceMBean</span> <span class="directive">extends</span> ObjectMBean
{
    ServiceMBean(<span class="predefined-type">Object</span> service)
    {
        <span class="local-variable">super</span>(service);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The custom <code>ObjectMBean</code> subclass is also scanned for Jetty JMX annotations and overrides the JMX metadata obtained by scanning the bean class.
This allows to annotate only the custom <code>ObjectMBean</code> subclass and keep the bean class free of the Jetty JMX annotations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="comment">//package com.acme;</span>
<span class="comment">// No Jetty JMX annotations.</span>
<span class="type">class</span> <span class="class">CountService</span>
{
    <span class="directive">private</span> <span class="type">int</span> count;

    <span class="directive">public</span> <span class="type">int</span> getCount()
    {
        <span class="keyword">return</span> count;
    }

    <span class="directive">public</span> <span class="type">void</span> addCount(<span class="type">int</span> value)
    {
        count += value;
    }
}

<span class="comment">//package com.acme.jmx;</span>
<span class="annotation">@ManagedObject</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">the count service</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">CountServiceMBean</span> <span class="directive">extends</span> ObjectMBean
{
    <span class="directive">public</span> CountServiceMBean(<span class="predefined-type">Object</span> service)
    {
        <span class="local-variable">super</span>(service);
    }

    <span class="directive">private</span> CountService getCountService()
    {
        <span class="keyword">return</span> (CountService)<span class="local-variable">super</span>.getManagedObject();
    }

    <span class="annotation">@ManagedAttribute</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">the current service count</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">int</span> getCount()
    {
        <span class="keyword">return</span> getCountService().getCount();
    }

    <span class="annotation">@ManagedOperation</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">adds the given value to the service count</span><span class="delimiter">&quot;</span></span>, impact = <span class="string"><span class="delimiter">&quot;</span><span class="content">ACTION</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> addCount(<span class="annotation">@Name</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">count delta</span><span class="delimiter">&quot;</span></span>) <span class="type">int</span> value)
    {
        getCountService().addCount(value);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scan for Jetty JMX annotations is performed on the bean class and all the interfaces implemented by the bean class, then on the super-class and all the interfaces implemented by the super-class and so on until <code>java.lang.Object</code> is reached.
For each type&#8201;&#8212;&#8201;class or interface, the corresponding <code>*.jmx.*MBean</code> is looked up and scanned as well with the same algorithm.
For each type, the scan looks for the class-level annotation <code>@ManagedObject</code>.
If it is found, the scan looks for method-level <code>@ManagedAttribute</code> and <code>@ManagedOperation</code> annotations; otherwise it skips the current type and moves to the next type to scan.</p>
</div>
<div class="sect4">
<h5 id="pg-managedobject"><a class="anchor" href="#pg-managedobject"></a><a class="link" href="#pg-managedobject">@ManagedObject</a></h5>
<div class="paragraph">
<p>The <code>@ManagedObject</code> annotation is used on a class at the top level to indicate that it should be exposed as an MBean.
It has only one attribute to it which is used as the description of the MBean.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-managedattribute"><a class="anchor" href="#pg-managedattribute"></a><a class="link" href="#pg-managedattribute">@ManagedAttribute</a></h5>
<div class="paragraph">
<p>The <code>@ManagedAttribute</code> annotation is used to indicate that a given method is exposed as a JMX attribute.
This annotation is placed always on the getter method of a given attribute.
Unless the <code>readonly</code> attribute is set to <code>true</code> in the annotation, a corresponding setter is looked up following normal naming conventions.
For example if this annotation is on a method called <code>String getFoo()</code> then a method called <code>void setFoo(String)</code> would be looked up, and if found wired as the setter for the JMX attribute.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-managedoperation"><a class="anchor" href="#pg-managedoperation"></a><a class="link" href="#pg-managedoperation">@ManagedOperation</a></h5>
<div class="paragraph">
<p>The <code>@ManagedOperation</code> annotation is used to indicate that a given method is exposed as a JMX operation.
A JMX operation has an <em>impact</em> that can be <code>INFO</code> if the operation returns a value without modifying the object, <code>ACTION</code> if the operation does not return a value but modifies the object, and "ACTION_INFO" if the operation both returns a value and modifies the object.
If the <em>impact</em> is not specified, it has the default value of <code>UNKNOWN</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-name"><a class="anchor" href="#pg-name"></a><a class="link" href="#pg-name">@Name</a></h5>
<div class="paragraph">
<p>The <code>@Name</code> annotation is used to assign a name and description to parameters in method signatures so that when rendered by JMX consoles it is clearer what the parameter meaning is.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pg-troubleshooting"><a class="anchor" href="#pg-troubleshooting"></a><a class="link" href="#pg-troubleshooting">Appendix B: Troubleshooting Jetty</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO: introduction</p>
</div>
<div class="sect2">
<h3 id="pg-troubleshooting-logging"><a class="anchor" href="#pg-troubleshooting-logging"></a><a class="link" href="#pg-troubleshooting-logging">Logging</a></h3>
<div class="paragraph">
<p>The Jetty libraries (both client and server) use <a href="http://slf4j.org/">SLF4J</a> as logging APIs.
You can therefore plug in any SLF4J logging implementation, and configure the logging category <code>org.eclipse.jetty</code> at the desired level.</p>
</div>
<div class="paragraph">
<p>When you have problems with Jetty, the first thing that you want to do is to enable DEBUG logging.
This is helpful because by reading the DEBUG logs you get a better understanding of what is going on in the system (and that alone may give you the answers you need to fix the problem), and because Jetty developers will probably need the DEBUG logs to help you.</p>
</div>
<div class="sect3">
<h4 id="pg-jetty-slf4j-binding"><a class="anchor" href="#pg-jetty-slf4j-binding"></a><a class="link" href="#pg-jetty-slf4j-binding">Jetty SLF4J Binding</a></h4>
<div class="paragraph">
<p>The Jetty artifact <code>jetty-slf4j-impl</code> is a SLF4J binding, that is the Jetty implementation of the SLF4J APIs, and provides a number of easy-to-use features to configure logging.</p>
</div>
<div class="paragraph">
<p>The Jetty SLF4J binding only provides an appender that writes to <code>System.err</code>.
For more advanced configurations (for example, logging to a file), use <a href="http://logback.qos.ch">LogBack</a>, or <a href="https://logging.apache.org/log4j/2.x/">Log4j2</a>, or your preferred SLF4J binding.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Only one binding can be present in the class-path or module-path. If you use the LogBack SLF4J binding or the Log4j2 SLF4J binding, remember to remove the Jetty SLF4J binding.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The Jetty SLF4J binding reads a file in the class-path (or module-path) called <code>jetty-logging.properties</code> that can be configured with the logging levels for various logger categories:</p>
</div>
<div class="listingblock">
<div class="title">jetty-logging.properties</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen"># By default, log at INFO level all Jetty classes.
org.eclipse.jetty.LEVEL=INFO

# However, the Jetty client classes are logged at DEBUG level.
org.eclipse.jetty.client.LEVEL=DEBUG</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly to how you configure the <code>jetty-logging.properties</code> file, you can set the system property <code>org.eclipse.jetty[.&lt;package_names&gt;].LEVEL=DEBUG</code> to quickly change the logging level to DEBUG without editing any file.
The system property can be set on the command line, or in your IDE when you run your tests or your Jetty-based application and will override the <code>jetty-logging.properties</code> file configuration.
For example to enable DEBUG logging for all the Jetty classes (<em>very</em> verbose):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">java -Dorg.eclipse.jetty.LEVEL=DEBUG --class-path ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to enable DEBUG logging but only for the HTTP/2 classes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">java -Dorg.eclipse.jetty.http2.LEVEL=DEBUG --class-path ...</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-troubleshooting-thread-dump"><a class="anchor" href="#pg-troubleshooting-thread-dump"></a><a class="link" href="#pg-troubleshooting-thread-dump">JVM Thread Dump</a></h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="pg-troubleshooting-component-dump"><a class="anchor" href="#pg-troubleshooting-component-dump"></a><a class="link" href="#pg-troubleshooting-component-dump">Jetty Component Tree Dump</a></h3>
<div class="paragraph">
<p>Jetty components are organized in a <a href="#pg-arch-bean">component tree</a>.</p>
</div>
<div class="paragraph">
<p>At the root of the component tree there is typically a <code>ContainerLifeCycle</code> instance&#8201;&#8212;&#8201;typically a <code>Server</code> instance on the server and an <code>HttpClient</code> instance on the client.</p>
</div>
<div class="paragraph">
<p><code>ContainerLifeCycle</code> has built-in <em>dump</em> APIs that can be invoked either directly or <a href="#pg-arch-jmx">via JMX</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can get more details from a Jetty&#8217;s <code>QueuedThreadPool</code> dump by enabling detailed dumps via <code>queuedThreadPool.setDetailedDump(true)</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="pg-troubleshooting-debugging"><a class="anchor" href="#pg-troubleshooting-debugging"></a><a class="link" href="#pg-troubleshooting-debugging">Debugging</a></h3>
<div class="paragraph">
<p>Sometimes, in order to figure out a problem, enabling <a href="#pg-troubleshooting-logging">DEBUG logging</a> is not enough and you really need to debug the code with a debugger.</p>
</div>
<div class="paragraph">
<p>Debugging an embedded Jetty application is most easily done from your preferred IDE, so refer to your IDE instruction for how to debug Java applications.</p>
</div>
<div class="paragraph">
<p>Remote debugging can be enabled in a Jetty application via command line options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="screen">java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000 --class-path ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above enables remote debugging so that debuggers (for example, your preferred IDE) can connect to port <code>8000</code> on the host running the Jetty application to receive debugging events.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
More technically, remote debugging exchanges JVM Tools Interface (JVMTI) events and commands via the Java Debug Wire Protocol (JDWP).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pg-migration"><a class="anchor" href="#pg-migration"></a><a class="link" href="#pg-migration">Appendix C: Migration Guides</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="pg-migration-94-to-10"><a class="anchor" href="#pg-migration-94-to-10"></a><a class="link" href="#pg-migration-94-to-10">Migrating from Jetty 9.4.x to Jetty 10.0.x</a></h3>
<div class="sect3">
<h4 id="pg-migration-94-to-10-java-version"><a class="anchor" href="#pg-migration-94-to-10-java-version"></a><a class="link" href="#pg-migration-94-to-10-java-version">Required Java Version Changes</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 9.4.x</th>
<th class="tableblock halign-left valign-top">Jetty 10.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 11</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="pg-migration-94-to-10-websocket"><a class="anchor" href="#pg-migration-94-to-10-websocket"></a><a class="link" href="#pg-migration-94-to-10-websocket">WebSocket Migration Guide</a></h4>
<div class="paragraph">
<p>Migrating from Jetty 9.4.x to Jetty 10.0.x requires changes in the coordinates of the Maven artifact dependencies for WebSocket. Some of these classes have also changed name and package. This is not a comprehensive list of changes but should cover the most common changes encountered during migration.</p>
</div>
<div class="sect4">
<h5 id="pg-migration-94-to-10-websocket-maven-artifact-changes"><a class="anchor" href="#pg-migration-94-to-10-websocket-maven-artifact-changes"></a><a class="link" href="#pg-migration-94-to-10-websocket-maven-artifact-changes">Maven Artifacts Changes</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 9.4.x</th>
<th class="tableblock halign-left valign-top">Jetty 10.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-api</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-jetty-api</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-server</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-jetty-server</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-client</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-jetty-client</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>javax-websocket-server-impl</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-javax-server</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>javax-websocket-client-impl</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket:<strong>websocket-javax-client</strong></code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="pg-migration-94-to-10-websocket-class-name-changes"><a class="anchor" href="#pg-migration-94-to-10-websocket-class-name-changes"></a><a class="link" href="#pg-migration-94-to-10-websocket-class-name-changes">Class Names Changes</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 9.4.x</th>
<th class="tableblock halign-left valign-top">Jetty 10.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.NativeWebSocketServletContainerInitializer</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.config.JettyWebSocketServletContainerInitializer</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>jsr356.server.deploy.WebSocketServerContainerInitializer</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>javax.server.config.JavaxWebSocketServletContainerInitializer</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>servlet.WebSocketCreator</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.JettyWebSocketCreator</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>servlet.ServletUpgradeRequest</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.JettyServerUpgradeRequest</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>servlet.ServletUpgradeResponse</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.JettyServerUpgradeResponse</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>servlet.WebSocketServlet</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.JettyWebSocketServlet</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>servlet.WebSocketServletFactory</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.<strong>server.JettyWebSocketServletFactory</strong></code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="pg-migration-94-to-10-websocket-example-code"><a class="anchor" href="#pg-migration-94-to-10-websocket-example-code"></a><a class="link" href="#pg-migration-94-to-10-websocket-example-code">Example Code</a></h5>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 9.4.x</th>
<th class="tableblock halign-left valign-top">Jetty 10.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleWebSocketServlet</span> <span class="directive">extends</span> WebSocketServlet
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configure(WebSocketServletFactory factory)
    {
        factory.setCreator(<span class="keyword">new</span> WebSocketCreator()
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="predefined-type">Object</span> createWebSocket(ServletUpgradeRequest req, ServletUpgradeResponse resp)
            {
                <span class="keyword">return</span> <span class="keyword">new</span> ExampleEndpoint();
            }
        });
    }
}</code></pre>
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ExampleWebSocketServlet</span> <span class="directive">extends</span> JettyWebSocketServlet
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> configure(JettyWebSocketServletFactory factory)
    {
        factory.setCreator(<span class="keyword">new</span> JettyWebSocketCreator()
        {
            <span class="annotation">@Override</span>
            <span class="directive">public</span> <span class="predefined-type">Object</span> createWebSocket(JettyServerUpgradeRequest req, JettyServerUpgradeResponse resp)
            {
                <span class="keyword">return</span> <span class="keyword">new</span> ExampleEndpoint();
            }
        });
    }
}</code></pre>
</div>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pg-migration-11-to-12"><a class="anchor" href="#pg-migration-11-to-12"></a><a class="link" href="#pg-migration-11-to-12">Migrating from Jetty 11.0.x to Jetty 12.0.x</a></h3>
<div class="sect3">
<h4 id="pg-migration-11-to-12-java-version"><a class="anchor" href="#pg-migration-11-to-12-java-version"></a><a class="link" href="#pg-migration-11-to-12-java-version">Required Java Version Changes</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 11.0.x</th>
<th class="tableblock halign-left valign-top">Jetty 12.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 17</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="pg-migration-11-to-12-maven-artifacts"><a class="anchor" href="#pg-migration-11-to-12-maven-artifacts"></a><a class="link" href="#pg-migration-11-to-12-maven-artifacts">Maven Artifacts Changes</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 11.0.x</th>
<th class="tableblock halign-left valign-top">Jetty 12.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.fcgi:<strong>fcgi-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.fcgi:<strong>jetty-fcgi-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.fcgi:<strong>fcgi-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.fcgi:<strong>jetty-fcgi-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>http2-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>jetty-http2-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>http2-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>jetty-http2-common</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>http2-hpack</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>jetty-http2-hpack</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>http2-http-client-transport</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>jetty-http2-client-transport</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>http2-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http2:<strong>jetty-http2-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>http3-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>jetty-http3-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>http3-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>jetty-http3-common</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>http3-http-client-transport</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>jetty-http3-client-transport</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>http3-qpack</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>jetty-http3-qpack</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>http3-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.http3:<strong>jetty-http3-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-osgi.</strong>*</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>org.eclipse.jetty:<strong>jetty-osgi</strong></p>
</li>
<li>
<p>org.eclipse.jetty.ee{8,9,10}:<strong>jetty-ee{8,9,10}-osgi-</strong>*</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-proxy</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>org.eclipse.jetty:<strong>jetty-proxy</strong></p>
</li>
<li>
<p>org.eclipse.jetty.ee{8,9,10}:<strong>jetty-ee{8,9,10}-proxy</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>quic-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>jetty-quic-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>quic-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>jetty-quic-common</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>quic-quiche</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>jetty-quic-quiche</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>quic-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.quic:<strong>jetty-quic-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-unixsocket.</strong>*</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Removed&#8201;&#8212;&#8201;Use org.eclipse.jetty:jetty-unixdomain-server</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-core-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-core-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-core-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-core-common</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-core-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-core-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-jetty-api</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-jetty-api</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-jetty-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-jetty-client</strong></p>
</li>
<li>
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:jetty-<strong>ee{8,9,10}-websocket-jetty-client</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-jetty-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-jetty-common</strong></p>
</li>
<li>
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:jetty-<strong>ee{8,9,10}-websocket-jetty-common</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.websocket:<strong>websocket-jetty-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>org.eclipse.jetty.websocket:<strong>jetty-websocket-jetty-server</strong></p>
</li>
<li>
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:jetty-<strong>ee{8,9,10}-websocket-jetty-server</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>websocket</strong>:<strong>websocket-jakarta-client</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:<strong>jetty-ee{8,9,10}-websocket-jakarta-client</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>websocket</strong>:<strong>websocket-jakarta-common</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:<strong>jetty-ee{8,9,10}-websocket-jakarta-common</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>websocket</strong>:<strong>websocket-jakarta-server</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:<strong>jetty-ee{8,9,10}-websocket-jakarta-server</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>websocket</strong>:<strong>websocket-servlet</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}.websocket</strong>:<strong>jetty-ee{8,9,10}-websocket-servlet</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>apache-jsp</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-apache-jsp</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-annotations</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-annotations</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-ant</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Removed&#8201;&#8212;&#8201;No Replacement</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-cdi</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-cdi</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>glassfish-jstl</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-glassfish-jstl</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-jaspi</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-jaspi</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-jndi</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-jndi</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-jspc-maven-plugin</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-jspc-maven-plugin</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-maven-plugin</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-maven-plugin</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-plus</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-plus</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-quickstart</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-quickstart</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-runner</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-runner</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-servlet</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-servlet</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-servlets</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-servlets</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty:<strong>jetty-webapp</strong></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>org.eclipse.jetty.<strong>ee{8,9,10}</strong>:<strong>jetty-ee{8,9,10}-webapp</strong></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="pg-migration-11-to-12-class-packages-names"><a class="anchor" href="#pg-migration-11-to-12-class-packages-names"></a><a class="link" href="#pg-migration-11-to-12-class-packages-names">Class Packages/Names Changes</a></h4>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Jetty 11.0.x</th>
<th class="tableblock halign-left valign-top">Jetty 12.0.x</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.<strong>api</strong>.*</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.*</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.<strong>util</strong>.*</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.*</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.<strong>util</strong>.*</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.*</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.<strong>http</strong>.*</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.client.<strong>transport</strong>.*</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.http2.client.<strong>http</strong>.*</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.http2.client.<strong>transport</strong>.*</code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.annotation.<strong>OnWebSocketConnect</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.annotation.<strong>OnWebSocketOpen</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>WriteCallback</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>Callback</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>WebSocket*Listener</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>Session.Listener.AutoDemanding</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>RemoteEndpoint</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>Session</strong></code></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>WebSocketPolicy</strong></code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>org.eclipse.jetty.websocket.api.<strong>Configurable</strong></code></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="pg-migration-11-to-12-servlet-to-handler"><a class="anchor" href="#pg-migration-11-to-12-servlet-to-handler"></a><a class="link" href="#pg-migration-11-to-12-servlet-to-handler">Migrate Servlets to Jetty Handlers</a></h4>
<div class="paragraph">
<p>Web applications written using the Servlet APIs may be re-written using the Jetty <code>Handler</code> APIs.
The sections below outline the Jetty <code>Handler</code> APIs that correspond to the Servlet APIs.
For more information about why using the Jetty <code>Handler</code> APIs instead of the Servlet APIs, refer to <a href="#pg-server-http">this section</a>.</p>
</div>
<div class="paragraph">
<p>For more information about replacing <code>HttpServlet</code>s or Servlet <code>Filter</code>s with Jetty <code>Handler</code>s, refer to <a href="#pg-server-http-handler">this section</a>.</p>
</div>
<div class="sect4">
<h5 id="pg-handler-request-apis"><a class="anchor" href="#pg-handler-request-apis"></a><a class="link" href="#pg-handler-request-apis">Handler Request APIs</a></h5>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">RequestAPIs</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Gets the request method.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getMethod();</span>
        <span class="predefined-type">String</span> method = request.getMethod();

        <span class="comment">// Gets the request protocol name and version.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getProtocol();</span>
        <span class="predefined-type">String</span> protocol = request.getConnectionMetaData().getProtocol();

        <span class="comment">// Gets the full request URI.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getRequestURL();</span>
        <span class="predefined-type">String</span> fullRequestURI = request.getHttpURI().asString();

        <span class="comment">// Gets the request context.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getServletContext()</span>
        <span class="predefined-type">Context</span> context = request.getContext();

        <span class="comment">// Gets the context path.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getContextPath()</span>
        <span class="predefined-type">String</span> contextPath = context.getContextPath();

        <span class="comment">// Gets the request path.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getRequestURI();</span>
        <span class="predefined-type">String</span> requestPath = request.getHttpURI().getPath();

        <span class="comment">// Gets the request path after the context path.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getServletPath() + servletRequest.getPathInfo()</span>
        <span class="predefined-type">String</span> pathInContext = Request.getPathInContext(request);

        <span class="comment">// Gets the request query.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getQueryString()</span>
        <span class="predefined-type">String</span> queryString = request.getHttpURI().getQuery();

        <span class="comment">// Gets request parameters.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getParameterNames();</span>
        <span class="comment">//   - servletRequest.getParameter(name);</span>
        <span class="comment">//   - servletRequest.getParameterValues(name);</span>
        <span class="comment">//   - servletRequest.getParameterMap();</span>
        Fields queryParameters = Request.extractQueryParameters(request, UTF_8);
        Fields allParameters = Request.getParameters(request);

        <span class="comment">// Gets cookies.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getCookies();</span>
        <span class="predefined-type">List</span>&lt;HttpCookie&gt; cookies = Request.getCookies(request);

        <span class="comment">// Gets request HTTP headers.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getHeaderNames()</span>
        <span class="comment">//   - servletRequest.getHeader(name)</span>
        <span class="comment">//   - servletRequest.getHeaders(name)</span>
        <span class="comment">//   - servletRequest.getDateHeader(name)</span>
        <span class="comment">//   - servletRequest.getIntHeader(name)</span>
        HttpFields requestHeaders = request.getHeaders();

        <span class="comment">// Gets the request Content-Type.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getContentType()</span>
        <span class="predefined-type">String</span> contentType = request.getHeaders().get(HttpHeader.CONTENT_TYPE);

        <span class="comment">// Gets the request Content-Length.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getContentLength()</span>
        <span class="comment">//   - servletRequest.getContentLengthLong()</span>
        <span class="type">long</span> contentLength = request.getLength();

        <span class="comment">// Gets the request locales.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getLocale()</span>
        <span class="comment">//   - servletRequest.getLocales()</span>
        <span class="predefined-type">List</span>&lt;<span class="predefined-type">Locale</span>&gt; locales = Request.getLocales(request);

        <span class="comment">// Gets the request scheme.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getScheme()</span>
        <span class="predefined-type">String</span> scheme = request.getHttpURI().getScheme();

        <span class="comment">// Gets the server name.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getServerName()</span>
        <span class="predefined-type">String</span> serverName = Request.getServerName(request);

        <span class="comment">// Gets the server port.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getServerPort()</span>
        <span class="type">int</span> serverPort = Request.getServerPort(request);

        <span class="comment">// Gets the remote host/address.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getRemoteAddr()</span>
        <span class="comment">//   - servletRequest.getRemoteHost()</span>
        <span class="predefined-type">String</span> remoteAddress = Request.getRemoteAddr(request);

        <span class="comment">// Gets the remote port.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getRemotePort()</span>
        <span class="type">int</span> remotePort = Request.getRemotePort(request);

        <span class="comment">// Gets the local host/address.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getLocalAddr()</span>
        <span class="comment">//   - servletRequest.getLocalHost()</span>
        <span class="predefined-type">String</span> localAddress = Request.getLocalAddr(request);

        <span class="comment">// Gets the local port.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getLocalPort()</span>
        <span class="type">int</span> localPort = Request.getLocalPort(request);

        <span class="comment">// Gets the request attributes.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getAttributeNames()</span>
        <span class="comment">//   - servletRequest.getAttribute(name)</span>
        <span class="comment">//   - servletRequest.setAttribute(name, value)</span>
        <span class="comment">//   - servletRequest.removeAttribute(name)</span>
        <span class="predefined-type">String</span> name = <span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>;
        <span class="predefined-type">Object</span> value = <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>;
        <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; names = request.getAttributeNameSet();
        <span class="predefined-type">Object</span> attribute = request.getAttribute(name);
        <span class="predefined-type">Object</span> oldValue = request.setAttribute(name, value);
        <span class="predefined-type">Object</span> removedValue = request.removeAttribute(name);
        request.clearAttributes();
        <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Object</span>&gt; map = request.asAttributeMap();

        <span class="comment">// Gets the request trailers.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getTrailerFields()</span>
        HttpFields trailers = request.getTrailers();

        <span class="comment">// Gets the HTTP session.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletRequest.getSession()</span>
        <span class="comment">//   - servletRequest.getSession(create)</span>
        <span class="type">boolean</span> create = <span class="predefined-constant">true</span>;
        Session session = request.getSession(create);

        callback.succeeded();
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-handler-request-content-apis"><a class="anchor" href="#pg-handler-request-content-apis"></a><a class="link" href="#pg-handler-request-content-apis">Handler Request Content APIs</a></h5>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Non-blocking read the request content as a String.</span>
    <span class="comment">// Use with caution as the request content may be large.</span>
    CompletableFuture&lt;<span class="predefined-type">String</span>&gt; completable = Content.Source.asStringAsync(request, UTF_8);

    completable.whenComplete((requestContent, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Process the request content here.</span>

            <span class="comment">// Implicitly respond with status code 200 and no content.</span>
            callback.succeeded();
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Implicitly respond with status code 500.</span>
            callback.failed(failure);
        }
    });

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Non-blocking read the request content as a ByteBuffer.</span>
    <span class="comment">// Use with caution as the request content may be large.</span>
    CompletableFuture&lt;<span class="predefined-type">ByteBuffer</span>&gt; completable = Content.Source.asByteBufferAsync(request);

    completable.whenComplete((requestContent, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Process the request content here.</span>

            <span class="comment">// Implicitly respond with status code 200 and no content.</span>
            callback.succeeded();
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Implicitly respond with status code 500.</span>
            callback.failed(failure);
        }
    });

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Read the request content as an InputStream.</span>
    <span class="comment">// Note that InputStream.read() may block.</span>
    <span class="keyword">try</span> (<span class="predefined-type">InputStream</span> inputStream = Content.Source.asInputStream(request))
    {
        <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
        {
            <span class="type">int</span> read = inputStream.read();

            <span class="comment">// EOF was reached, stop reading.</span>
            <span class="keyword">if</span> (read &lt; <span class="integer">0</span>)
                <span class="keyword">break</span>;

            <span class="comment">// Process the read byte here.</span>
        }
    }

    <span class="comment">// Implicitly respond with status code 200 and no content.</span>
    callback.succeeded();
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    CompletableTask&lt;<span class="predefined-type">Void</span>&gt; reader = <span class="keyword">new</span> CompletableTask&lt;&gt;()
    {
        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">void</span> run()
        {
            <span class="comment">// Read in a loop.</span>
            <span class="keyword">while</span> (<span class="predefined-constant">true</span>)
            {
                <span class="comment">// Read a chunk of content.</span>
                Content.Chunk chunk = request.read();

                <span class="comment">// If there is no content, demand to be</span>
                <span class="comment">// called back when more content is available.</span>
                <span class="keyword">if</span> (chunk == <span class="predefined-constant">null</span>)
                {
                    request.demand(<span class="local-variable">this</span>);
                    <span class="keyword">return</span>;
                }

                <span class="comment">// If a failure is read, complete with a failure.</span>
                <span class="keyword">if</span> (Content.Chunk.isFailure(chunk))
                {
                    <span class="predefined-type">Throwable</span> failure = chunk.getFailure();
                    completeExceptionally(failure);
                    <span class="keyword">return</span>;
                }

                <span class="keyword">if</span> (chunk <span class="keyword">instanceof</span> Trailers trailers)
                {
                    <span class="comment">// Possibly process the request trailers here.</span>
                    <span class="comment">// Trailers have an empty ByteBuffer and are a last chunk.</span>
                }

                <span class="comment">// Process the request content chunk here.</span>
                <span class="comment">// After the processing, the chunk MUST be released.</span>
                chunk.release();

                <span class="comment">// If the last chunk is read, complete normally.</span>
                <span class="keyword">if</span> (chunk.isLast())
                {
                    complete(<span class="predefined-constant">null</span>);
                    <span class="keyword">return</span>;
                }

                <span class="comment">// Not the last chunk of content, loop around to read more.</span>
            }
        }
    };

    <span class="comment">// Initiate the read of the request content.</span>
    reader.start();

    <span class="comment">// When the read is complete, complete the Handler callback.</span>
    callback.completeWith(reader);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-handler-response-apis"><a class="anchor" href="#pg-handler-response-apis"></a><a class="link" href="#pg-handler-response-apis">Handler Response APIs</a></h5>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">ResponseAPIs</span> <span class="directive">extends</span> <span class="predefined-type">Handler</span>.Abstract
{
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
    {
        <span class="comment">// Sets/Gets the response HTTP status.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.setStatus(code);</span>
        <span class="comment">//   - servletResponse.getStatus();</span>
        response.setStatus(HttpStatus.OK_200);
        <span class="type">int</span> status = response.getStatus();

        <span class="comment">// Gets the response HTTP headers.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.setHeader(name, value);</span>
        <span class="comment">//   - servletResponse.addHeader(name, value);</span>
        <span class="comment">//   - servletResponse.setDateHeader(name, date);</span>
        <span class="comment">//   - servletResponse.addDateHeader(name, date);</span>
        <span class="comment">//   - servletResponse.setIntHeader(name, value);</span>
        <span class="comment">//   - servletResponse.addIntHeader(name, value);</span>
        <span class="comment">//   - servletResponse.getHeaderNames()</span>
        <span class="comment">//   - servletResponse.getHeader(name)</span>
        <span class="comment">//   - servletResponse.getHeaders(name)</span>
        <span class="comment">//   - servletResponse.containsHeader(name)</span>
        HttpFields.Mutable responseHeaders = response.getHeaders();

        <span class="comment">// Sets an HTTP cookie.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - Cookie cookie = new Cookie(&quot;name&quot;, &quot;value&quot;);</span>
        <span class="comment">//   - cookie.setDomain(&quot;example.org&quot;);</span>
        <span class="comment">//   - cookie.setPath(&quot;/path&quot;);</span>
        <span class="comment">//   - cookie.setMaxAge(24 * 3600);</span>
        <span class="comment">//   - cookie.setAttribute(&quot;SameSite&quot;, &quot;Lax&quot;);</span>
        <span class="comment">//   - servletResponse.addCookie(cookie);</span>
        HttpCookie cookie = HttpCookie.build(<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">value</span><span class="delimiter">&quot;</span></span>)
            .domain(<span class="string"><span class="delimiter">&quot;</span><span class="content">example.org</span><span class="delimiter">&quot;</span></span>)
            .path(<span class="string"><span class="delimiter">&quot;</span><span class="content">/path</span><span class="delimiter">&quot;</span></span>)
            .maxAge(<span class="predefined-type">Duration</span>.ofDays(<span class="integer">1</span>).toSeconds())
            .sameSite(HttpCookie.SameSite.LAX)
            .build();
        Response.addCookie(response, cookie);

        <span class="comment">// Sets the response Content-Type.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.setContentType(type)</span>
        responseHeaders.put(HttpHeader.CONTENT_TYPE, <span class="string"><span class="delimiter">&quot;</span><span class="content">text/plain; charset=UTF-8</span><span class="delimiter">&quot;</span></span>);

        <span class="comment">// Sets the response Content-Length.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.setContentLength(length)</span>
        <span class="comment">//   - servletResponse.setContentLengthLong(length)</span>
        responseHeaders.put(HttpHeader.CONTENT_LENGTH, <span class="integer">1024L</span>);

        <span class="comment">// Sets/Gets the response trailers.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.setTrailerFields(() -&gt; trailers)</span>
        <span class="comment">//   - servletResponse.getTrailerFields()</span>
        HttpFields trailers = HttpFields.build().put(<span class="string"><span class="delimiter">&quot;</span><span class="content">checksum</span><span class="delimiter">&quot;</span></span>, <span class="hex">0xCAFE</span>);
        response.setTrailersSupplier(trailers);
        Supplier&lt;HttpFields&gt; trailersSupplier = response.getTrailersSupplier();

        <span class="comment">// Gets whether the response is committed.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.isCommitted()</span>
        <span class="type">boolean</span> committed = response.isCommitted();

        <span class="comment">// Resets the response.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.reset();</span>
        response.reset();

        <span class="comment">// Sends a redirect response.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.encodeRedirectURL(location)</span>
        <span class="comment">//   - servletResponse.sendRedirect(location)</span>
        <span class="predefined-type">String</span> location = Request.toRedirectURI(request, <span class="string"><span class="delimiter">&quot;</span><span class="content">/redirect</span><span class="delimiter">&quot;</span></span>);
        Response.sendRedirect(request, response, callback, location);

        <span class="comment">// Sends an error response.</span>
        <span class="comment">// Replaces:</span>
        <span class="comment">//   - servletResponse.sendError(code);</span>
        <span class="comment">//   - servletResponse.sendError(code, message);</span>
        Response.writeError(request, response, callback, HttpStatus.SERVICE_UNAVAILABLE_503, <span class="string"><span class="delimiter">&quot;</span><span class="content">Request Cannot be Processed</span><span class="delimiter">&quot;</span></span>);

        callback.succeeded();
        <span class="keyword">return</span> <span class="predefined-constant">true</span>;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pg-handler-response-content-apis"><a class="anchor" href="#pg-handler-response-content-apis"></a><a class="link" href="#pg-handler-response-content-apis">Handler Response Content APIs</a></h5>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Produces an implicit response with status code 200</span>
    <span class="comment">// with no content when returning from this method.</span>

    <span class="comment">// The Handler callback must be completed when returning true.</span>
    callback.succeeded();
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Produces an implicit response with status 204</span>
    <span class="comment">// with no content when returning from this method.</span>
    response.setStatus(HttpStatus.NO_CONTENT_204);

    <span class="comment">// The Handler callback must be completed when returning true.</span>
    callback.succeeded();
    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    <span class="comment">// Produces an explicit response with status 204 with no content.</span>
    response.setStatus(HttpStatus.NO_CONTENT_204);

    <span class="comment">// This explicit first write() writes the response status code and headers.</span>
    <span class="comment">// It is also the last write (as specified by the first parameter)</span>
    <span class="comment">// and writes an empty content (the second parameter, a null ByteBuffer).</span>
    <span class="comment">// When this write completes, the Handler callback is completed.</span>
    response.write(<span class="predefined-constant">true</span>, <span class="predefined-constant">null</span>, callback);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    response.setStatus(HttpStatus.OK_200);

    <span class="predefined-type">ByteBuffer</span> content = UTF_8.encode(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>);

    <span class="comment">// Explicit first write that writes the response status code, headers and content.</span>
    <span class="comment">// When this write completes, the Handler callback is completed.</span>
    response.write(<span class="predefined-constant">true</span>, content, callback);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}
<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    response.setStatus(HttpStatus.OK_200);

    <span class="predefined-type">ByteBuffer</span> content = UTF_8.encode(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>);
    response.getHeaders().put(HttpHeader.CONTENT_LENGTH, content.remaining());

    <span class="comment">// Flush the response status code and the headers (no content).</span>
    <span class="comment">// This is the fist but non-last write.</span>
    <span class="predefined-type">Callback</span>.Completable completable = <span class="keyword">new</span> <span class="predefined-type">Callback</span>.Completable();
    response.write(<span class="predefined-constant">false</span>, <span class="predefined-constant">null</span>, completable);

    <span class="comment">// When the first write completes, perform the second (and last) write.</span>
    completable.whenComplete((ignored, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Now explicitly write the content as the last write.</span>
            <span class="comment">// When this write completes, the Handler callback is completed.</span>
            response.write(<span class="predefined-constant">true</span>, content, callback);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Implicitly respond with status code 500.</span>
            callback.failed(failure);
        }
    });

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    response.setStatus(HttpStatus.OK_200);

    <span class="comment">// Utility method to write UTF-8 string content.</span>
    <span class="comment">// When this write completes, the Handler callback is completed.</span>
    Content.Sink.write(response, <span class="predefined-constant">true</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>, callback);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    response.setStatus(HttpStatus.OK_200);

    <span class="comment">// Utility method to echo the content from the request to the response.</span>
    <span class="comment">// When the echo completes, the Handler callback is completed.</span>
    Content.copy(request, response, callback);

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">boolean</span> handle(Request request, Response response, <span class="predefined-type">Callback</span> callback) <span class="directive">throws</span> <span class="exception">Exception</span>
{
    response.setStatus(HttpStatus.OK_200);

    <span class="comment">// The trailers must be set on the response before the first write.</span>
    HttpFields.Mutable trailers = HttpFields.build();
    response.setTrailersSupplier(trailers);

    <span class="comment">// Explicit first write that writes the response status code, headers and content.</span>
    <span class="comment">// The trailers have not been written yet; they will be written with the last write.</span>
    <span class="predefined-type">ByteBuffer</span> content = UTF_8.encode(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>);
    <span class="predefined-type">Callback</span>.Completable completable = <span class="keyword">new</span> <span class="predefined-type">Callback</span>.Completable();
    response.write(<span class="predefined-constant">false</span>, content, completable);

    completable.whenComplete((ignored, failure) -&gt;
    {
        <span class="keyword">if</span> (failure == <span class="predefined-constant">null</span>)
        {
            <span class="comment">// Update the trailers</span>
            trailers.put(<span class="string"><span class="delimiter">&quot;</span><span class="content">Content-Checksum</span><span class="delimiter">&quot;</span></span>, <span class="hex">0xCAFE</span>);

            <span class="comment">// Explicit last write to write the trailers</span>
            <span class="comment">// and complete the Handler callback.</span>
            response.write(<span class="predefined-constant">true</span>, <span class="predefined-constant">null</span>, callback);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">// Implicitly respond with status code 500.</span>
            callback.failed(failure);
        }
    });

    <span class="keyword">return</span> <span class="predefined-constant">true</span>;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pg-migration-11-to-12-api-changes"><a class="anchor" href="#pg-migration-11-to-12-api-changes"></a><a class="link" href="#pg-migration-11-to-12-api-changes">APIs Changes</a></h4>
<div class="sect4">
<h5 id="pg-httpclient"><a class="anchor" href="#pg-httpclient"></a><a class="link" href="#pg-httpclient"><code>HttpClient</code></a></h5>
<div class="paragraph">
<p>The Jetty 11 <code>Request.onResponseContentDemanded(Response.DemandedContentListener)</code> API has been replaced by <code>Request.onResponseContentSource(Response.ContentSourceListener)</code> in Jetty 12.</p>
</div>
<div class="paragraph">
<p>However, also look at <code>Request.onResponseContentAsync(Response.AsyncContentListener)</code> and <code>Request.onResponseContent(Response.ContentListener)</code> for simpler usages.</p>
</div>
<div class="paragraph">
<p>The Jetty 11 model was a "demand+push" model: the application was demanding content; when the content was available, the implementation was pushing content to the application by calling <code>DemandedContentListener.onContent(Response, LongConsumer, ByteBuffer, Callback)</code> for every content chunk.</p>
</div>
<div class="paragraph">
<p>The Jetty 12 model is a "demand+pull" model: when the content is available, the implementation calls once <code>Response.ContentSourceListener.onContentSource(Content.Source)</code>; the application can then pull the content chunks from the <code>Content.Source</code>.</p>
</div>
<div class="paragraph">
<p>For more information about the new model, see <a href="#pg-arch-io-content-source">this section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="pg-websocket"><a class="anchor" href="#pg-websocket"></a><a class="link" href="#pg-websocket">WebSocket</a></h5>
<div class="paragraph">
<p>The Jetty WebSocket APIs have been vastly simplified, and brought in line with the style of other APIs.</p>
</div>
<div class="paragraph">
<p>The Jetty 12 WebSocket APIs are now fully asynchronous, so the Jetty 11 <code>SuspendToken</code> class has been removed in favor of an explicit (or automatic) demand mechanism in Jetty 12 (for more information, refer to <a href="#pg-websocket-endpoints-demand">this section</a>).</p>
</div>
<div class="paragraph">
<p>The various Jetty 11 <code>WebSocket*Listener</code> interfaces have been replaced by a single interface in Jetty 12, <code>Session.Listener.AutoDemanding</code> (for more information, refer to <a href="#pg-websocket-endpoints-listener">this section</a>).</p>
</div>
<div class="paragraph">
<p>The Jetty 11 <code>RemoteEndpoint</code> APIs have been merged into the <code>Session</code> APIs in Jetty 12.</p>
</div>
<div class="paragraph">
<p>The Jetty 11 <code>WriteCallback</code> class has been renamed to just <code>Callback</code> in Jetty 12, because it is now also used when receiving binary data.
Note that this <code>Callback</code> interface is a different interface from the <code>org.eclipse.jetty.util.Callback</code> interface, which cannot be used in the Jetty WebSocket APIs due to class loader visibility issues.</p>
</div>
<div class="paragraph">
<p>On the server-side, the Jetty WebSocket APIs have been made independent of the Servlet APIs.</p>
</div>
<div class="paragraph">
<p>Jetty 11 <code>JettyWebSocketServerContainer</code> has been replaced by <code>ServerWebSocketContainer</code> in Jetty 12, with similar APIs (for more information, refer to <a href="#pg-server-websocket-jetty">this section</a>).</p>
</div>
<div class="paragraph">
<p>On the client-side the <code>WebSocketClient</code> APIs are practically unchanged, as most of the changes come from the <code>HttpClient</code> changes described above.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 12.0.10-SNAPSHOT<br>
Last updated 2023-12-05 16:42:05 -0200
</div>
</div>
</body>
</html>